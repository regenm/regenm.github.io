<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="Regen&#39;s blogs" />
       
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Data Structure and Algorithm |  Regen</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/touxiang.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Data-Structure-and-Algorithm"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Data Structure and Algorithm
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/12/Data-Structure-and-Algorithm/" class="article-date">
  <time datetime="2023-11-12T13:58:40.000Z" itemprop="datePublished">2023-11-12</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">8.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">39 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h3><blockquote>
<p>​		哈夫曼算法：</p>
<ol>
<li>构造 n 棵二叉树森林，每一个都是带权值的根节点。</li>
<li>选择权值最小的两棵树作为左右子树，其根节点的权值为左右子树权值之和。</li>
<li>删除这两棵树，将新的树加入森林。</li>
<li>重复操作到只剩下一棵树为止。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  基于结构体数组的哈曼树</span></span><br><span class="line"><span class="comment">*  C++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> DataType; <span class="comment">//结点权值的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HTNode</span> <span class="comment">//单个结点的信息</span></span><br><span class="line">&#123;</span><br><span class="line">  DataType weight; <span class="comment">//权值</span></span><br><span class="line">  <span class="type">int</span> parent; <span class="comment">//父节点</span></span><br><span class="line">  <span class="type">int</span> lc, rc; <span class="comment">//左右孩子</span></span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> **HuffmanCode; <span class="comment">//字符指针数组中存储的元素类型</span></span><br><span class="line">              <span class="comment">//用于存储哈夫曼编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标为1到i-1的范围找到权值最小的两个值的下标，其中s1的权值小于s2的权值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree&amp; HT, <span class="type">int</span> n, <span class="type">int</span>&amp; s1, <span class="type">int</span>&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> min;</span><br><span class="line">  <span class="comment">//找第一个最小值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; HT[i].weight &lt; HT[min].weight)</span><br><span class="line">      min = i;</span><br><span class="line">  &#125;</span><br><span class="line">  s1 = min; <span class="comment">//第一个最小值给s1</span></span><br><span class="line">  <span class="comment">//找第二个最小值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">    &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; HT[i].weight &lt; HT[min].weight&amp;&amp;i != s1)</span><br><span class="line">      min = i;</span><br><span class="line">  &#125;</span><br><span class="line">  s2 = min; <span class="comment">//第二个最小值给s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建哈夫曼树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuff</span><span class="params">(HuffmanTree&amp; HT, DataType* w, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>; <span class="comment">//哈夫曼树总结点数</span></span><br><span class="line">    </span><br><span class="line">  HT = (HuffmanTree)<span class="built_in">calloc</span>(m + <span class="number">1</span>, <span class="built_in">sizeof</span>(HTNode)); <span class="comment">//开m+1个HTNode，因为下标为0的HTNode不存储数据</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    HT[i].weight = w[i - <span class="number">1</span>]; <span class="comment">//赋权值给n个叶子结点</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) <span class="comment">//构建哈夫曼树</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//选择权值最小的s1和s2，生成它们的父结点</span></span><br><span class="line">    <span class="type">int</span> s1, s2;</span><br><span class="line">    <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2); <span class="comment">//在下标为1到i-1的范围找到权值最小的两个值的下标，其中s1的权值小于s2的权值</span></span><br><span class="line">    HT[i].weight = HT[s1].weight + HT[s2].weight; <span class="comment">//i的权重是s1和s2的权重之和</span></span><br><span class="line">    HT[s1].parent = i; <span class="comment">//s1的父亲是i</span></span><br><span class="line">    HT[s2].parent = i; <span class="comment">//s2的父亲是i</span></span><br><span class="line">    HT[i].lc = s1; <span class="comment">//左孩子是s1</span></span><br><span class="line">    HT[i].rc = s2; <span class="comment">//右孩子是s2</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//打印哈夫曼树中各结点之间的关系</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;哈夫曼树为:&gt;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;下标   权值     父结点   左孩子   右孩子\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;0                                  \n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-4d   %-6.2lf   %-6d   %-6d   %-6d\n&quot;</span>, i, HT[i].weight, HT[i].parent, HT[i].lc, HT[i].rc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成哈夫曼编码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffCoding</span><span class="params">(HuffmanTree&amp; HT, HuffmanCode&amp; HC, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HC = (HuffmanCode)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>*)*(n + <span class="number">1</span>)); <span class="comment">//开n+1个空间，因为下标为0的空间不用</span></span><br><span class="line">  <span class="type">char</span>* code = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*n); <span class="comment">//辅助空间，编码最长为n(最长时，前n-1个用于存储数据，最后1个用于存放&#x27;\0&#x27;)</span></span><br><span class="line">  code[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//辅助空间最后一个位置为&#x27;\0&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> start = n - <span class="number">1</span>; <span class="comment">//每次生成数据的哈夫曼编码之前，先将start指针指向&#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">int</span> c = i; <span class="comment">//正在进行的第i个数据的编码</span></span><br><span class="line">    <span class="type">int</span> p = HT[c].parent; <span class="comment">//找到该数据的父结点</span></span><br><span class="line">    <span class="keyword">while</span> (p) <span class="comment">//直到父结点为0，即父结点为根结点时，停止</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (HT[p].lc == c) <span class="comment">//如果该结点是其父结点的左孩子，则编码为0，否则为1</span></span><br><span class="line">        code[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        code[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">      c = p; <span class="comment">//继续往上进行编码</span></span><br><span class="line">      p = HT[c].parent; <span class="comment">//c的父结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    HC[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*(n - start)); <span class="comment">//开辟用于存储编码的内存空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(HC[i], &amp;code[start]); <span class="comment">//将编码拷贝到字符指针数组中的相应位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(code); <span class="comment">//释放辅助空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入数据个数:&gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  DataType* w = (DataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DataType)*n);</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入数据:&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  HuffmanTree HT;</span><br><span class="line">  <span class="built_in">CreateHuff</span>(HT, w, n); <span class="comment">//构建哈夫曼树</span></span><br><span class="line"></span><br><span class="line">  HuffmanCode HC;</span><br><span class="line">  <span class="built_in">HuffCoding</span>(HT, HC, n); <span class="comment">//构建哈夫曼编码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//打印哈夫曼编码</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据%.2lf的编码为:%s\n&quot;</span>, HT[i].weight, HC[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(w);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树：求树的高度"><a href="#二叉树：求树的高度" class="headerlink" title="二叉树：求树的高度"></a>二叉树：求树的高度</h3><ol>
<li>递归</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetHeight</span><span class="params">(BinTree BT)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BT) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(GetHeight(BT-&gt;Left),GetHeight(BT-&gt;Right))+<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetHeight</span><span class="params">( BinTree BT )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    BinTree arr[<span class="number">100</span>];</span><br><span class="line">    BinTree tmpFront;</span><br><span class="line">    <span class="type">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h=<span class="number">0</span>;</span><br><span class="line">    arr[rear++]=BT;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nextCount=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(front!=rear)&#123;</span><br><span class="line">        h++;</span><br><span class="line">        count=nextCount;</span><br><span class="line">        nextCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">            tmpFront=arr[front++];</span><br><span class="line">            <span class="keyword">if</span>(tmpFront-&gt;Left)&#123;</span><br><span class="line">                arr[rear++]=tmpFront-&gt;Left;</span><br><span class="line">                nextCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpFront-&gt;Right)&#123;</span><br><span class="line">                arr[rear++]=tmpFront-&gt;Right;</span><br><span class="line">                nextCount++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树：顺序存储"><a href="#二叉树：顺序存储" class="headerlink" title="二叉树：顺序存储"></a>二叉树：顺序存储</h3><p>​	存储按照完全二叉树来（遇到空节点则 赋值 isEmpty 为 true）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">   ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">   <span class="type">bool</span> isEmpty;   <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   TreeNode t[MaxSize];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">      t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入:ABC##DE#G##F###</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">(BiTree *T)</span>  <span class="comment">//创建二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">  <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)		<span class="comment">//判断该字符ch是不是为&#x27;#&#x27;,意思是该节点是不是空的</span></span><br><span class="line">    *T=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));	<span class="comment">//为结点T申请空间</span></span><br><span class="line">    (*T)-&gt;data=ch;		<span class="comment">//将ch的值赋给(*T)-&gt;data</span></span><br><span class="line">    creat(&amp;(*T)-&gt;lchild);</span><br><span class="line">    creat(&amp;(*T)-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li><strong>二叉树：先序遍历</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">       </span><br><span class="line">      PreOrder(T-&gt;lchild);      <span class="comment">//递归遍历左子树</span></span><br><span class="line">      PreOrder(T-&gt;rchild);      <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">//遍历失败，根节点空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p><strong>二叉树：中序遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ShowZhongXu</span><span class="params">(BitTree T)</span>      <span class="comment">//		先序遍历二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)						<span class="comment">//	递归中遇到NULL，返回上一层节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  ShowZhongXu(T-&gt;lchild);			<span class="comment">//	递归遍历左子树</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);</span><br><span class="line">  ShowZhongXu(T-&gt;rchild);			<span class="comment">//	递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树：后序遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ShowZhongXu</span><span class="params">(BitTree T)</span>      <span class="comment">//		先序遍历二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)						<span class="comment">//	递归中遇到NULL，返回上一层节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;					<span class="comment">// 空根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  ShowZhongXu(T-&gt;lchild);			<span class="comment">//	递归遍历左子树</span></span><br><span class="line">  ShowZhongXu(T-&gt;rchild);			<span class="comment">//	递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>二叉树：层序遍历</strong></li>
</ul>
<ul>
<li>使用队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   LinkQueue Q;</span><br><span class="line">   InitQueue (Q);          <span class="comment">//初始化辅助队列</span></span><br><span class="line">    </span><br><span class="line">   BiTree p;</span><br><span class="line">   EnQueue(Q,T);           <span class="comment">//将根节点入队</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">while</span>(!isEmpty(Q))&#123;     <span class="comment">//队列不空则循环</span></span><br><span class="line">      DeQueue(Q,p);        <span class="comment">//队头结点出队</span></span><br><span class="line">      visit(p);            <span class="comment">//访问出队结点</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;lchild);   <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;rchild);   <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树交换左右孩子"><a href="#二叉树交换左右孩子" class="headerlink" title="二叉树交换左右孩子"></a>二叉树交换左右孩子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似于先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    BiTNode *m=T-&gt;lchild;<span class="comment">/*这三行类似于&quot;打擂台法&quot;*/</span></span><br><span class="line">    T-&gt;lchild=T-&gt;rchild;</span><br><span class="line">    T-&gt;rchild=m;			</span><br><span class="line">    swap(T-&gt;lchild);</span><br><span class="line">    swap(T-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求二叉树高度-深度"><a href="#求二叉树高度-深度" class="headerlink" title="求二叉树高度(深度)"></a>求二叉树高度(深度)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">( BiTree T )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> countl =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> countr =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        countl=Depth( T-&gt;lchild );</span><br><span class="line">        countr=Depth( T-&gt;rchild );</span><br><span class="line">        max=countl&gt;countr? countl:countr;</span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><blockquote>
<p>将空的指针域用以指向前驱后继节点。</p>
<p>遵循：</p>
<ul>
<li>ltag&#x3D;&#x3D;0，指向左孩子；ltag&#x3D;&#x3D;1，指向前驱结点</li>
<li>rtag&#x3D;&#x3D;0，指向右孩子；rtag&#x3D;&#x3D;1，指向后继结点</li>
</ul>
</blockquote>
<pre><code>    1. 二叉树的线索化
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderThreadTree</span><span class="params">(Node* node)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//如果当前结点为NULL 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//先处理左子树</span></span><br><span class="line">  inOrderThreadTree(node-&gt;left_node);</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;left_node == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置前驱结点</span></span><br><span class="line">    node-&gt;left_type = <span class="number">1</span>;</span><br><span class="line">    node-&gt;left_node = pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果结点的右子节点为NULL 处理前驱的右指针</span></span><br><span class="line">  <span class="keyword">if</span> (pre !=<span class="literal">NULL</span> &amp;&amp; pre-&gt;right_node == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置后继</span></span><br><span class="line">    pre-&gt;right_node = node;</span><br><span class="line">    pre-&gt;right_type = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//每处理一个节点 当前结点是下一个节点的前驱</span></span><br><span class="line">  pre = node;</span><br><span class="line">  <span class="comment">//最后处理右子树</span></span><br><span class="line">  inOrderThreadTree(node-&gt;right_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>中序遍历线索二叉树</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraverse</span><span class="params">(Node* root)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//从根节点开始先找到最左边</span></span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node* temp = root;</span><br><span class="line">  <span class="comment">//先找到最左边结点 然后根据线索化直接向右遍历</span></span><br><span class="line">  <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;left_type == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    temp = temp-&gt;left_node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    temp = temp-&gt;right_node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><strong>线索二叉树操作集合</strong></p>
<ol>
<li>结构体</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>主函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreorderTraversal</span><span class="params">( BinTree BT )</span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InorderTraversal</span><span class="params">( BinTree BT )</span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line">BinTree <span class="title function_">Insert</span><span class="params">( BinTree BST, ElementType X )</span>;</span><br><span class="line">BinTree <span class="title function_">Delete</span><span class="params">( BinTree BST, ElementType X )</span>;</span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( BinTree BST, ElementType X )</span>;</span><br><span class="line">Position <span class="title function_">FindMin</span><span class="params">( BinTree BST )</span>;</span><br><span class="line">Position <span class="title function_">FindMax</span><span class="params">( BinTree BST )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="type">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = Insert(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Preorder:&quot;</span>); PreorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    MinP = FindMin(BST);</span><br><span class="line">    MaxP = FindMax(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        Tmp = Find(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d is not found\n&quot;</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is found\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the smallest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the largest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = Delete(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inorder:&quot;</span>); InorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>操作集合</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line">BinTree <span class="title function_">Insert</span><span class="params">( BinTree BST, ElementType X )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>) &#123;          <span class="comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span></span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTree));</span><br><span class="line">        BST -&gt;Data = X;</span><br><span class="line">        BST -&gt;Left = BST -&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;         <span class="comment">/* 开始寻找要插入元素的位置 */</span></span><br><span class="line">        <span class="keyword">if</span>(X &lt; BST -&gt;Data ) &#123;</span><br><span class="line">            BST -&gt;Left = Insert(BST -&gt;Left, X);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST -&gt;Data ) &#123;</span><br><span class="line">            BST -&gt;Right = Insert(BST -&gt;Right, X);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* X已经存在，不用操作 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">BinTree <span class="title function_">Delete</span><span class="params">( BinTree BST, ElementType X )</span>&#123;</span><br><span class="line">    BinTree Tmp;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>)    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data)  </span><br><span class="line">            BST -&gt;Left = Delete(BST-&gt;Left, X);          <span class="comment">/* 左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data ) </span><br><span class="line">            BST -&gt;Right = Delete(BST-&gt;Right , X);       <span class="comment">/* 右子树递归删除*/</span></span><br><span class="line">        <span class="keyword">else</span> &#123;                                          <span class="comment">/* 找到需要删除的结点 */</span></span><br><span class="line">            <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123;               <span class="comment">/* 被删除的结点有左右子结点 */</span></span><br><span class="line">                Tmp=FindMin(BST-&gt;Right);                <span class="comment">/* 在右子树中找到最小结点填充删除结点 */</span></span><br><span class="line">                BST-&gt;Data = Tmp -&gt;Data;</span><br><span class="line">                BST-&gt;Right=Delete(BST-&gt;Right,BST-&gt;Data);<span class="comment">/* 递归删除要删除结点的右子树中最小元素 */</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;                                     <span class="comment">/* 被删除结点有一个或没有子结点*/</span></span><br><span class="line">                Tmp = BST;</span><br><span class="line">                <span class="keyword">if</span>(!BST-&gt;Left) BST = BST-&gt;Right;        <span class="comment">/*有右孩子或者没孩子*/</span> </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)    BST = BST-&gt;Left;<span class="comment">/*有左孩子，一定要加else，不然BST可能是NULL，会段错误*/</span> </span><br><span class="line">                <span class="built_in">free</span>(Tmp);                              <span class="comment">/*如无左右孩子直接删除*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( BinTree BST, ElementType X )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(BST-&gt;Data==X)    <span class="keyword">return</span> BST; </span><br><span class="line">    <span class="keyword">if</span>(X&gt;BST-&gt;Data)     <span class="keyword">return</span> Find(BST-&gt;Right,X);      </span><br><span class="line">    <span class="keyword">if</span>(X&lt;BST-&gt;Data)     <span class="keyword">return</span> Find(BST-&gt;Left,X);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*  以下几种写法均可，推荐第上面这一种 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(!BST)    return NULL;</span></span><br><span class="line"><span class="comment">    if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">    if(X&gt;BST-&gt;Data)     Find(BST-&gt;Right,X);     </span></span><br><span class="line"><span class="comment">    if(X&lt;BST-&gt;Data)     Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(BST)&#123;</span></span><br><span class="line"><span class="comment">        if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">        if(X&gt;BST-&gt;Data)     Find(BST-&gt;Right,X);     //如果不写return，则返回过来的值并没有继续返回给最开始的函数 </span></span><br><span class="line"><span class="comment">        if(X&lt;BST-&gt;Data)     Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    else return NULL;   </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(BST)&#123;</span></span><br><span class="line"><span class="comment">        if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">        if(X&gt;BST-&gt;Data)     return  Find(BST-&gt;Right,X); </span></span><br><span class="line"><span class="comment">        if(X&lt;BST-&gt;Data)     return  Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    return NULL;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(BST)&#123;</span></span><br><span class="line"><span class="comment">        if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">        if(X&gt;BST-&gt;Data)     return Find(BST-&gt;Right,X);      </span></span><br><span class="line"><span class="comment">        if(X&lt;BST-&gt;Data)     return Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    else return NULL;</span></span><br><span class="line"><span class="comment">    */</span>                          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果return NULL前面不写else且Find前也不写else，则最后递归返回的也没return，最后只能是执行到了return NULL</span></span><br><span class="line"><span class="comment">返回了，而如果find 前加上了return则就把递归的结果利用起来了，最后加不加else也无所谓了，而如果直接最后else，</span></span><br><span class="line"><span class="comment">不加return find也是可以的，加上了else之后就不会被每一次返回时最后的return NULL给覆盖掉，所以也行。 */</span> </span><br><span class="line">Position <span class="title function_">FindMin</span><span class="params">( BinTree BST )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Left)&#123;</span><br><span class="line">            BST=BST-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> BST; </span><br><span class="line">&#125; </span><br><span class="line">Position <span class="title function_">FindMax</span><span class="params">( BinTree BST )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right)&#123;</span><br><span class="line">            BST=BST-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> BST; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>​	 	主要用于解决一些<strong>元素分组</strong>的问题。也可以用来判断图的连通性，它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p>
<ul>
<li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li>
<li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//最简单版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *当数据很多时，查找会很耗费时间</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x) father[x]=find(father[x]);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;           <span class="comment">//查找根节点的函数 </span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  升级版</span></span><br><span class="line"><span class="comment">    *  带路径压缩功能</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">  a=x;</span><br><span class="line">  <span class="keyword">while</span>(x!=father[x])x=father[x];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(a!=father[a])&#123;    <span class="comment">//路径压缩 </span></span><br><span class="line">    <span class="type">int</span> z=a;</span><br><span class="line">    a=father[a];</span><br><span class="line">    father[z]=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123; </span><br><span class="line">                <span class="comment">//合并两个集合</span></span><br><span class="line">    <span class="type">int</span> fx=find(a);</span><br><span class="line">    <span class="type">int</span> fy=find(b);</span><br><span class="line">    father[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">judgeConnect</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//判断连通性</span></span><br><span class="line">    <span class="type">int</span> i,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=vertex;i++)</span><br><span class="line">        <span class="keyword">if</span>(father[i]==i) k++;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOE图"><a href="#AOE图" class="headerlink" title="AOE图"></a>AOE图</h3><blockquote>
<p><em>concept:</em></p>
<p>1、<strong>最早发生</strong>时间：从前往后，前驱结点到当前结点所需时间，取<strong>最大值</strong>；</p>
<p>2、<strong>最迟发生</strong>时间：从后往前，后继结点的最迟时间减去边权的值，取<strong>最小值</strong>；</p>
<p><strong>结束节点的最早发生时间和最迟发生时间相同。</strong></p>
<p>3、关键路径：最早发生时间和最迟发生时间相同的结点叫做关键路径上的结点；</p>
<p>4、<strong>最早开始</strong>时间：等于当前边起始节点的最早发生时间；</p>
<p>5、<strong>最晚开始</strong>时间：等于当前便指向结点的最迟时间减去当前边的权值；</p>
<p>6、<strong>最早完工</strong>时间：等于当前边指向结点的最早发生时间；</p>
<p>7、<strong>最晚完工</strong>时间：等于当前边指向结点的最迟发生时间；</p>
</blockquote>
<h3 id="图的链式存储结构"><a href="#图的链式存储结构" class="headerlink" title="图的链式存储结构"></a>图的链式存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100                                 <span class="comment">//最大顶点数 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>                        <span class="comment">//表结点 </span></span><br><span class="line">    <span class="type">int</span> adjvex;                                    <span class="comment">//邻接点的位置 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span>      <span class="comment">//指向下一个表结点的指针 </span></span><br><span class="line">  &#125;ArcNode; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span> </span><br><span class="line">   <span class="type">char</span> data;                                    <span class="comment">//顶点信息 </span></span><br><span class="line">   ArcNode * firstarc;         <span class="comment">//指向第一个表结点的指针 </span></span><br><span class="line">&#125;VNode, AdjList[MVNum];                 <span class="comment">//AdjList表示邻接表类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    AdjList vertices;              <span class="comment">//头结点数组</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;     <span class="comment">//图的当前顶点数和边数 </span></span><br><span class="line">&#125;ALGraph; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatMGraph</span><span class="params">(ALGraph *G)</span>;<span class="comment">/* 创建图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(ALGraph G)</span>;<span class="comment">/*输出图 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    CreatMGraph(&amp;G);</span><br><span class="line">    printGraph(G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatMGraph</span><span class="params">(ALGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;G-&gt;vexnum,&amp;G-&gt;arcnum);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;G-&gt;vertices[i].data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">         G-&gt;vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;arcnum;k++) &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);    </span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;nextarc=G-&gt;vertices[i].firstarc;</span><br><span class="line"></span><br><span class="line">        G-&gt;vertices[i].firstarc=s;   </span><br><span class="line"></span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=i;</span><br><span class="line"></span><br><span class="line">        s-&gt;nextarc=G-&gt;vertices[j].firstarc;;</span><br><span class="line">        G-&gt;vertices[j].firstarc=s;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(ALGraph G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%c:&quot;</span>,G.vertices[i].data);</span><br><span class="line">       <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot; %c&quot;</span>,G.vertices[p-&gt;adjvex].data);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找（搜索）"><a href="#查找（搜索）" class="headerlink" title="查找（搜索）"></a>查找（搜索）</h2><h3 id="折半搜索"><a href="#折半搜索" class="headerlink" title="折半搜索"></a>折半搜索</h3><blockquote>
<p>因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> x, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];<span class="comment">//0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> re=BinSearch(arr,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;下标：%d\n&quot;</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//按折半查找法查找值为x的数组元素，若找到则返回x在数组中的下标位置，否则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = n<span class="number">-1</span>, mid;<span class="comment">//区间左端点low置为0，右端点high置为n-1</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)      <span class="comment">//若左端点小于等于右端点，则继续查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;<span class="comment">//取数据区间的重点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mid);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="built_in">array</span>[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>;      <span class="comment">//若x&gt;array[mid]，则修改区间的左端点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="built_in">array</span>[mid])</span><br><span class="line">            high = mid - <span class="number">1</span>;      <span class="comment">//若x&lt;array[mid]，则修改区间的右端点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;次数：%d\n&quot;</span>,num);</span><br><span class="line">            <span class="keyword">return</span> mid;        <span class="comment">//若找到，则返回下标值mid</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;            <span class="comment">//循环结束仍未找到，则返回值-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><blockquote>
<p>类似于折半搜索，只是mid的计算方法不一样</p>
<p>比较元素的下标：</p>
<p>Mid &#x3D; Begin + ( (End - Begin) &#x2F; (A[End] - A[Begin]) ) * (X - A[Begin])</p>
<blockquote>
<p>式子中，各部分的含义分别是：</p>
<p>Mid：计算得出的元素的位置；</p>
<p>End：搜索区域内最后一个元素所在的位置；</p>
<p>Begin：搜索区域内第一个元素所在的位置；</p>
<p>X：要查找的目标元素；</p>
<p>A[]：表示整个待搜索序列</p>
</blockquote>
</blockquote>
<p>C语言实现过程</p>
<p>​	<strong>递归算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//实现插值查找算法，ele 表示要查找的目标元素，[begin,end] 指定查找区域</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">interpolation_search</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> ele)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果[begin,end] 不存在，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果搜索区域内只有一个元素，判断其是否为目标元素</span></span><br><span class="line">    <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ele == arr[begin]) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该元素非目标元素，则查找失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到&quot;中间元素&quot;所在的位置</span></span><br><span class="line">    mid = begin + ((end - begin) / (arr[end] - arr[begin]) * (ele - arr[begin]));</span><br><span class="line">    <span class="comment">//递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> (ele == arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较 ele 和 arr[mid] 的值，缩小 ele 可能存在的区域</span></span><br><span class="line">    <span class="keyword">if</span> (ele &lt; arr[mid]) &#123;</span><br><span class="line">        <span class="comment">//新的搜索区域为 [begin,mid-1]</span></span><br><span class="line">        <span class="keyword">return</span> interpolation_search(arr, begin, mid - <span class="number">1</span>, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//新的搜索区域为 [mid+1,end]</span></span><br><span class="line">        <span class="keyword">return</span> interpolation_search(arr, mid + <span class="number">1</span>, end, ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="comment">//输出元素 2 所在位置的下标</span></span><br><span class="line">    <span class="type">int</span> pos = interpolation_search(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, interpolation_search(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><blockquote>
<ol>
<li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li>
<li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li>
<li>左、右子树也分别是一棵二叉排序树。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> data;	<span class="comment">//结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *Bitree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归查找二叉排序树T中是否存在key</span></span><br><span class="line"><span class="comment">指针f指向T的双亲，其初始调用值为NULL</span></span><br><span class="line"><span class="comment">若查找成功，则指针p指向该数据元素结点，并返回TRUE</span></span><br><span class="line"><span class="comment">否则指针p指向查找路径上访问的最后一个结点并返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SearchBST</span><span class="params">(BiTree T, <span class="type">int</span> key, BiTree f, BiTree *p)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">    *p = f;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">    <span class="comment">//查找成功</span></span><br><span class="line">    *p = T;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">    <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);	<span class="comment">//在左子树继续查找</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);	<span class="comment">//在右子树继续查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当二叉排序树T中不存在关键字等于key的数据元素时</span></span><br><span class="line"><span class="comment">插入key并返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">  BiTree p, s;</span><br><span class="line">  <span class="keyword">if</span>(!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p))&#123;</span><br><span class="line">    <span class="comment">//查找不成功</span></span><br><span class="line">    s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    s-&gt;data = key;</span><br><span class="line">    s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">      *T = s;	<span class="comment">//插入s为新的根节点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p-&gt;data)&#123;</span><br><span class="line">      p-&gt;lchild = s;	<span class="comment">//插入s为左孩子</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      p-&gt;rchild = s;	<span class="comment">//插入s为右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;	<span class="comment">//树种已有关键字相同的结点，不再插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************构造二叉排序树************/</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span>&#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  InsertBST(&amp;T, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点，</span></span><br><span class="line"><span class="comment">并返回TRUE;否则返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE; </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">      <span class="comment">//找到关键字等于key的数据元素</span></span><br><span class="line">      <span class="keyword">return</span> Delete(T);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T -&gt; data)&#123;</span><br><span class="line">      <span class="keyword">return</span> DeleteBST(T -&gt; lchild, key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DeleteBST(T -&gt; rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="哈希表（散列表）"><a href="#哈希表（散列表）" class="headerlink" title="哈希表（散列表）"></a>哈希表（散列表）</h3><blockquote>
<p>​	散列表是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>
<p>​	这种对应关系称为散列函数，又称为哈希(Hash) 函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。那么关键字对应的记录存储位置我们称为散列地址。</p>
</blockquote>
<h4 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h4><ol>
<li>直接定址法</li>
</ol>
<p>​				直接取关键字的某个线性函数值为散列地址，散列函数为：<br>$$<br>H(key)&#x3D;key或H(key)&#x3D;a∗key+b<br>$$</p>
<ol start="2">
<li>数字分析法</li>
</ol>
<blockquote>
<p>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址。</p>
</blockquote>
<ol start="3">
<li>平方取中法</li>
</ol>
<blockquote>
<p>平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p>
<p>字面意思：平方之后取中间的数字作为散列地址</p>
</blockquote>
<ol start="4">
<li>除留余数法</li>
</ol>
<p>​				散列函数：</p>
<blockquote>
<p>h（key） &#x3D; key % 17</p>
<blockquote>
<ul>
<li>p取素数（避免余数相关性）</li>
</ul>
</blockquote>
</blockquote>
<ol start="5">
<li>随机数法</li>
</ol>
<p>$$<br>H(key)&#x3D;random(key)<br>$$</p>
<h4 id="处理散列冲突"><a href="#处理散列冲突" class="headerlink" title="处理散列冲突"></a>处理散列冲突</h4><p>​				开放地址法（闭散列表）和链地址法（开散列表法）</p>
<ol>
<li>线性探测法</li>
</ol>
<blockquote>
<p>从冲突的的下一个位置起，依次寻找空的散列地址</p>
<blockquote>
<ul>
<li>存在堆积现象</li>
</ul>
</blockquote>
</blockquote>
<p>​	公式：<br>$$<br>H<br>i<br>​<br> (key)&#x3D;(f(key)+d<br>i<br>​<br> )%m (d<br>i<br>​<br> &#x3D;1,2,3,…,m−1)<br>$$<br>​	此时： di &#x3D; 0,1,2,3,…k</p>
<ol start="2">
<li>二次（平方）探测法</li>
</ol>
<p>​		公式<br>$$<br>H<br>i<br>​<br> (key)&#x3D;(f(key)+d<br>i<br>​<br> )%m (d<br>i<br>​<br> &#x3D;1,2,3,…,m−1)<br>$$<br>​	此时：di &#x3D; 0,1,-1,2^2,-2^2,….k^2,-k^2</p>
<ol start="3">
<li>拉链法</li>
</ol>
<blockquote>
<p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p>
</blockquote>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//记录有序序列最后一个元素的下标</span></span><br><span class="line">    <span class="type">int</span> end = i;</span><br><span class="line">    <span class="comment">//待插入的元素</span></span><br><span class="line">    <span class="type">int</span> tem = arr[end + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//单趟排</span></span><br><span class="line">    <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//比插入的数大就向后移</span></span><br><span class="line">      <span class="keyword">if</span> (tem &lt; arr[end])</span><br><span class="line">      &#123;</span><br><span class="line">        arr[end + <span class="number">1</span>] = arr[end];</span><br><span class="line">        end--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//比插入的数小，跳出循环</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//tem放到比插入的数小的数的后面</span></span><br><span class="line">    arr[end  + <span class="number">1</span>] = tem;</span><br><span class="line">    <span class="comment">//代码执行到此位置有两种情况:</span></span><br><span class="line">    <span class="comment">//1.待插入元素找到应插入位置（break跳出循环到此）</span></span><br><span class="line">    <span class="comment">//2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：	</p>
<ul>
<li>最坏（逆序）：O(n^2)</li>
<li>最好（升序）：O(n)</li>
</ul>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> gap = n;</span><br><span class="line">  <span class="keyword">while</span> (gap&gt;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//每次对gap折半操作</span></span><br><span class="line">    gap = gap / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//单趟排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> end = i;</span><br><span class="line">      <span class="type">int</span> tem = arr[end + gap];</span><br><span class="line">      <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (tem &lt; arr[end])</span><br><span class="line">        &#123;</span><br><span class="line">          arr[end + gap] = arr[end];</span><br><span class="line">          end -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[end + gap] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度(平均)：O(N^1.3)<br>空间复杂度：O(1)</p>
</blockquote>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tem = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//保存参与单趟排序的第一个数和最后一个数的下标</span></span><br><span class="line">  <span class="type">int</span> begin = <span class="number">0</span>, end = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//保存最大值的下标</span></span><br><span class="line">    <span class="type">int</span> maxi = begin;</span><br><span class="line">    <span class="comment">//保存最小值的下标</span></span><br><span class="line">    <span class="type">int</span> mini = begin;</span><br><span class="line">    <span class="comment">//找出最大值和最小值的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[mini])</span><br><span class="line">      &#123;</span><br><span class="line">        mini = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[maxi])</span><br><span class="line">      &#123;</span><br><span class="line">        maxi = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小值放在序列开头</span></span><br><span class="line">    swap(&amp;arr[mini], &amp;arr[begin]);</span><br><span class="line">    <span class="comment">//防止最大的数在begin位置被换走</span></span><br><span class="line">    <span class="keyword">if</span> (begin == maxi)</span><br><span class="line">    &#123;</span><br><span class="line">      maxi = mini;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大值放在序列结尾</span></span><br><span class="line">    swap(&amp;arr[maxi], &amp;arr[end]);</span><br><span class="line">    ++begin;</span><br><span class="line">    --end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最坏情况：O(N^2)</li>
<li>最好情况：O(N^2)</li>
</ul>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> end = n;</span><br><span class="line">  <span class="keyword">while</span> (end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> tem = arr[i];</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">        arr[i - <span class="number">1</span>] = tem;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最坏情况：O(N^2)</li>
<li>最好情况：O(N)</li>
</ul>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>堆的分类：</p>
<ul>
<li>大根堆：每个节点的值大于或等于左右孩子节点的值</li>
<li>小根堆：每个节点的值小于或等于左右孩子节点的值</li>
</ul>
</blockquote>
<p>步骤：</p>
<ol>
<li>构造大根堆</li>
<li>顶端与末尾值交换</li>
<li>将剩下的n-1个数造次构造为大根堆，重复上述操作。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标为升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapAdjust</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tmp = arr[start];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * start + <span class="number">1</span>; i &lt;= end; i = i * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; end&amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>])<span class="comment">//有右孩子并且左孩子小于右孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;<span class="comment">//i一定是左右孩子的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; tmp)</span><br><span class="line">    &#123;</span><br><span class="line">      arr[start] = arr[i];</span><br><span class="line">      start = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[start] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//第一次建立大根堆，从后往前依次调整</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=(len<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">    HeapAdjust(arr, i, len - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//每次将根和待排序的最后一次交换，然后在调整</span></span><br><span class="line">  <span class="type">int</span> tmp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    tmp = arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = arr[len - <span class="number">1</span>-i];</span><br><span class="line">    arr[len - <span class="number">1</span> - i] = tmp;</span><br><span class="line">    HeapAdjust(arr, <span class="number">0</span>, len - <span class="number">1</span>-i- <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">96</span>,<span class="number">66</span> &#125;;</span><br><span class="line">  HeapSort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;排序后为:&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>时间复杂度：时间复杂度为O(nlogn)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="快速排序（挖坑法）"><a href="#快速排序（挖坑法）" class="headerlink" title="快速排序（挖坑法）"></a>快速排序（挖坑法）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PartSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key = arr[left];</span><br><span class="line">    <span class="type">int</span> hole = left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[hole] = arr[right];</span><br><span class="line">        hole = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[hole] = arr[left];</span><br><span class="line">        hole = left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    arr[hole] = key;</span><br><span class="line">    <span class="keyword">return</span> hole;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="快速排序（库函数直接调用法）"><a href="#快速排序（库函数直接调用法）" class="headerlink" title="快速排序（库函数直接调用法）"></a>快速排序（库函数直接调用法）</h3><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span>* base<span class="comment">/*数组名字*/</span>,<span class="type">size_t</span> num<span class="comment">/*元素个数*/</span>,<span class="type">size_t</span> width<span class="comment">/*单个元素所占字节*/</span>,<span class="type">int</span>(__cdecl*compare)(<span class="type">const</span> <span class="type">void</span>*,<span class="type">const</span> <span class="type">void</span>*)<span class="comment">/*比较函数*/</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">int</span>*)a-*(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> n,i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="type">int</span> time[n];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;time[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  qsort(time,n,<span class="keyword">sizeof</span>(<span class="type">int</span>),cmp);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,time[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> sourceArr[],<span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> midIndex, <span class="type">int</span> endIndex)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = startIndex, j=midIndex+<span class="number">1</span>, k = startIndex;</span><br><span class="line">    <span class="keyword">while</span>(i!=midIndex+<span class="number">1</span> &amp;&amp; j!=endIndex+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i != midIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j != endIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部使用递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> sourceArr[], <span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex) &#123;</span><br><span class="line">        midIndex = startIndex + (endIndex-startIndex) / <span class="number">2</span>;<span class="comment">//避免溢出int</span></span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, b[<span class="number">8</span>];</span><br><span class="line">    MergeSort(a, b, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<blockquote>
<p> 时间复杂度：O(nlogn)。</p>
<p> 空间复杂度：O(N)，归并排序需要一个与原数组相同长度的数组做辅助来排序。</p>
</blockquote>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testBS</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    inta[] = &#123;<span class="number">2</span>, <span class="number">343</span>, <span class="number">342</span>, <span class="number">1</span>, <span class="number">123</span>, <span class="number">43</span>, <span class="number">4343</span>, <span class="number">433</span>, <span class="number">687</span>, <span class="number">654</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *a_p = a;</span><br><span class="line">    <span class="comment">//计算数组长度</span></span><br><span class="line">    intsize = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    bucketSort3(a_p, size);</span><br><span class="line">    <span class="comment">//打印排序后结果</span></span><br><span class="line">    inti;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    intt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucketSort3</span><span class="params">(<span class="type">int</span> *p, intn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取数组中的最大数</span></span><br><span class="line">    intmaxNum = findMaxNum(p, n);</span><br><span class="line">    <span class="comment">//获取最大数的位数，次数也是再分配的次数。</span></span><br><span class="line">    intloopTimes = getLoopTimes(maxNum);</span><br><span class="line">    inti;</span><br><span class="line">    <span class="comment">//对每一位进行桶分配</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= loopTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort2(p, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数字的位数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLoopTimes</span><span class="params">(intnum)</span></span><br><span class="line">&#123;</span><br><span class="line">    intcount = <span class="number">1</span>;</span><br><span class="line">    inttemp = num / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        temp = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returncount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询数组中的最大数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxNum</span><span class="params">(<span class="type">int</span> *p, intn)</span></span><br><span class="line">&#123;</span><br><span class="line">    inti;</span><br><span class="line">    intmax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*(p + i) &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = *(p + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将数字分配到各自的桶中，然后按照桶的顺序输出排序结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort2</span><span class="params">(<span class="type">int</span> *p, intn, intloop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建立一组桶此处的20是预设的根据实际数情况修改</span></span><br><span class="line">    intbuckets[<span class="number">10</span>][<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//求桶的index的除数</span></span><br><span class="line">    <span class="comment">//如798个位桶index=(798/1)%10=8</span></span><br><span class="line">    <span class="comment">//十位桶index=(798/10)%10=9</span></span><br><span class="line">    <span class="comment">//百位桶index=(798/100)%10=7</span></span><br><span class="line">    <span class="comment">//tempNum为上式中的1、10、100</span></span><br><span class="line">    inttempNum = (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, loop - <span class="number">1</span>);</span><br><span class="line">    inti, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        introw_index = (*(p + i) / tempNum) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[row_index][j] == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buckets[row_index][j] = *(p + i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将桶中的数，倒回到原有数组中</span></span><br><span class="line">    intk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i][j] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *(p + k) = buckets[i][j];</span><br><span class="line">                buckets[i][j] = <span class="literal">NULL</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/dataStructureSort.webp" alt=" comparison "></p>
<h2 id="应试"><a href="#应试" class="headerlink" title="应试"></a>应试</h2><h3 id="概述作业"><a href="#概述作业" class="headerlink" title="概述作业"></a>概述作业</h3><blockquote>
<p>数据在计算机内存中的表示是指（） 。数据的存储结构</p>
<p>数据结构形式地定义为（K，R），其中K是（）的有限集合，R是K上的关系上的有限集合。数据元素</p>
<p>数据结构形式地定义为（D,S），其中D是数据元素的有限集合，S是D上的（）的有限集合。关系</p>
<p>一个广义表的表尾总是一个（ ）。广义表</p>
</blockquote>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><blockquote>
<p>对于线性表的各种操作，考虑：</p>
<ol>
<li>length与MaxSize的关系</li>
<li>length是否为零</li>
<li>输入的参数是否符合规则（大于或小于零，是否为空）</li>
</ol>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote>
<p>对于栈的各种操作，考虑：</p>
<ol>
<li>栈空或栈满的情况</li>
<li>输入的参数是否符合规则（大于或小于零，是否为空）</li>
</ol>
</blockquote>
<ul>
<li>后缀表达式</li>
</ul>
<blockquote>
<p>从左往右开始扫描中缀表达式。<br>        遇到数字直接加入后缀表达式<br>        遇到运算符时：<br>            a.若为’(‘则入栈<br>            b.若为’)’，则依次把栈中的运算符加入后缀表达式，直到出现’(’，从栈中删除’)’。<br>            c.若为除括号外的其他运算符，当其他优先级高于除’)’外的栈顶运算符时，直接入栈。<br>        否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，<br>        直到一个比它优先级低的或遇到了一个左括号为止。</p>
</blockquote>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><blockquote>
<p>对于队列的各种操作，考虑：</p>
<ol>
<li>队列空和满的情况</li>
<li>输入的参数是否符合规则（大于或小于零，是否为空）</li>
</ol>
</blockquote>
<h3 id="图-1"><a href="#图-1" class="headerlink" title="图"></a>图</h3><blockquote>
<p>用邻接矩阵表示有N个结点E条边的图时，深度优先遍历算法的时间复杂度是：C.O(N2)</p>
</blockquote>
<h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><blockquote>
<p> 下列关于栈的叙述中，错误的是：</p>
<ol>
<li><strong>采用非递归方式重写递归程序时必须使用栈</strong></li>
<li>函数调用时，系统要用栈保存必要的信息</li>
<li><strong>只要确定了入栈次序，即可确定出栈次序</strong></li>
<li><strong>栈是一种受限的线性表，允许在其两端进行操作</strong></li>
</ol>
</blockquote>
<blockquote>
<p> 最不适合用作栈的链表是（）。</p>
<p>A.只有表头指针没有表尾指针的循环双链表</p>
<p>B.只有表尾指针没有表头指针的循环双链表</p>
<p>C.只有表尾指针没有表头指针的循环单链表</p>
<p>D.<strong>只有表头指针没有表尾指针的循环单链表</strong></p>
</blockquote>
<blockquote>
<p> 下列关于栈的叙述中，错误的是：</p>
<ol>
<li>采用非递归方式重写递归程序时必须使用栈</li>
<li>函数调用时，系统要用栈保存必要的信息</li>
<li>只要确定了入栈次序，即可确定出栈次序</li>
<li>栈是一种受限的线性表，允许在其两端进行操作</li>
</ol>
<p> A.仅 1</p>
<p> B.仅 1、2、3</p>
<p> **C.**仅 1、3、4</p>
<p> D.仅 2、3、4</p>
<p> 循环队列的引入是为了（ ）。克服假溢出</p>
</blockquote>
<h3 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h3><blockquote>
<p>树的后序遍历与其对应的二叉树的哪种遍历相同？中序</p>
<p>森林的中序遍历与对应二叉树的什么遍历序列相同？中序</p>
</blockquote>
<h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>有组记录的排序码为{ 46，79，56，38，40，84 }，则利用堆排序的方法建立的初始堆为：</p>
<p>84，79，56，38，40，46</p>
</blockquote>
<blockquote>
<p>下面四种排序算法中，稳定的算法是：归并排序</p>
</blockquote>
<blockquote>
<p>快速排序下列排序算法中，时间复杂度不受数据初始状态影响，恒为O(NlogN)的是：</p>
<p>堆排序</p>
</blockquote>
<blockquote>
<p>对N个记录进行快速排序，在最坏的情况下，其时间复杂度是：</p>
<p>O(N2)</p>
</blockquote>
<blockquote>
<p>下列关键码序列中，属于堆的是（ 　）。</p>
<p>（15，30，22，93，52，71）</p>
</blockquote>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/11/12/Data-Structure-and-Algorithm/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure-and-Algorithm/" rel="tag">Data-Structure-and-Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/11/26/GIT-basic/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            GIT basic
          
        </div>
      </a>
    
    
      <a href="/2023/10/31/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">MySql学习笔记</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.staticfile.org/valine/1.4.16/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "lJFN2cyOh63wpxIlrVeeMDO8-gzGzoHsz",
    app_key: "d4GM27zPASnZH5cgTbXF2JJY",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> Regen
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/touxiang.png" alt="Regen"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E7%AC%94%E8%AE%B0">笔记</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E8%AF%BB%E4%B9%A6">读书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0">随笔</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/regenalipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/regenwechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=536623501&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>