<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="Regen&#39;s blogs" />
       
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Regen</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/touxiang.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/regenm/Notes"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/background_blackSandBeach.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Regen</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['Hi !', 'HOLA ！', 'bonjour ！'],
        startDelay: 10,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://regenm.gitee.io/tags/about/">
                <img src="/images/touxiang.png" width="300" alt="Bilibili">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Data-Structure-and-Algorithm"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/12/Data-Structure-and-Algorithm/"
    >Data Structure and Algorithm</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/12/Data-Structure-and-Algorithm/" class="article-date">
  <time datetime="2023-11-12T13:58:40.000Z" itemprop="datePublished">2023-11-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h3><blockquote>
<p>​		哈夫曼算法：</p>
<ol>
<li>构造 n 棵二叉树森林，每一个都是带权值的根节点。</li>
<li>选择权值最小的两棵树作为左右子树，其根节点的权值为左右子树权值之和。</li>
<li>删除这两棵树，将新的树加入森林。</li>
<li>重复操作到只剩下一棵树为止。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  基于结构体数组的哈曼树</span></span><br><span class="line"><span class="comment">*  C++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> DataType; <span class="comment">//结点权值的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HTNode</span> <span class="comment">//单个结点的信息</span></span><br><span class="line">&#123;</span><br><span class="line">  DataType weight; <span class="comment">//权值</span></span><br><span class="line">  <span class="type">int</span> parent; <span class="comment">//父节点</span></span><br><span class="line">  <span class="type">int</span> lc, rc; <span class="comment">//左右孩子</span></span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> **HuffmanCode; <span class="comment">//字符指针数组中存储的元素类型</span></span><br><span class="line">              <span class="comment">//用于存储哈夫曼编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标为1到i-1的范围找到权值最小的两个值的下标，其中s1的权值小于s2的权值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree&amp; HT, <span class="type">int</span> n, <span class="type">int</span>&amp; s1, <span class="type">int</span>&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> min;</span><br><span class="line">  <span class="comment">//找第一个最小值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; HT[i].weight &lt; HT[min].weight)</span><br><span class="line">      min = i;</span><br><span class="line">  &#125;</span><br><span class="line">  s1 = min; <span class="comment">//第一个最小值给s1</span></span><br><span class="line">  <span class="comment">//找第二个最小值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">    &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; HT[i].weight &lt; HT[min].weight&amp;&amp;i != s1)</span><br><span class="line">      min = i;</span><br><span class="line">  &#125;</span><br><span class="line">  s2 = min; <span class="comment">//第二个最小值给s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建哈夫曼树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuff</span><span class="params">(HuffmanTree&amp; HT, DataType* w, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>; <span class="comment">//哈夫曼树总结点数</span></span><br><span class="line">    </span><br><span class="line">  HT = (HuffmanTree)<span class="built_in">calloc</span>(m + <span class="number">1</span>, <span class="built_in">sizeof</span>(HTNode)); <span class="comment">//开m+1个HTNode，因为下标为0的HTNode不存储数据</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    HT[i].weight = w[i - <span class="number">1</span>]; <span class="comment">//赋权值给n个叶子结点</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) <span class="comment">//构建哈夫曼树</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//选择权值最小的s1和s2，生成它们的父结点</span></span><br><span class="line">    <span class="type">int</span> s1, s2;</span><br><span class="line">    <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2); <span class="comment">//在下标为1到i-1的范围找到权值最小的两个值的下标，其中s1的权值小于s2的权值</span></span><br><span class="line">    HT[i].weight = HT[s1].weight + HT[s2].weight; <span class="comment">//i的权重是s1和s2的权重之和</span></span><br><span class="line">    HT[s1].parent = i; <span class="comment">//s1的父亲是i</span></span><br><span class="line">    HT[s2].parent = i; <span class="comment">//s2的父亲是i</span></span><br><span class="line">    HT[i].lc = s1; <span class="comment">//左孩子是s1</span></span><br><span class="line">    HT[i].rc = s2; <span class="comment">//右孩子是s2</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//打印哈夫曼树中各结点之间的关系</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;哈夫曼树为:&gt;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;下标   权值     父结点   左孩子   右孩子\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;0                                  \n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-4d   %-6.2lf   %-6d   %-6d   %-6d\n&quot;</span>, i, HT[i].weight, HT[i].parent, HT[i].lc, HT[i].rc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成哈夫曼编码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffCoding</span><span class="params">(HuffmanTree&amp; HT, HuffmanCode&amp; HC, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HC = (HuffmanCode)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>*)*(n + <span class="number">1</span>)); <span class="comment">//开n+1个空间，因为下标为0的空间不用</span></span><br><span class="line">  <span class="type">char</span>* code = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*n); <span class="comment">//辅助空间，编码最长为n(最长时，前n-1个用于存储数据，最后1个用于存放&#x27;\0&#x27;)</span></span><br><span class="line">  code[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//辅助空间最后一个位置为&#x27;\0&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> start = n - <span class="number">1</span>; <span class="comment">//每次生成数据的哈夫曼编码之前，先将start指针指向&#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">int</span> c = i; <span class="comment">//正在进行的第i个数据的编码</span></span><br><span class="line">    <span class="type">int</span> p = HT[c].parent; <span class="comment">//找到该数据的父结点</span></span><br><span class="line">    <span class="keyword">while</span> (p) <span class="comment">//直到父结点为0，即父结点为根结点时，停止</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (HT[p].lc == c) <span class="comment">//如果该结点是其父结点的左孩子，则编码为0，否则为1</span></span><br><span class="line">        code[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        code[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">      c = p; <span class="comment">//继续往上进行编码</span></span><br><span class="line">      p = HT[c].parent; <span class="comment">//c的父结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    HC[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*(n - start)); <span class="comment">//开辟用于存储编码的内存空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(HC[i], &amp;code[start]); <span class="comment">//将编码拷贝到字符指针数组中的相应位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(code); <span class="comment">//释放辅助空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入数据个数:&gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  DataType* w = (DataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DataType)*n);</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入数据:&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  HuffmanTree HT;</span><br><span class="line">  <span class="built_in">CreateHuff</span>(HT, w, n); <span class="comment">//构建哈夫曼树</span></span><br><span class="line"></span><br><span class="line">  HuffmanCode HC;</span><br><span class="line">  <span class="built_in">HuffCoding</span>(HT, HC, n); <span class="comment">//构建哈夫曼编码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//打印哈夫曼编码</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据%.2lf的编码为:%s\n&quot;</span>, HT[i].weight, HC[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(w);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树：求树的高度"><a href="#二叉树：求树的高度" class="headerlink" title="二叉树：求树的高度"></a>二叉树：求树的高度</h3><ol>
<li>递归</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetHeight</span><span class="params">(BinTree BT)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BT) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(GetHeight(BT-&gt;Left),GetHeight(BT-&gt;Right))+<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetHeight</span><span class="params">( BinTree BT )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    BinTree arr[<span class="number">100</span>];</span><br><span class="line">    BinTree tmpFront;</span><br><span class="line">    <span class="type">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h=<span class="number">0</span>;</span><br><span class="line">    arr[rear++]=BT;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nextCount=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(front!=rear)&#123;</span><br><span class="line">        h++;</span><br><span class="line">        count=nextCount;</span><br><span class="line">        nextCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">            tmpFront=arr[front++];</span><br><span class="line">            <span class="keyword">if</span>(tmpFront-&gt;Left)&#123;</span><br><span class="line">                arr[rear++]=tmpFront-&gt;Left;</span><br><span class="line">                nextCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpFront-&gt;Right)&#123;</span><br><span class="line">                arr[rear++]=tmpFront-&gt;Right;</span><br><span class="line">                nextCount++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树：顺序存储"><a href="#二叉树：顺序存储" class="headerlink" title="二叉树：顺序存储"></a>二叉树：顺序存储</h3><p>​	存储按照完全二叉树来（遇到空节点则 赋值 isEmpty 为 true）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">   ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">   <span class="type">bool</span> isEmpty;   <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   TreeNode t[MaxSize];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">      t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入:ABC##DE#G##F###</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">(BiTree *T)</span>  <span class="comment">//创建二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">  <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)		<span class="comment">//判断该字符ch是不是为&#x27;#&#x27;,意思是该节点是不是空的</span></span><br><span class="line">    *T=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));	<span class="comment">//为结点T申请空间</span></span><br><span class="line">    (*T)-&gt;data=ch;		<span class="comment">//将ch的值赋给(*T)-&gt;data</span></span><br><span class="line">    creat(&amp;(*T)-&gt;lchild);</span><br><span class="line">    creat(&amp;(*T)-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li><strong>二叉树：先序遍历</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">       </span><br><span class="line">      PreOrder(T-&gt;lchild);      <span class="comment">//递归遍历左子树</span></span><br><span class="line">      PreOrder(T-&gt;rchild);      <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">//遍历失败，根节点空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p><strong>二叉树：中序遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ShowZhongXu</span><span class="params">(BitTree T)</span>      <span class="comment">//		先序遍历二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)						<span class="comment">//	递归中遇到NULL，返回上一层节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  ShowZhongXu(T-&gt;lchild);			<span class="comment">//	递归遍历左子树</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);</span><br><span class="line">  ShowZhongXu(T-&gt;rchild);			<span class="comment">//	递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树：后序遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ShowZhongXu</span><span class="params">(BitTree T)</span>      <span class="comment">//		先序遍历二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)						<span class="comment">//	递归中遇到NULL，返回上一层节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;					<span class="comment">// 空根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  ShowZhongXu(T-&gt;lchild);			<span class="comment">//	递归遍历左子树</span></span><br><span class="line">  ShowZhongXu(T-&gt;rchild);			<span class="comment">//	递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>二叉树：层序遍历</strong></li>
</ul>
<ul>
<li>使用队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   LinkQueue Q;</span><br><span class="line">   InitQueue (Q);          <span class="comment">//初始化辅助队列</span></span><br><span class="line">    </span><br><span class="line">   BiTree p;</span><br><span class="line">   EnQueue(Q,T);           <span class="comment">//将根节点入队</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">while</span>(!isEmpty(Q))&#123;     <span class="comment">//队列不空则循环</span></span><br><span class="line">      DeQueue(Q,p);        <span class="comment">//队头结点出队</span></span><br><span class="line">      visit(p);            <span class="comment">//访问出队结点</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;lchild);   <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;rchild);   <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树交换左右孩子"><a href="#二叉树交换左右孩子" class="headerlink" title="二叉树交换左右孩子"></a>二叉树交换左右孩子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似于先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    BiTNode *m=T-&gt;lchild;<span class="comment">/*这三行类似于&quot;打擂台法&quot;*/</span></span><br><span class="line">    T-&gt;lchild=T-&gt;rchild;</span><br><span class="line">    T-&gt;rchild=m;			</span><br><span class="line">    swap(T-&gt;lchild);</span><br><span class="line">    swap(T-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求二叉树高度-深度"><a href="#求二叉树高度-深度" class="headerlink" title="求二叉树高度(深度)"></a>求二叉树高度(深度)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">( BiTree T )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> countl =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> countr =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        countl=Depth( T-&gt;lchild );</span><br><span class="line">        countr=Depth( T-&gt;rchild );</span><br><span class="line">        max=countl&gt;countr? countl:countr;</span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><blockquote>
<p>将空的指针域用以指向前驱后继节点。</p>
<p>遵循：</p>
<ul>
<li>ltag&#x3D;&#x3D;0，指向左孩子；ltag&#x3D;&#x3D;1，指向前驱结点</li>
<li>rtag&#x3D;&#x3D;0，指向右孩子；rtag&#x3D;&#x3D;1，指向后继结点</li>
</ul>
</blockquote>
<pre><code>    1. 二叉树的线索化
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderThreadTree</span><span class="params">(Node* node)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//如果当前结点为NULL 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//先处理左子树</span></span><br><span class="line">  inOrderThreadTree(node-&gt;left_node);</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;left_node == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置前驱结点</span></span><br><span class="line">    node-&gt;left_type = <span class="number">1</span>;</span><br><span class="line">    node-&gt;left_node = pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果结点的右子节点为NULL 处理前驱的右指针</span></span><br><span class="line">  <span class="keyword">if</span> (pre !=<span class="literal">NULL</span> &amp;&amp; pre-&gt;right_node == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置后继</span></span><br><span class="line">    pre-&gt;right_node = node;</span><br><span class="line">    pre-&gt;right_type = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//每处理一个节点 当前结点是下一个节点的前驱</span></span><br><span class="line">  pre = node;</span><br><span class="line">  <span class="comment">//最后处理右子树</span></span><br><span class="line">  inOrderThreadTree(node-&gt;right_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>中序遍历线索二叉树</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraverse</span><span class="params">(Node* root)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//从根节点开始先找到最左边</span></span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node* temp = root;</span><br><span class="line">  <span class="comment">//先找到最左边结点 然后根据线索化直接向右遍历</span></span><br><span class="line">  <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;left_type == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    temp = temp-&gt;left_node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    temp = temp-&gt;right_node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><strong>线索二叉树操作集合</strong></p>
<ol>
<li>结构体</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>主函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreorderTraversal</span><span class="params">( BinTree BT )</span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InorderTraversal</span><span class="params">( BinTree BT )</span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line">BinTree <span class="title function_">Insert</span><span class="params">( BinTree BST, ElementType X )</span>;</span><br><span class="line">BinTree <span class="title function_">Delete</span><span class="params">( BinTree BST, ElementType X )</span>;</span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( BinTree BST, ElementType X )</span>;</span><br><span class="line">Position <span class="title function_">FindMin</span><span class="params">( BinTree BST )</span>;</span><br><span class="line">Position <span class="title function_">FindMax</span><span class="params">( BinTree BST )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="type">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = Insert(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Preorder:&quot;</span>); PreorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    MinP = FindMin(BST);</span><br><span class="line">    MaxP = FindMax(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        Tmp = Find(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d is not found\n&quot;</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is found\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the smallest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the largest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = Delete(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inorder:&quot;</span>); InorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>操作集合</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line">BinTree <span class="title function_">Insert</span><span class="params">( BinTree BST, ElementType X )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>) &#123;          <span class="comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span></span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTree));</span><br><span class="line">        BST -&gt;Data = X;</span><br><span class="line">        BST -&gt;Left = BST -&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;         <span class="comment">/* 开始寻找要插入元素的位置 */</span></span><br><span class="line">        <span class="keyword">if</span>(X &lt; BST -&gt;Data ) &#123;</span><br><span class="line">            BST -&gt;Left = Insert(BST -&gt;Left, X);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST -&gt;Data ) &#123;</span><br><span class="line">            BST -&gt;Right = Insert(BST -&gt;Right, X);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* X已经存在，不用操作 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">BinTree <span class="title function_">Delete</span><span class="params">( BinTree BST, ElementType X )</span>&#123;</span><br><span class="line">    BinTree Tmp;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>)    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data)  </span><br><span class="line">            BST -&gt;Left = Delete(BST-&gt;Left, X);          <span class="comment">/* 左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data ) </span><br><span class="line">            BST -&gt;Right = Delete(BST-&gt;Right , X);       <span class="comment">/* 右子树递归删除*/</span></span><br><span class="line">        <span class="keyword">else</span> &#123;                                          <span class="comment">/* 找到需要删除的结点 */</span></span><br><span class="line">            <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123;               <span class="comment">/* 被删除的结点有左右子结点 */</span></span><br><span class="line">                Tmp=FindMin(BST-&gt;Right);                <span class="comment">/* 在右子树中找到最小结点填充删除结点 */</span></span><br><span class="line">                BST-&gt;Data = Tmp -&gt;Data;</span><br><span class="line">                BST-&gt;Right=Delete(BST-&gt;Right,BST-&gt;Data);<span class="comment">/* 递归删除要删除结点的右子树中最小元素 */</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;                                     <span class="comment">/* 被删除结点有一个或没有子结点*/</span></span><br><span class="line">                Tmp = BST;</span><br><span class="line">                <span class="keyword">if</span>(!BST-&gt;Left) BST = BST-&gt;Right;        <span class="comment">/*有右孩子或者没孩子*/</span> </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)    BST = BST-&gt;Left;<span class="comment">/*有左孩子，一定要加else，不然BST可能是NULL，会段错误*/</span> </span><br><span class="line">                <span class="built_in">free</span>(Tmp);                              <span class="comment">/*如无左右孩子直接删除*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( BinTree BST, ElementType X )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(BST-&gt;Data==X)    <span class="keyword">return</span> BST; </span><br><span class="line">    <span class="keyword">if</span>(X&gt;BST-&gt;Data)     <span class="keyword">return</span> Find(BST-&gt;Right,X);      </span><br><span class="line">    <span class="keyword">if</span>(X&lt;BST-&gt;Data)     <span class="keyword">return</span> Find(BST-&gt;Left,X);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*  以下几种写法均可，推荐第上面这一种 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(!BST)    return NULL;</span></span><br><span class="line"><span class="comment">    if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">    if(X&gt;BST-&gt;Data)     Find(BST-&gt;Right,X);     </span></span><br><span class="line"><span class="comment">    if(X&lt;BST-&gt;Data)     Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(BST)&#123;</span></span><br><span class="line"><span class="comment">        if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">        if(X&gt;BST-&gt;Data)     Find(BST-&gt;Right,X);     //如果不写return，则返回过来的值并没有继续返回给最开始的函数 </span></span><br><span class="line"><span class="comment">        if(X&lt;BST-&gt;Data)     Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    else return NULL;   </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(BST)&#123;</span></span><br><span class="line"><span class="comment">        if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">        if(X&gt;BST-&gt;Data)     return  Find(BST-&gt;Right,X); </span></span><br><span class="line"><span class="comment">        if(X&lt;BST-&gt;Data)     return  Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    return NULL;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(BST)&#123;</span></span><br><span class="line"><span class="comment">        if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">        if(X&gt;BST-&gt;Data)     return Find(BST-&gt;Right,X);      </span></span><br><span class="line"><span class="comment">        if(X&lt;BST-&gt;Data)     return Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    else return NULL;</span></span><br><span class="line"><span class="comment">    */</span>                          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果return NULL前面不写else且Find前也不写else，则最后递归返回的也没return，最后只能是执行到了return NULL</span></span><br><span class="line"><span class="comment">返回了，而如果find 前加上了return则就把递归的结果利用起来了，最后加不加else也无所谓了，而如果直接最后else，</span></span><br><span class="line"><span class="comment">不加return find也是可以的，加上了else之后就不会被每一次返回时最后的return NULL给覆盖掉，所以也行。 */</span> </span><br><span class="line">Position <span class="title function_">FindMin</span><span class="params">( BinTree BST )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Left)&#123;</span><br><span class="line">            BST=BST-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> BST; </span><br><span class="line">&#125; </span><br><span class="line">Position <span class="title function_">FindMax</span><span class="params">( BinTree BST )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right)&#123;</span><br><span class="line">            BST=BST-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> BST; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>​	 	主要用于解决一些<strong>元素分组</strong>的问题。也可以用来判断图的连通性，它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p>
<ul>
<li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li>
<li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//最简单版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *当数据很多时，查找会很耗费时间</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x) father[x]=find(father[x]);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;           <span class="comment">//查找根节点的函数 </span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  升级版</span></span><br><span class="line"><span class="comment">    *  带路径压缩功能</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">  a=x;</span><br><span class="line">  <span class="keyword">while</span>(x!=father[x])x=father[x];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(a!=father[a])&#123;    <span class="comment">//路径压缩 </span></span><br><span class="line">    <span class="type">int</span> z=a;</span><br><span class="line">    a=father[a];</span><br><span class="line">    father[z]=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123; </span><br><span class="line">                <span class="comment">//合并两个集合</span></span><br><span class="line">    <span class="type">int</span> fx=find(a);</span><br><span class="line">    <span class="type">int</span> fy=find(b);</span><br><span class="line">    father[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">judgeConnect</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//判断连通性</span></span><br><span class="line">    <span class="type">int</span> i,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=vertex;i++)</span><br><span class="line">        <span class="keyword">if</span>(father[i]==i) k++;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOE图"><a href="#AOE图" class="headerlink" title="AOE图"></a>AOE图</h3><blockquote>
<p><em>concept:</em></p>
<p>1、<strong>最早发生</strong>时间：从前往后，前驱结点到当前结点所需时间，取<strong>最大值</strong>；</p>
<p>2、<strong>最迟发生</strong>时间：从后往前，后继结点的最迟时间减去边权的值，取<strong>最小值</strong>；</p>
<p><strong>结束节点的最早发生时间和最迟发生时间相同。</strong></p>
<p>3、关键路径：最早发生时间和最迟发生时间相同的结点叫做关键路径上的结点；</p>
<p>4、<strong>最早开始</strong>时间：等于当前边起始节点的最早发生时间；</p>
<p>5、<strong>最晚开始</strong>时间：等于当前便指向结点的最迟时间减去当前边的权值；</p>
<p>6、<strong>最早完工</strong>时间：等于当前边指向结点的最早发生时间；</p>
<p>7、<strong>最晚完工</strong>时间：等于当前边指向结点的最迟发生时间；</p>
</blockquote>
<h3 id="图的链式存储结构"><a href="#图的链式存储结构" class="headerlink" title="图的链式存储结构"></a>图的链式存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100                                 <span class="comment">//最大顶点数 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>                        <span class="comment">//表结点 </span></span><br><span class="line">    <span class="type">int</span> adjvex;                                    <span class="comment">//邻接点的位置 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span>      <span class="comment">//指向下一个表结点的指针 </span></span><br><span class="line">  &#125;ArcNode; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span> </span><br><span class="line">   <span class="type">char</span> data;                                    <span class="comment">//顶点信息 </span></span><br><span class="line">   ArcNode * firstarc;         <span class="comment">//指向第一个表结点的指针 </span></span><br><span class="line">&#125;VNode, AdjList[MVNum];                 <span class="comment">//AdjList表示邻接表类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    AdjList vertices;              <span class="comment">//头结点数组</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;     <span class="comment">//图的当前顶点数和边数 </span></span><br><span class="line">&#125;ALGraph; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatMGraph</span><span class="params">(ALGraph *G)</span>;<span class="comment">/* 创建图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(ALGraph G)</span>;<span class="comment">/*输出图 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    CreatMGraph(&amp;G);</span><br><span class="line">    printGraph(G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatMGraph</span><span class="params">(ALGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;G-&gt;vexnum,&amp;G-&gt;arcnum);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;G-&gt;vertices[i].data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">         G-&gt;vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;arcnum;k++) &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);    </span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;nextarc=G-&gt;vertices[i].firstarc;</span><br><span class="line"></span><br><span class="line">        G-&gt;vertices[i].firstarc=s;   </span><br><span class="line"></span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=i;</span><br><span class="line"></span><br><span class="line">        s-&gt;nextarc=G-&gt;vertices[j].firstarc;;</span><br><span class="line">        G-&gt;vertices[j].firstarc=s;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(ALGraph G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%c:&quot;</span>,G.vertices[i].data);</span><br><span class="line">       <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot; %c&quot;</span>,G.vertices[p-&gt;adjvex].data);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找（搜索）"><a href="#查找（搜索）" class="headerlink" title="查找（搜索）"></a>查找（搜索）</h2><h3 id="折半搜索"><a href="#折半搜索" class="headerlink" title="折半搜索"></a>折半搜索</h3><blockquote>
<p>因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> x, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];<span class="comment">//0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> re=BinSearch(arr,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;下标：%d\n&quot;</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//按折半查找法查找值为x的数组元素，若找到则返回x在数组中的下标位置，否则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = n<span class="number">-1</span>, mid;<span class="comment">//区间左端点low置为0，右端点high置为n-1</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)      <span class="comment">//若左端点小于等于右端点，则继续查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;<span class="comment">//取数据区间的重点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mid);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="built_in">array</span>[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>;      <span class="comment">//若x&gt;array[mid]，则修改区间的左端点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="built_in">array</span>[mid])</span><br><span class="line">            high = mid - <span class="number">1</span>;      <span class="comment">//若x&lt;array[mid]，则修改区间的右端点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;次数：%d\n&quot;</span>,num);</span><br><span class="line">            <span class="keyword">return</span> mid;        <span class="comment">//若找到，则返回下标值mid</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;            <span class="comment">//循环结束仍未找到，则返回值-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><blockquote>
<p>类似于折半搜索，只是mid的计算方法不一样</p>
<p>比较元素的下标：</p>
<p>Mid &#x3D; Begin + ( (End - Begin) &#x2F; (A[End] - A[Begin]) ) * (X - A[Begin])</p>
<blockquote>
<p>式子中，各部分的含义分别是：</p>
<p>Mid：计算得出的元素的位置；</p>
<p>End：搜索区域内最后一个元素所在的位置；</p>
<p>Begin：搜索区域内第一个元素所在的位置；</p>
<p>X：要查找的目标元素；</p>
<p>A[]：表示整个待搜索序列</p>
</blockquote>
</blockquote>
<p>C语言实现过程</p>
<p>​	<strong>递归算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//实现插值查找算法，ele 表示要查找的目标元素，[begin,end] 指定查找区域</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">interpolation_search</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> ele)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果[begin,end] 不存在，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果搜索区域内只有一个元素，判断其是否为目标元素</span></span><br><span class="line">    <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ele == arr[begin]) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该元素非目标元素，则查找失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到&quot;中间元素&quot;所在的位置</span></span><br><span class="line">    mid = begin + ((end - begin) / (arr[end] - arr[begin]) * (ele - arr[begin]));</span><br><span class="line">    <span class="comment">//递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> (ele == arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较 ele 和 arr[mid] 的值，缩小 ele 可能存在的区域</span></span><br><span class="line">    <span class="keyword">if</span> (ele &lt; arr[mid]) &#123;</span><br><span class="line">        <span class="comment">//新的搜索区域为 [begin,mid-1]</span></span><br><span class="line">        <span class="keyword">return</span> interpolation_search(arr, begin, mid - <span class="number">1</span>, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//新的搜索区域为 [mid+1,end]</span></span><br><span class="line">        <span class="keyword">return</span> interpolation_search(arr, mid + <span class="number">1</span>, end, ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="comment">//输出元素 2 所在位置的下标</span></span><br><span class="line">    <span class="type">int</span> pos = interpolation_search(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, interpolation_search(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><blockquote>
<ol>
<li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li>
<li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li>
<li>左、右子树也分别是一棵二叉排序树。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> data;	<span class="comment">//结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *Bitree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归查找二叉排序树T中是否存在key</span></span><br><span class="line"><span class="comment">指针f指向T的双亲，其初始调用值为NULL</span></span><br><span class="line"><span class="comment">若查找成功，则指针p指向该数据元素结点，并返回TRUE</span></span><br><span class="line"><span class="comment">否则指针p指向查找路径上访问的最后一个结点并返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SearchBST</span><span class="params">(BiTree T, <span class="type">int</span> key, BiTree f, BiTree *p)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">    *p = f;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">    <span class="comment">//查找成功</span></span><br><span class="line">    *p = T;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">    <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);	<span class="comment">//在左子树继续查找</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);	<span class="comment">//在右子树继续查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当二叉排序树T中不存在关键字等于key的数据元素时</span></span><br><span class="line"><span class="comment">插入key并返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">  BiTree p, s;</span><br><span class="line">  <span class="keyword">if</span>(!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p))&#123;</span><br><span class="line">    <span class="comment">//查找不成功</span></span><br><span class="line">    s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    s-&gt;data = key;</span><br><span class="line">    s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">      *T = s;	<span class="comment">//插入s为新的根节点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p-&gt;data)&#123;</span><br><span class="line">      p-&gt;lchild = s;	<span class="comment">//插入s为左孩子</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      p-&gt;rchild = s;	<span class="comment">//插入s为右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;	<span class="comment">//树种已有关键字相同的结点，不再插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************构造二叉排序树************/</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span>&#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  InsertBST(&amp;T, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点，</span></span><br><span class="line"><span class="comment">并返回TRUE;否则返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE; </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">      <span class="comment">//找到关键字等于key的数据元素</span></span><br><span class="line">      <span class="keyword">return</span> Delete(T);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T -&gt; data)&#123;</span><br><span class="line">      <span class="keyword">return</span> DeleteBST(T -&gt; lchild, key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DeleteBST(T -&gt; rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="哈希表（散列表）"><a href="#哈希表（散列表）" class="headerlink" title="哈希表（散列表）"></a>哈希表（散列表）</h3><blockquote>
<p>​	散列表是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>
<p>​	这种对应关系称为散列函数，又称为哈希(Hash) 函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。那么关键字对应的记录存储位置我们称为散列地址。</p>
</blockquote>
<h4 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h4><ol>
<li>直接定址法</li>
</ol>
<p>​				直接取关键字的某个线性函数值为散列地址，散列函数为：<br>$$<br>H(key)&#x3D;key或H(key)&#x3D;a∗key+b<br>$$</p>
<ol start="2">
<li>数字分析法</li>
</ol>
<blockquote>
<p>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址。</p>
</blockquote>
<ol start="3">
<li>平方取中法</li>
</ol>
<blockquote>
<p>平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p>
<p>字面意思：平方之后取中间的数字作为散列地址</p>
</blockquote>
<ol start="4">
<li>除留余数法</li>
</ol>
<p>​				散列函数：</p>
<blockquote>
<p>h（key） &#x3D; key % 17</p>
<blockquote>
<ul>
<li>p取素数（避免余数相关性）</li>
</ul>
</blockquote>
</blockquote>
<ol start="5">
<li>随机数法</li>
</ol>
<p>$$<br>H(key)&#x3D;random(key)<br>$$</p>
<h4 id="处理散列冲突"><a href="#处理散列冲突" class="headerlink" title="处理散列冲突"></a>处理散列冲突</h4><p>​				开放地址法（闭散列表）和链地址法（开散列表法）</p>
<ol>
<li>线性探测法</li>
</ol>
<blockquote>
<p>从冲突的的下一个位置起，依次寻找空的散列地址</p>
<blockquote>
<ul>
<li>存在堆积现象</li>
</ul>
</blockquote>
</blockquote>
<p>​	公式：<br>$$<br>H<br>i<br>​<br> (key)&#x3D;(f(key)+d<br>i<br>​<br> )%m (d<br>i<br>​<br> &#x3D;1,2,3,…,m−1)<br>$$<br>​	此时： di &#x3D; 0,1,2,3,…k</p>
<ol start="2">
<li>二次（平方）探测法</li>
</ol>
<p>​		公式<br>$$<br>H<br>i<br>​<br> (key)&#x3D;(f(key)+d<br>i<br>​<br> )%m (d<br>i<br>​<br> &#x3D;1,2,3,…,m−1)<br>$$<br>​	此时：di &#x3D; 0,1,-1,2^2,-2^2,….k^2,-k^2</p>
<ol start="3">
<li>拉链法</li>
</ol>
<blockquote>
<p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p>
</blockquote>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//记录有序序列最后一个元素的下标</span></span><br><span class="line">    <span class="type">int</span> end = i;</span><br><span class="line">    <span class="comment">//待插入的元素</span></span><br><span class="line">    <span class="type">int</span> tem = arr[end + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//单趟排</span></span><br><span class="line">    <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//比插入的数大就向后移</span></span><br><span class="line">      <span class="keyword">if</span> (tem &lt; arr[end])</span><br><span class="line">      &#123;</span><br><span class="line">        arr[end + <span class="number">1</span>] = arr[end];</span><br><span class="line">        end--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//比插入的数小，跳出循环</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//tem放到比插入的数小的数的后面</span></span><br><span class="line">    arr[end  + <span class="number">1</span>] = tem;</span><br><span class="line">    <span class="comment">//代码执行到此位置有两种情况:</span></span><br><span class="line">    <span class="comment">//1.待插入元素找到应插入位置（break跳出循环到此）</span></span><br><span class="line">    <span class="comment">//2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：	</p>
<ul>
<li>最坏（逆序）：O(n^2)</li>
<li>最好（升序）：O(n)</li>
</ul>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> gap = n;</span><br><span class="line">  <span class="keyword">while</span> (gap&gt;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//每次对gap折半操作</span></span><br><span class="line">    gap = gap / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//单趟排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> end = i;</span><br><span class="line">      <span class="type">int</span> tem = arr[end + gap];</span><br><span class="line">      <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (tem &lt; arr[end])</span><br><span class="line">        &#123;</span><br><span class="line">          arr[end + gap] = arr[end];</span><br><span class="line">          end -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[end + gap] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度(平均)：O(N^1.3)<br>空间复杂度：O(1)</p>
</blockquote>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tem = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//保存参与单趟排序的第一个数和最后一个数的下标</span></span><br><span class="line">  <span class="type">int</span> begin = <span class="number">0</span>, end = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//保存最大值的下标</span></span><br><span class="line">    <span class="type">int</span> maxi = begin;</span><br><span class="line">    <span class="comment">//保存最小值的下标</span></span><br><span class="line">    <span class="type">int</span> mini = begin;</span><br><span class="line">    <span class="comment">//找出最大值和最小值的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[mini])</span><br><span class="line">      &#123;</span><br><span class="line">        mini = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[maxi])</span><br><span class="line">      &#123;</span><br><span class="line">        maxi = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小值放在序列开头</span></span><br><span class="line">    swap(&amp;arr[mini], &amp;arr[begin]);</span><br><span class="line">    <span class="comment">//防止最大的数在begin位置被换走</span></span><br><span class="line">    <span class="keyword">if</span> (begin == maxi)</span><br><span class="line">    &#123;</span><br><span class="line">      maxi = mini;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大值放在序列结尾</span></span><br><span class="line">    swap(&amp;arr[maxi], &amp;arr[end]);</span><br><span class="line">    ++begin;</span><br><span class="line">    --end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最坏情况：O(N^2)</li>
<li>最好情况：O(N^2)</li>
</ul>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> end = n;</span><br><span class="line">  <span class="keyword">while</span> (end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> tem = arr[i];</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">        arr[i - <span class="number">1</span>] = tem;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最坏情况：O(N^2)</li>
<li>最好情况：O(N)</li>
</ul>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>堆的分类：</p>
<ul>
<li>大根堆：每个节点的值大于或等于左右孩子节点的值</li>
<li>小根堆：每个节点的值小于或等于左右孩子节点的值</li>
</ul>
</blockquote>
<p>步骤：</p>
<ol>
<li>构造大根堆</li>
<li>顶端与末尾值交换</li>
<li>将剩下的n-1个数造次构造为大根堆，重复上述操作。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标为升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapAdjust</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tmp = arr[start];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * start + <span class="number">1</span>; i &lt;= end; i = i * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; end&amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>])<span class="comment">//有右孩子并且左孩子小于右孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;<span class="comment">//i一定是左右孩子的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; tmp)</span><br><span class="line">    &#123;</span><br><span class="line">      arr[start] = arr[i];</span><br><span class="line">      start = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[start] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//第一次建立大根堆，从后往前依次调整</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=(len<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">    HeapAdjust(arr, i, len - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//每次将根和待排序的最后一次交换，然后在调整</span></span><br><span class="line">  <span class="type">int</span> tmp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    tmp = arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = arr[len - <span class="number">1</span>-i];</span><br><span class="line">    arr[len - <span class="number">1</span> - i] = tmp;</span><br><span class="line">    HeapAdjust(arr, <span class="number">0</span>, len - <span class="number">1</span>-i- <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">96</span>,<span class="number">66</span> &#125;;</span><br><span class="line">  HeapSort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;排序后为:&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>时间复杂度：时间复杂度为O(nlogn)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="快速排序（挖坑法）"><a href="#快速排序（挖坑法）" class="headerlink" title="快速排序（挖坑法）"></a>快速排序（挖坑法）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PartSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key = arr[left];</span><br><span class="line">    <span class="type">int</span> hole = left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[hole] = arr[right];</span><br><span class="line">        hole = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[hole] = arr[left];</span><br><span class="line">        hole = left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    arr[hole] = key;</span><br><span class="line">    <span class="keyword">return</span> hole;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="快速排序（库函数直接调用法）"><a href="#快速排序（库函数直接调用法）" class="headerlink" title="快速排序（库函数直接调用法）"></a>快速排序（库函数直接调用法）</h3><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span>* base<span class="comment">/*数组名字*/</span>,<span class="type">size_t</span> num<span class="comment">/*元素个数*/</span>,<span class="type">size_t</span> width<span class="comment">/*单个元素所占字节*/</span>,<span class="type">int</span>(__cdecl*compare)(<span class="type">const</span> <span class="type">void</span>*,<span class="type">const</span> <span class="type">void</span>*)<span class="comment">/*比较函数*/</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">int</span>*)a-*(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> n,i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="type">int</span> time[n];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;time[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  qsort(time,n,<span class="keyword">sizeof</span>(<span class="type">int</span>),cmp);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,time[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> sourceArr[],<span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> midIndex, <span class="type">int</span> endIndex)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = startIndex, j=midIndex+<span class="number">1</span>, k = startIndex;</span><br><span class="line">    <span class="keyword">while</span>(i!=midIndex+<span class="number">1</span> &amp;&amp; j!=endIndex+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i != midIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j != endIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部使用递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> sourceArr[], <span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex) &#123;</span><br><span class="line">        midIndex = startIndex + (endIndex-startIndex) / <span class="number">2</span>;<span class="comment">//避免溢出int</span></span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, b[<span class="number">8</span>];</span><br><span class="line">    MergeSort(a, b, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<blockquote>
<p> 时间复杂度：O(nlogn)。</p>
<p> 空间复杂度：O(N)，归并排序需要一个与原数组相同长度的数组做辅助来排序。</p>
</blockquote>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testBS</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    inta[] = &#123;<span class="number">2</span>, <span class="number">343</span>, <span class="number">342</span>, <span class="number">1</span>, <span class="number">123</span>, <span class="number">43</span>, <span class="number">4343</span>, <span class="number">433</span>, <span class="number">687</span>, <span class="number">654</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *a_p = a;</span><br><span class="line">    <span class="comment">//计算数组长度</span></span><br><span class="line">    intsize = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    bucketSort3(a_p, size);</span><br><span class="line">    <span class="comment">//打印排序后结果</span></span><br><span class="line">    inti;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    intt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucketSort3</span><span class="params">(<span class="type">int</span> *p, intn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取数组中的最大数</span></span><br><span class="line">    intmaxNum = findMaxNum(p, n);</span><br><span class="line">    <span class="comment">//获取最大数的位数，次数也是再分配的次数。</span></span><br><span class="line">    intloopTimes = getLoopTimes(maxNum);</span><br><span class="line">    inti;</span><br><span class="line">    <span class="comment">//对每一位进行桶分配</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= loopTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort2(p, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数字的位数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLoopTimes</span><span class="params">(intnum)</span></span><br><span class="line">&#123;</span><br><span class="line">    intcount = <span class="number">1</span>;</span><br><span class="line">    inttemp = num / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        temp = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returncount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询数组中的最大数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxNum</span><span class="params">(<span class="type">int</span> *p, intn)</span></span><br><span class="line">&#123;</span><br><span class="line">    inti;</span><br><span class="line">    intmax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*(p + i) &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = *(p + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将数字分配到各自的桶中，然后按照桶的顺序输出排序结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort2</span><span class="params">(<span class="type">int</span> *p, intn, intloop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建立一组桶此处的20是预设的根据实际数情况修改</span></span><br><span class="line">    intbuckets[<span class="number">10</span>][<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//求桶的index的除数</span></span><br><span class="line">    <span class="comment">//如798个位桶index=(798/1)%10=8</span></span><br><span class="line">    <span class="comment">//十位桶index=(798/10)%10=9</span></span><br><span class="line">    <span class="comment">//百位桶index=(798/100)%10=7</span></span><br><span class="line">    <span class="comment">//tempNum为上式中的1、10、100</span></span><br><span class="line">    inttempNum = (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, loop - <span class="number">1</span>);</span><br><span class="line">    inti, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        introw_index = (*(p + i) / tempNum) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[row_index][j] == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buckets[row_index][j] = *(p + i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将桶中的数，倒回到原有数组中</span></span><br><span class="line">    intk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i][j] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *(p + k) = buckets[i][j];</span><br><span class="line">                buckets[i][j] = <span class="literal">NULL</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/dataStructureSort.webp" alt=" comparison "></p>
<h2 id="应试"><a href="#应试" class="headerlink" title="应试"></a>应试</h2><h3 id="概述作业"><a href="#概述作业" class="headerlink" title="概述作业"></a>概述作业</h3><blockquote>
<p>数据在计算机内存中的表示是指（） 。数据的存储结构</p>
<p>数据结构形式地定义为（K，R），其中K是（）的有限集合，R是K上的关系上的有限集合。数据元素</p>
<p>数据结构形式地定义为（D,S），其中D是数据元素的有限集合，S是D上的（）的有限集合。关系</p>
<p>一个广义表的表尾总是一个（ ）。广义表</p>
</blockquote>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><blockquote>
<p>对于线性表的各种操作，考虑：</p>
<ol>
<li>length与MaxSize的关系</li>
<li>length是否为零</li>
<li>输入的参数是否符合规则（大于或小于零，是否为空）</li>
</ol>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote>
<p>对于栈的各种操作，考虑：</p>
<ol>
<li>栈空或栈满的情况</li>
<li>输入的参数是否符合规则（大于或小于零，是否为空）</li>
</ol>
</blockquote>
<ul>
<li>后缀表达式</li>
</ul>
<blockquote>
<p>从左往右开始扫描中缀表达式。<br>        遇到数字直接加入后缀表达式<br>        遇到运算符时：<br>            a.若为’(‘则入栈<br>            b.若为’)’，则依次把栈中的运算符加入后缀表达式，直到出现’(’，从栈中删除’)’。<br>            c.若为除括号外的其他运算符，当其他优先级高于除’)’外的栈顶运算符时，直接入栈。<br>        否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，<br>        直到一个比它优先级低的或遇到了一个左括号为止。</p>
</blockquote>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><blockquote>
<p>对于队列的各种操作，考虑：</p>
<ol>
<li>队列空和满的情况</li>
<li>输入的参数是否符合规则（大于或小于零，是否为空）</li>
</ol>
</blockquote>
<h3 id="图-1"><a href="#图-1" class="headerlink" title="图"></a>图</h3><blockquote>
<p>用邻接矩阵表示有N个结点E条边的图时，深度优先遍历算法的时间复杂度是：C.O(N2)</p>
</blockquote>
<h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><blockquote>
<p> 下列关于栈的叙述中，错误的是：</p>
<ol>
<li><strong>采用非递归方式重写递归程序时必须使用栈</strong></li>
<li>函数调用时，系统要用栈保存必要的信息</li>
<li><strong>只要确定了入栈次序，即可确定出栈次序</strong></li>
<li><strong>栈是一种受限的线性表，允许在其两端进行操作</strong></li>
</ol>
</blockquote>
<blockquote>
<p> 最不适合用作栈的链表是（）。</p>
<p>A.只有表头指针没有表尾指针的循环双链表</p>
<p>B.只有表尾指针没有表头指针的循环双链表</p>
<p>C.只有表尾指针没有表头指针的循环单链表</p>
<p>D.<strong>只有表头指针没有表尾指针的循环单链表</strong></p>
</blockquote>
<blockquote>
<p> 下列关于栈的叙述中，错误的是：</p>
<ol>
<li>采用非递归方式重写递归程序时必须使用栈</li>
<li>函数调用时，系统要用栈保存必要的信息</li>
<li>只要确定了入栈次序，即可确定出栈次序</li>
<li>栈是一种受限的线性表，允许在其两端进行操作</li>
</ol>
<p> A.仅 1</p>
<p> B.仅 1、2、3</p>
<p> **C.**仅 1、3、4</p>
<p> D.仅 2、3、4</p>
<p> 循环队列的引入是为了（ ）。克服假溢出</p>
</blockquote>
<h3 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h3><blockquote>
<p>树的后序遍历与其对应的二叉树的哪种遍历相同？中序</p>
<p>森林的中序遍历与对应二叉树的什么遍历序列相同？中序</p>
</blockquote>
<h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>有组记录的排序码为{ 46，79，56，38，40，84 }，则利用堆排序的方法建立的初始堆为：</p>
<p>84，79，56，38，40，46</p>
</blockquote>
<blockquote>
<p>下面四种排序算法中，稳定的算法是：归并排序</p>
</blockquote>
<blockquote>
<p>快速排序下列排序算法中，时间复杂度不受数据初始状态影响，恒为O(NlogN)的是：</p>
<p>堆排序</p>
</blockquote>
<blockquote>
<p>对N个记录进行快速排序，在最坏的情况下，其时间复杂度是：</p>
<p>O(N2)</p>
</blockquote>
<blockquote>
<p>下列关键码序列中，属于堆的是（ 　）。</p>
<p>（15，30，22，93，52，71）</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure-and-Algorithm/" rel="tag">Data-Structure-and-Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-MySql学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/31/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >MySql学习笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/31/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-10-31T04:27:48.000Z" itemprop="datePublished">2023-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="MySQL学习笔记（8-0）"><a href="#MySQL学习笔记（8-0）" class="headerlink" title="MySQL学习笔记（8.0）"></a>MySQL学习笔记（8.0）</h1><p>​		一切只因花几十块买了一年的云服务器。刚好目前需要用 用 JDBC ，于是就把数据库部署到了服务器上面。然而这其中却遇到了难以想象的困难（后来才发现没有必要这么弄，且一般也不这么弄，安全性大打折扣）。</p>
<h2 id="1-部署环境以及初始化配置"><a href="#1-部署环境以及初始化配置" class="headerlink" title="1.部署环境以及初始化配置"></a>1.部署环境以及初始化配置</h2><ul>
<li>Ubuntu</li>
</ul>
<h3 id="1-下载安装，配置密码"><a href="#1-下载安装，配置密码" class="headerlink" title="1.下载安装，配置密码"></a>1.下载安装，配置密码</h3><p>以root用户登录之后：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade  #不解释</span><br><span class="line">apt install mysql-server -y  #下载</span><br></pre></td></tr></table></figure>

<p><strong>此时你可以直接进入mysql</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span> apt install mysql<span class="operator">-</span>server <span class="operator">-</span>y #（将密码置为空）</span><br><span class="line">mysql<span class="operator">&gt;</span> quit;</span><br><span class="line">#  然后重启mysql，再次进入</span><br><span class="line">systemstl restart mysql</span><br><span class="line">mysql</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> (如果不用远程链接则为<span class="string">&#x27;localhost&#x27;</span>)IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> quit #修改完成</span><br></pre></td></tr></table></figure>

<ul>
<li>开启远程链接功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; apt install mysql-server -y #修改访问权限，默认只能本地访问。</span><br></pre></td></tr></table></figure>

<ul>
<li>修改MySQL配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">将[mysqld]下面的 bind-address ***以及mysqlx-bind-address ****注释</span><br><span class="line">同时取消注释</span><br><span class="line">port</span><br><span class="line">user</span><br><span class="line">socket</span><br><span class="line">server-id</span><br><span class="line">重启测试即可</span><br></pre></td></tr></table></figure>

<h2 id="2-开始正式学习mysql"><a href="#2-开始正式学习mysql" class="headerlink" title="2. 开始正式学习mysql"></a>2. 开始正式学习mysql</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-51单片机笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/26/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%94%E8%AE%B0/"
    >51单片机笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/26/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-10-26T03:43:20.000Z" itemprop="datePublished">2023-10-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>git test message</p>
<ul>
<li><h1 id="Information-Data-sheet"><a href="#Information-Data-sheet" class="headerlink" title="Information	&amp;  	Data sheet"></a>Information	&amp;  	Data sheet</h1></li>
</ul>
<p>Based on –AT89C51.</p>
<blockquote>
<p>The <strong>Atmel AT89 series</strong> is an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intel_8051">Intel 8051</a>-compatible family of 8 bit <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microcontroller">microcontrollers</a> (μCs) manufactured by the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Atmel">Atmel Corporation</a>.</p>
<p>Based on the Intel 8051 core, the AT89 series remains very popular as general purpose microcontrollers, due to their industry standard instruction set, their low unit cost, and the availability of these chips in DIL (DIP) packages. This allows a great amount of legacy code to be reused without modification in new applications. While less powerful than the newer AT90 series of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Atmel_AVR">AVR</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RISC">RISC</a> microcontrollers, new product development has continued with the AT89 series for the aforementioned advantages.</p>
<p>More recently, the AT89 series has been augmented with 8051-cored special function microcontrollers, specifically in the areas of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universal_Serial_Bus">USB</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/I%C2%B2C">I²C</a> (two wire interface), <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Controller_Area_Network">CAN</a> bus controllers, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MP3">MP3</a> decoders and hardware <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pulse-width_modulation">PWM</a>.</p>
</blockquote>
<p>Data sheet url links : <a target="_blank" rel="noopener" href="https://rocelec.widen.net/view/pdf/gywrtkuql9/ATMLS01727-1.pdf?t.download=true&u=5oefqw">Data Sheet PDF Downloads</a> </p>
<blockquote>
<p><img src="/images/featuresofat89c51.png" alt="features of AT89C51"></p>
</blockquote>
<p>​						<strong>The following I would not like to just write down the points. The post will be focused on application layer</strong></p>
<h1 id="Project-1-1：TIME-BOMB"><a href="#Project-1-1：TIME-BOMB" class="headerlink" title="Project_1_1：TIME BOMB"></a>Project_1_1：<strong>TIME BOMB</strong></h1><p>​	It’s actually very easy to make a TIME BOMB than you can imagine.You will just need some TNT and an at89c51 chip(&lt;3).</p>
<p>Now that we fixed the Bomb (got some TNT). What about the  timer ? Yep, we can use the <strong>AT89C51</strong> chip.</p>
<p><strong>Timer</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delayN10ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> N)</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(N;N&gt;<span class="number">0</span>;N--)</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);         <span class="comment">//different types of chips have different delay functions</span></span><br><span class="line">                   <span class="comment">//and it&#x27;s also related to the crystal oscillator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>what about the next to do after the timer is set? yep , light it.</p>
<p>We can use a switch or a relay to light it . When the switch (connected between vcc and gnd) is on , the heat will light the TNT. EZ game.</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delayN10ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> N)</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(N;N&gt;<span class="number">0</span>;N--)</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);         <span class="comment">//different types of chips have different delay functions</span></span><br><span class="line">                   <span class="comment">//and it&#x27;s also related to the crystal oscillator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    delayN10ms(<span class="number">10000</span>);<span class="comment">//10s</span></span><br><span class="line">    P1=<span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/timeBomb.png" alt=" schematic "></p>
<h1 id="project-1-2-CANCEL-the-TIME-BOMB"><a href="#project-1-2-CANCEL-the-TIME-BOMB" class="headerlink" title="project_1_2 : CANCEL the TIME BOMB"></a>project_1_2 : CANCEL the TIME BOMB</h1><p>​	Now that we create a time bomb , we are going to  use it to rob a bank . However your </p>
<p>incompetent teammates set the bomb  early! You guys are to be exposed to TNT in just 10s . What are you going to do ? </p>
<ul>
<li>Yes ,for sure you can reset the chip. </li>
<li>Also we can use a technique called <strong>INTERRUPTION</strong></li>
</ul>
<blockquote>
<p>Now we are  going to talk about <strong>INTERRUPTION</strong></p>
<p>The chip AT89C51 has six interrupt sources .</p>
<p><strong>What is an interrupt ?</strong></p>
<blockquote>
<p>An interrupt is an external or internal event to get the CPU’s attention. Once the controller detects the interrupt, it suspends the current job and executes a special service routine know as Interrupt Service Routine(ISR).</p>
<p>Upon activation of an interrupt, the microcontroller goes through the following steps</p>
<ol>
<li><p>First it finishes the instruction it is executing and saves the address of the next instruction (PC) on the stack.</p>
</li>
<li><p>It also saves the current status of all the interrupts internally.</p>
</li>
<li><p>It jumps to a fixed location in memory, called the interrupt vector table, that holds the address of the ISR. The microcontroller gets the address of the ISR from the interrupt vector table and jumps to it It starts to execute the interrupt service subroutine until it reaches the last instruction of the subroutine which is RETI (return from interrupt)</p>
</li>
<li><p>Upon executing the RETI instruction, the microcontroller returns to the place where it was interrupted.</p>
</li>
<li><p>First, it gets the program counter (PC) address from the stack by popping the top two bytes of the stack into the PC.</p>
</li>
<li><p>Then it starts to execute from that address.</p>
<p><a target="_blank" rel="noopener" href="http://exploreembedded.com/wiki/6.8051_Interrupts">information from here</a></p>
</li>
</ol>
</blockquote>
<p><strong>8051 interrupt Structure</strong></p>
<blockquote>
<p>8051 Microcontroller has six interrupt sources as shown in the table below:</p>
<table>
<thead>
<tr>
<th>Interrupt</th>
<th>ROM Location(Hex)</th>
<th>Pin</th>
<th>Flag Clearing</th>
<th>Interrupt no. in C</th>
</tr>
</thead>
<tbody><tr>
<td>Reset</td>
<td>0000</td>
<td>9</td>
<td>Auto</td>
<td>–</td>
</tr>
<tr>
<td>External HW Interrupt 0 (INT0)</td>
<td>0003</td>
<td>P3.2(12)</td>
<td>Auto</td>
<td>0</td>
</tr>
<tr>
<td>Timer 0 Interrupt(TF0)</td>
<td>000B</td>
<td>-</td>
<td>Auto</td>
<td>1</td>
</tr>
<tr>
<td>External HW Interrupt 1 (INT1)</td>
<td>0013</td>
<td>P3.3(13)</td>
<td>Auto</td>
<td>2</td>
</tr>
<tr>
<td>Timer 1 Interrupt(TF1)</td>
<td>001B</td>
<td>-</td>
<td>Auto</td>
<td>3</td>
</tr>
<tr>
<td>Serial Com Interrupt(RI and TI)</td>
<td>0023</td>
<td>-</td>
<td>Program SW</td>
<td>4</td>
</tr>
</tbody></table>
<ul>
<li>the reset vector has just 3 bytes allocated to it, meaning it can hold a jump instruction to the location where the main program is stored.</li>
<li>The other interrupts have 8 bytes allocated to each of them, hence a small Interrupt service routine(ISR) can be placed here. However, if the ISR needs to larger in length, it has to placed else where and the allocated 8 bytes need to have the code that simple redirects the control to the ISR.</li>
<li><em>INT0</em> and <em>INT1</em> are external interrupts on P3.2 and P3.3 respectively. These can be configured to be low level triggered or edge triggered interrupt sources.</li>
<li><em>TF0</em> and <em>TF1</em> are timer overflow interrupts for timer 0 and 1 respectively</li>
<li>The <em>Serial COM Interrupt</em> can be configured to trigger upon transmit or receipt of a byte during serial communication.</li>
</ul>
</blockquote>
<p><strong>enable interruption</strong></p>
<blockquote>
<p><img src="/images/structureof51interruption.jpg" alt="structure of 51 interrupt "></p>
</blockquote>
</blockquote>
<p>**example code using external interrupt **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    IP = <span class="number">0x04</span>; </span><br><span class="line">   EA=<span class="number">1</span>;</span><br><span class="line">   EX0=<span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">   IT0 = <span class="number">1</span>; <span class="comment">// set edge triggerin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  setUp();</span><br><span class="line">   delayNms(<span class="number">10000</span>);<span class="comment">//10s</span></span><br><span class="line">    P1=<span class="number">0x00</span>;        <span class="comment">//start BOMB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123;</span><br><span class="line"></span><br><span class="line">     P1=<span class="number">0xff</span>;			<span class="comment">//cancel the timer</span></span><br><span class="line">    P2=<span class="number">0x00</span>;       <span class="comment">//to display</span></span><br><span class="line">    delayN10ms(<span class="number">1000</span>);   <span class="comment">// pause 10s for your survive</span></span><br><span class="line">    P2=<span class="number">0xff</span>;       <span class="comment">//to display</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/images/gif.gif" alt="simple example"></p>
</blockquote>
<p>Now you can run away safely ;D.</p>
<p>**The above codes are just some rough examples . **</p>
<h1 id="Project-1-3-the-final-version-of-the-time-bomb"><a href="#Project-1-3-the-final-version-of-the-time-bomb" class="headerlink" title="Project_1_3 : the final version of the time bomb"></a>Project_1_3 : the final version of the time bomb</h1><h2 id="First-we-are-going-to-design-the-schematic-seriously"><a href="#First-we-are-going-to-design-the-schematic-seriously" class="headerlink" title="First , we are going to design the schematic seriously."></a>First , we are going to design the schematic seriously.</h2><p><img src="/images/finalbomb.png" alt="the final schematic"></p>
<h3 id="codes"><a href="#codes" class="headerlink" title="codes:"></a><strong>codes:</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg51.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit button_1=P2^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delayNms</span><span class="params">(<span class="type">int</span> N)</span>    <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);</span><br><span class="line">  N--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bombStart</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//setup</span></span><br><span class="line">   IP = <span class="number">0x04</span>; </span><br><span class="line">    EA=<span class="number">1</span>;</span><br><span class="line">    EX0=<span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">    IT0 = <span class="number">1</span>; <span class="comment">// set edge triggering</span></span><br><span class="line">    P2 =<span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(button_1==<span class="number">0</span>)&#123;</span><br><span class="line">        bombStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bombStart</span><span class="params">()</span>&#123;</span><br><span class="line">  delayNms(<span class="number">10000</span>);</span><br><span class="line">  P1=<span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123; </span><br><span class="line"></span><br><span class="line">   P1=<span class="number">0xff</span>;<span class="comment">//cancel the timer</span></span><br><span class="line">  delayNms(<span class="number">10000</span>); <span class="comment">// increase 10s for your survive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>explanations:</strong></p>
<ol>
<li>Once the bomb is set up , you need to press the start button to start the bomb.</li>
<li>Once you start the bomb , you have 10 s to run away .</li>
<li>If you want to delay the bomb , press the button “PAUSE” .<ul>
<li><strong>ps</strong>: there is no way you can cancel the bomb unless you reset or cut off the power .</li>
</ul>
</li>
</ol>
<p><strong>other information</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IT1 = <span class="number">1</span>; <span class="comment">// Enable external interrupt 1 to trigger by a falling edge signal. </span></span><br><span class="line"></span><br><span class="line">IT1 = <span class="number">0</span>; <span class="comment">// Enable a low level signal on external interrupt 1 to generate an interrupt.</span></span><br><span class="line"></span><br><span class="line">IT0 = <span class="number">1</span>; <span class="comment">// Enable external interrupt 0 to trigger by a falling edge signal.</span></span><br><span class="line"></span><br><span class="line">IT0 = <span class="number">0</span>; <span class="comment">// Enable a low level signal on external interrupt 1 to generate an interrupt.</span></span><br></pre></td></tr></table></figure>

<h1 id="Project-1-4-Use-a-TIMER-interrupt-to-set-the-bomb"><a href="#Project-1-4-Use-a-TIMER-interrupt-to-set-the-bomb" class="headerlink" title="Project_1_4: Use a TIMER interrupt to  set the bomb"></a>Project_1_4: Use a TIMER interrupt to  set the bomb</h1><p>​	To control the timer and specify our needs&#x2F;logic we have to configure the timers first. For configuring and controlling the 89c51 microcontroller timers we have four registers. These registers are associated with timers of 89c51 micro controller. Each register plays an important role in controlling and configuring the timer. </p>
<blockquote>
<p>**Registers that are associated with timers.  **</p>
<p>- </p>
<ul>
<li>(Timer Control register)</li>
<li>TMOD   (Timer Mode register)</li>
<li>TH0&#x2F;TL0 (Timer 0, 16-bit register, High bits goes to TH0, Low bits goes to TL0)</li>
<li>TH1&#x2F;TL1 (Timer 1, 16-bit register, High bits goes to TH1, Low bits goes to TL1)</li>
</ul>
</blockquote>
<p><strong>Formula if TIMER INTERRUPT</strong></p>
<p>TH0&#x2F;TL0(Timer-0) &#x3D; TH1&#x2F;TL1(Timer-1)</p>
<p>These two registers TH and TL are timer high byte and timer low byte registers. 0 and 1 are the timers numbers. These are 16-bit registers. we Load our time delays&#x2F;counter value in these registers. Recall 8051 timer counter can count up to 65535 and 16 bits cover 65535 in binary. Since 8051(89c51,89c52) is an 8-bit microcontroller, so to load 65535 we need two registers one representing the high byte and other the low byte. we access these register in two bytes one byte for TH(timer high byte) and TL(timer low byte). TH and TL together makes 16-bits(TH 8-bit, TL8-bit).  TH0 and TL0 are byte addressable only.</p>
<ul>
<li>how to set them then ? There is an  example .</li>
</ul>
<blockquote>
<p><img src="https://b2600043.smushcdn.com/2600043/wp-content/uploads/2/2/1/5/22159166/1434719730.png?lossy=0&strip=1&webp=1" alt="Calculating Delay for 8051(89c51,89c52) microcontroller"></p>
</blockquote>
<h3 id="TCON-Timer-control-Register-of-8051-Microcontroller"><a href="#TCON-Timer-control-Register-of-8051-Microcontroller" class="headerlink" title="TCON(Timer control) Register of 8051 Microcontroller"></a>TCON(Timer control) Register of 8051 Microcontroller</h3><p>TCON(Timer Control) is an 8-bit register. It’s bits are used for generating interrupts on gpio pins internal or external. The most important bits of the timers TRx and TFx are also in it. TRx(timer run) and TFx(timer overflow) bits which we use in almost all our timer applications are in it. When we initialize TRx with 1, TRx&#x3D;1 it means start the timer, When the specified time is over the timer it self make TFx&#x3D;1 which means that the delay value is reached. Once TFx&#x3D;1 stop the timer by initializing TRx with 0 TRx&#x3D;0(Stop Timer). Now if we again want to run the timer make TRx&#x3D;1. In the diagram you can see the SFR for TCON register, the bit’s used for interrupt handling and the timer run and timer over flow bits. If you want to access the individual bits of the registers, you can access them by their names. You can also access whole register it self by its name. At the bottom of the page their is a small example explaining it. </p>
<h2 id="Now-we-are-going-to-upgrade-our-Bomb"><a href="#Now-we-are-going-to-upgrade-our-Bomb" class="headerlink" title="Now we are going to upgrade our Bomb!"></a>Now we are going to upgrade our Bomb!</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"> </span><br><span class="line">sbit led=P2^<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//配置定时器0工作模式16位计时</span></span><br><span class="line">    <span class="comment">//set T0 working mode with 16 bits</span></span><br><span class="line">  TMOD&amp;=<span class="number">0xF0</span>;</span><br><span class="line">    TMOD|=<span class="number">0x01</span>;</span><br><span class="line">  <span class="comment">//给初值，定制10ms</span></span><br><span class="line">    <span class="comment">//set initial value , create 10 ms delay</span></span><br><span class="line">  TL0=<span class="number">0x00</span>;</span><br><span class="line">  TH0=<span class="number">0xDC</span>;</span><br><span class="line">  </span><br><span class="line">  TR0=<span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">        <span class="comment">// turn on T0</span></span><br><span class="line">  TF0=<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//打开定时器0中断</span></span><br><span class="line">    <span class="comment">//turn on T0 interrupt</span></span><br><span class="line">  ET0=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//打开总中断</span></span><br><span class="line">    <span class="comment">// turn on general interrupt</span></span><br><span class="line">  EA=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  led=<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  Time0Init();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ;<span class="comment">//do noting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0Rountime</span><span class="params">()</span>  interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">      cnt++;						<span class="comment">//cnt++用来记录第一次爆表，cnt是1次</span></span><br><span class="line">            						<span class="comment">// record the interrupt times</span></span><br><span class="line">                    <span class="comment">//重新给初值</span></span><br><span class="line">                        <span class="comment">//reset the initial value</span></span><br><span class="line">      TL0=<span class="number">0x00</span>;</span><br><span class="line">      TH0=<span class="number">0xDC</span>;</span><br><span class="line">      <span class="keyword">if</span>(cnt==<span class="number">1000</span>)				<span class="comment">//爆表100次，经过10s，led就亮</span></span><br><span class="line">                              <span class="comment">// after 100 times which the time passes 1s</span></span><br><span class="line">      &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;					<span class="comment">//当1s时，让count从0开始，计算下一次的1s</span></span><br><span class="line">                            <span class="comment">// set the cnt again</span></span><br><span class="line">        P1=<span class="number">0x00</span>;				<span class="comment">//BOMb!!!</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-What-if-we-get-many-BOMBs-which-they-are-set-at-different-palces"><a href="#1-What-if-we-get-many-BOMBs-which-they-are-set-at-different-palces" class="headerlink" title="1. What if we get many BOMBs which they are set at different palces ?"></a>1. What if we get many BOMBs which they are set at different palces ?</h2><ul>
<li><strong>Explode with a delay ( such as 1 s )</strong></li>
</ul>
<blockquote>
<p>Solution KEY : </p>
<p>​				Once the first BOMB is about to explode , it sends a signal to another BOMB.</p>
<p><strong>the signal :</strong></p>
<ol>
<li>Voltage （like 0 v  —&gt; 1 v  or reverse it ）</li>
<li>Waves of Voltage ( PULSE )</li>
<li>Serial text</li>
</ol>
</blockquote>
<h2 id="1-Voltage"><a href="#1-Voltage" class="headerlink" title="1. Voltage"></a>1. Voltage</h2><p>​	Once the first bomb is about to explode, it sends a Voltage signal to the second and so on.</p>
<p>​	We can use one of a pin to do this work .</p>
<ul>
<li>The first BOMB</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    delayN10ms(<span class="number">10000</span>);   <span class="comment">//10s</span></span><br><span class="line">    P2<span class="number">.1</span>=<span class="number">0</span>;       <span class="comment">// send a signal ( 5v ) </span></span><br><span class="line">    P1=<span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>The second BOMB</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;   </span><br><span class="line">      <span class="keyword">if</span>(P2<span class="number">.1</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            delayN10ms(<span class="number">10000</span>);   <span class="comment">//10s</span></span><br><span class="line">            P2<span class="number">.2</span>=<span class="number">0</span>;       <span class="comment">// send a signal to the third BOMB (send to P2.1) ( 5v ) </span></span><br><span class="line">            P1=<span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Through-Plain-Text（by-serial-）"><a href="#2-Through-Plain-Text（by-serial-）" class="headerlink" title="2. Through Plain Text（by serial ）"></a>2. Through Plain Text（by serial ）</h2><blockquote>
<p>The procedure :</p>
<ol>
<li>Set the first bomb</li>
<li>Connect to the the second Bomb and the third one so on</li>
<li>Start the first Bomb</li>
<li>the second before the first Bomb is about to explode ,it send a message “BOMB”</li>
</ol>
</blockquote>
<p><strong>The schematic</strong></p>
<p><img src="/images/theFinalBomb.png" alt="the final version"></p>
<p><strong>The first BOMB.</strong> 	</p>
<ul>
<li>Transmit  signal ( We only use the send module, so we just need one pin ( <strong>TX</strong> ))</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg51.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;; <span class="comment">//数码管驱动</span></span><br><span class="line"></span><br><span class="line">sbit start = P1^<span class="number">7</span>;</span><br><span class="line">sbit bomb  = P1^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> timeS=<span class="number">9</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delayNms</span><span class="params">(<span class="type">int</span> N)</span>    <span class="comment">// @11.0592MHz   延时函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);</span><br><span class="line">                N--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">serialInit</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        TH1=<span class="number">0xFD</span>;   <span class="comment">//Set timer 1 for BAUD=9600</span></span><br><span class="line">        TMOD=<span class="number">0x20</span>;   <span class="comment">//Set Timer 1 in Mode 2 8-bit Auto reload          </span></span><br><span class="line">        SCON=<span class="number">0x50</span>;   <span class="comment">//Set serial reception enable and Mode 1 8-bit UART</span></span><br><span class="line">        TR1=<span class="number">1</span>;     <span class="comment">//Start Timer 1</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptSetUp</span><span class="params">()</span>&#123;</span><br><span class="line">        IP  =  <span class="number">0x04</span>; </span><br><span class="line">     EA  =  <span class="number">1</span>;</span><br><span class="line">     EX0 =  <span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">        EX1 =  <span class="number">1</span>;</span><br><span class="line">     IT0 =  <span class="number">1</span>; <span class="comment">// set edge triggerin</span></span><br><span class="line">        IT1 =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> Message[<span class="number">15</span>]=&#123;<span class="string">&quot;BOMB&quot;</span>&#125;;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = Message[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        serialInit();<span class="comment">// initialize</span></span><br><span class="line">        interruptSetUp();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(start==<span class="number">0</span>)&#123;</span><br><span class="line">                        timeS=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                                P0=seg[timeS];</span><br><span class="line">                                delayNms(<span class="number">500</span>);</span><br><span class="line">                                timeS--;</span><br><span class="line">                                <span class="keyword">if</span>(timeS==<span class="number">-1</span>)&#123;</span><br><span class="line">                                        sendSignal();</span><br><span class="line">                                        delayNms(<span class="number">10</span>);</span><br><span class="line">                                        bomb=<span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123;    <span class="comment">// stop all the BOMBs entirely </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int1</span><span class="params">(<span class="type">void</span>)</span> interrupt 2&#123;</span><br><span class="line">        delayNms(<span class="number">5000</span>);        <span class="comment">//pause for 5 seconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The second BOMB</p>
<ul>
<li>Receive the signal from the last BOMB</li>
<li>Transmit signal to the third</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;; <span class="comment">//数码管驱动</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Message[<span class="number">15</span>]=&#123;<span class="string">&quot;BOMB&quot;</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> receivedMessage[<span class="number">15</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  r=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> timeS=<span class="number">9</span>;</span><br><span class="line">sbit bomb  = P1^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delayNms</span><span class="params">(<span class="type">int</span> N)</span>    <span class="comment">//@11.0592MHz   延时函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);</span><br><span class="line">                N--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptSetUp</span><span class="params">()</span>&#123;</span><br><span class="line">        IP  =  <span class="number">0x04</span>; </span><br><span class="line">   EA  =  <span class="number">1</span>;</span><br><span class="line">   EX0 =  <span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">        EX1 =  <span class="number">1</span>;</span><br><span class="line">   IT0 =  <span class="number">1</span>; <span class="comment">// set edge triggerin</span></span><br><span class="line">        IT1 =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">()</span>    <span class="comment">//9600bps@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  PCON &amp;= <span class="number">0x7F</span>;		<span class="comment">//波特率不倍速</span></span><br><span class="line">  SCON = <span class="number">0x50</span>;		<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;		<span class="comment">//清除定时器1模式位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;		<span class="comment">//设定定时器1为8位自动重装方式</span></span><br><span class="line">  TL1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时初值</span></span><br><span class="line">  TH1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时器重装值		</span></span><br><span class="line">  TR1 = <span class="number">1</span>;			<span class="comment">//启动定时器1</span></span><br><span class="line">  ET1 = <span class="number">0</span>;        	<span class="comment">//禁止定时器1中断</span></span><br><span class="line">  EA=<span class="number">1</span>;				<span class="comment">//开放总中断 </span></span><br><span class="line">  ES=<span class="number">1</span>;				<span class="comment">//开放串口中断</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Uartsend</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte)</span><span class="comment">//发送</span></span><br><span class="line">&#123;</span><br><span class="line">  receivedMessage[r]=byte;<span class="comment">//把数据写入发送缓冲区SBUF</span></span><br><span class="line">        r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = Message[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendReceivedSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = receivedMessage[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_ISR</span><span class="params">()</span> interrupt 4     <span class="comment">//串口中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(RI==<span class="number">1</span>)<span class="comment">//接收中断</span></span><br><span class="line">  &#123;</span><br><span class="line">    Uartsend(SBUF);<span class="comment">//把接收的数据发送到计算机</span></span><br><span class="line">    RI=<span class="number">0</span>;<span class="comment">//软件清零</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compareMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(receivedMessage[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>&amp;&amp;receivedMessage[<span class="number">1</span>]==<span class="string">&#x27;O&#x27;</span>&amp;&amp;receivedMessage[<span class="number">2</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;receivedMessage[<span class="number">3</span>]==<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  UartInit();</span><br><span class="line">        interruptSetUp();</span><br><span class="line">       </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">if</span>(compareMessage()==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                                P0=seg[timeS];</span><br><span class="line">                                delayNms(<span class="number">500</span>);</span><br><span class="line">                                timeS--;</span><br><span class="line">                                <span class="keyword">if</span>(timeS==<span class="number">-1</span>)&#123;</span><br><span class="line">                                        sendSignal();</span><br><span class="line">                                        delayNms(<span class="number">10</span>);</span><br><span class="line">                                        bomb=<span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int1</span><span class="params">(<span class="type">void</span>)</span> interrupt 2&#123;</span><br><span class="line">        delayNms(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>The THird BOMB.</strong></p>
<p>Actually it  does the same thing as the second one .</p>
<ul>
<li>Receive the signal from the last BOMB</li>
<li>Transmit signal to the third one</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;; <span class="comment">//数码管驱动</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Message[<span class="number">15</span>]=&#123;<span class="string">&quot;BOMB&quot;</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> receivedMessage[<span class="number">15</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  r=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> timeS=<span class="number">9</span>;</span><br><span class="line">sbit bomb  = P1^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delayNms</span><span class="params">(<span class="type">int</span> N)</span>    <span class="comment">//@11.0592MHz   延时函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);</span><br><span class="line">                N--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptSetUp</span><span class="params">()</span>&#123;</span><br><span class="line">        IP  =  <span class="number">0x04</span>; </span><br><span class="line">   EA  =  <span class="number">1</span>;</span><br><span class="line">   EX0 =  <span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">        EX1 =  <span class="number">1</span>;</span><br><span class="line">   IT0 =  <span class="number">1</span>; <span class="comment">// set edge triggerin</span></span><br><span class="line">        IT1 =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">()</span>    <span class="comment">//9600bps@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  PCON &amp;= <span class="number">0x7F</span>;		<span class="comment">//波特率不倍速</span></span><br><span class="line">  SCON = <span class="number">0x50</span>;		<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;		<span class="comment">//清除定时器1模式位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;		<span class="comment">//设定定时器1为8位自动重装方式</span></span><br><span class="line">  TL1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时初值</span></span><br><span class="line">  TH1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时器重装值		</span></span><br><span class="line">  TR1 = <span class="number">1</span>;			<span class="comment">//启动定时器1</span></span><br><span class="line">  ET1 = <span class="number">0</span>;        	<span class="comment">//禁止定时器1中断</span></span><br><span class="line">  EA=<span class="number">1</span>;				<span class="comment">//开放总中断 </span></span><br><span class="line">  ES=<span class="number">1</span>;				<span class="comment">//开放串口中断</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Uartsend</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte)</span><span class="comment">//发送</span></span><br><span class="line">&#123;</span><br><span class="line">  receivedMessage[r]=byte;<span class="comment">//把数据写入发送缓冲区SBUF</span></span><br><span class="line">        r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = Message[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendReceivedSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = receivedMessage[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_ISR</span><span class="params">()</span> interrupt 4     <span class="comment">//串口中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(RI==<span class="number">1</span>)<span class="comment">//接收中断</span></span><br><span class="line">  &#123;</span><br><span class="line">    Uartsend(SBUF);<span class="comment">//把接收的数据发送到计算机</span></span><br><span class="line">    RI=<span class="number">0</span>;<span class="comment">//软件清零</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compareMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(receivedMessage[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>&amp;&amp;receivedMessage[<span class="number">1</span>]==<span class="string">&#x27;O&#x27;</span>&amp;&amp;receivedMessage[<span class="number">2</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;receivedMessage[<span class="number">3</span>]==<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  UartInit();</span><br><span class="line">        interruptSetUp();</span><br><span class="line">       </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">if</span>(compareMessage()==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                                P0=seg[timeS];</span><br><span class="line">                                delayNms(<span class="number">500</span>);</span><br><span class="line">                                timeS--;</span><br><span class="line">                                <span class="keyword">if</span>(timeS==<span class="number">-1</span>)&#123;</span><br><span class="line">                                        sendSignal();</span><br><span class="line">                                        delayNms(<span class="number">10</span>);</span><br><span class="line">                                        bomb=<span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int1</span><span class="params">(<span class="type">void</span>)</span> interrupt 2&#123;</span><br><span class="line">        delayNms(<span class="number">5000</span>);</span><br><span class="line">&#125;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">()</span>    <span class="comment">//9600bps@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  PCON &amp;= <span class="number">0x7F</span>;		<span class="comment">//波特率不倍速</span></span><br><span class="line">  SCON = <span class="number">0x50</span>;		<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;		<span class="comment">//清除定时器1模式位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;		<span class="comment">//设定定时器1为8位自动重装方式</span></span><br><span class="line">  TL1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时初值</span></span><br><span class="line">  TH1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时器重装值		</span></span><br><span class="line">  TR1 = <span class="number">1</span>;			<span class="comment">//启动定时器1</span></span><br><span class="line">  ET1 = <span class="number">0</span>;        	<span class="comment">//禁止定时器1中断</span></span><br><span class="line">  EA=<span class="number">1</span>;				<span class="comment">//开放总中断 </span></span><br><span class="line">  ES=<span class="number">1</span>;				<span class="comment">//开放串口中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Uartsend</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte)</span><span class="comment">//发送</span></span><br><span class="line">&#123;</span><br><span class="line">  SBUF=byte;<span class="comment">//把数据写入发送缓冲区SBUF</span></span><br><span class="line">  <span class="comment">//数据发送完成的标志是TI=1；所以等待数据传送完</span></span><br><span class="line">  <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">  TI=<span class="number">0</span>;<span class="comment">//软件清零</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_ISR</span><span class="params">()</span> interrupt 4<span class="comment">//串口中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(RI==<span class="number">1</span>)<span class="comment">//接收中断</span></span><br><span class="line">  &#123;</span><br><span class="line">    Uartsend(SBUF);<span class="comment">//把接收的数据发送到下一个</span></span><br><span class="line">    RI=<span class="number">0</span>;<span class="comment">//软件清零</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  UartInit();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>This is the end of our BOMB</strong></p>
<p>Good luck .</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c51/" rel="tag">c51</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-微机原理与接口技术笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/26/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"
    >微机原理与接口技术笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/26/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-10-26T03:42:48.000Z" itemprop="datePublished">2023-10-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="汇编语言（8086为例）"><a href="#汇编语言（8086为例）" class="headerlink" title="汇编语言（8086为例）"></a>汇编语言（8086为例）</h1><p>—-基于《汇编语言第三版》王爽</p>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><ul>
<li>8086 CPU的简介</li>
</ul>
<blockquote>
<p>(1) 16位微处理器；</p>
<p>(2) 采用<strong>高速运算性能</strong>的 <code>HMOS</code> 工艺制造，芯片上集成了2.9万只晶体管；</p>
<p>(3) 使用单一的 <code>+5V</code> 电源，<code>40</code> 条引脚双列直插式封装；</p>
<p>(4) 时钟频率为 <code>5MHz~10MHz</code> ，基本指令执行时间为<code>0.3ms~0.6ms</code> ；</p>
<p>(5) 16根数据线和 20根地址线，可寻址的地址空间达 <code>1MB</code> (毕竟 16根地址线只可以寻址 64KB，太小了) ；</p>
</blockquote>
<ul>
<li>冯诺依曼架构</li>
</ul>
<blockquote>
<p><strong>冯·诺伊曼结构</strong>（英语：Von Neumann architecture），也称<strong>范·诺伊曼模型</strong>（Von Neumann model）或<strong>普林斯顿结构</strong>（Princeton architecture），是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。该结构包含：运算器、控制器、存储器、输入设备、输出设备。</p>
<blockquote>
<p>结构特点：</p>
<ol>
<li>以运算单元为中心</li>
<li>采用存储程序原理</li>
<li>存储器是按地址访问、线性编址的空间</li>
<li>控制流由指令流产生</li>
<li>指令由操作码和地址码组成</li>
<li>数据以二进制编码</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>存储单元</li>
</ul>
<blockquote>
<p>1 KB&#x3D;1024 B(字节)</p>
<p>1 字（word）&#x3D;2 字节</p>
<p>1 B&#x3D;8 bit</p>
</blockquote>
<ul>
<li>总线</li>
</ul>
<p>​	总线包含：<strong>数据总线，地址总线，控制总线</strong></p>
<p>​				<strong>地址总线</strong>：假设一个CPU有N根地址总线（即地址总线宽度为N），最多可以寻找2的N次方个内存单元。</p>
<p>​				<strong>数据总线</strong>：N根数据总线一次可以传输N位二进制数据。</p>
<p>​				8088 CPU数据总线宽度为8；8086 CPU数据总线宽度为16。</p>
<p>​				<strong>控制总线</strong>：N根代表N种控制。</p>
<h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.寄存器"></a>2.寄存器</h2><p>​		一个典型的CPU由：运算器，控制器，寄存器等器件构成。同时他们通过总线在内部相连接（地址，数据，控制）。对于汇编程序员来说，CPU的主要器件就是寄存器。</p>
<p>​		8086寄存器特征：16位  (数据最大为2^16-1)</p>
<p>​		8086 CPU的寄存器种类：</p>
<p><img src="/images/registerof8086.png" alt="register of Intel 8086"></p>
<blockquote>
<ul>
<li>AX</li>
<li>BX</li>
<li>CX</li>
<li>DX    &#x2F;&#x2F;    以上四个为通用寄存器，用于存放一般性数据</li>
<li>SI</li>
<li>DI</li>
<li>SP</li>
<li>BP</li>
<li>IP</li>
<li>CS</li>
<li>SS</li>
</ul>
</blockquote>
<ul>
<li><strong>通用寄存器</strong></li>
</ul>
<p>​		<em>AX,BX,CX,DX四个寄存器通常用来存放一般性数据，因此内成为通用寄存器</em>。</p>
<blockquote>
<p>8086的上一代CPU的寄存器是8位的，为了兼容性，这四个寄存器也可以当丞8个8位寄存器使用。</p>
<ul>
<li><p>AX—-AH,AL</p>
</li>
<li><p>BX—-BH,BL</p>
</li>
<li><p>CX—-DH,DL</p>
</li>
<li><p>DX—-DH,DL	    （L和H指的是low和high，即低位和高位）</p>
</li>
</ul>
</blockquote>
<ul>
<li>8086 CPU的物理地址给出方法</li>
</ul>
<p>​		<strong>物理地址&#x3D;段地址*16+偏移地址</strong>   （段地址*16  可以理解为段地址向左移四位）</p>
<blockquote>
<p>一个物理地址可以可以有不同的段地址和偏移地址</p>
<p>偏移地址为16位，寻址能力为2^16即 64 KB，所以一个段的长度不能超过 64 KB</p>
</blockquote>
<ul>
<li><strong>段寄存器</strong></li>
</ul>
<blockquote>
<p>8086 CPU 的段寄存器：</p>
<ul>
<li>CS</li>
<li>DS</li>
<li>SS</li>
<li>ES</li>
</ul>
</blockquote>
<ul>
<li>CS 和 IP</li>
</ul>
<p>​	对于8086 CPU来说，CS和IP一起指示了当前要读取指令的地址：CS :IP ，执行该位置的语句后IP会自动增加，从而可以进行下一指令的执行。</p>
<ul>
<li><p>CS 和 IP 寄存器的修改</p>
</li>
<li><p>* </p>
<ul>
<li>情况一：当你在写汇编脚本或者直接向内存中写入汇编指令时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用 JMP 指令</span><br><span class="line">使用方法： JMP 段地址：偏移地址</span><br><span class="line">eg: JMP 2AE3:3   //CS=2AE3,IP= 0003（均为16进制）</span><br><span class="line">或者（不想改变段地址时）</span><br><span class="line">JMP ax,    # 修改IP为 AX的值</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>情况二： 在debug.exe（MASM32）中想要修改当前程序运行位置时(后面将会介绍)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如在 dosBox中：</span><br><span class="line">debug.exe #进入debug模式</span><br><span class="line">-r CS</span><br><span class="line">CS 073f</span><br><span class="line">:XXXX(输入你需要位置)  # IP寄存器同理，通用寄存器也同上</span><br></pre></td></tr></table></figure>


</li>
<li><p>代码段</p>
</li>
</ul>
<p>​		即定义一片区域用于输入需要执行的代码。</p>
<ul>
<li><strong>debug的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-r              #显示CPU各个寄存器的值</span><br><span class="line">-r 寄存器名字    	 	 #修改寄存器的值</span><br><span class="line"></span><br><span class="line">-d              #查看当前地址的内容</span><br><span class="line">-d 段地址：偏移地址       #查看该段的地址</span><br><span class="line"></span><br><span class="line">-a              #从当前位置开始写入汇编指令</span><br><span class="line">-a 段地址：偏移地址        #从该位置开始写入汇编指令</span><br><span class="line"></span><br><span class="line">-e                        #从当前位置开始写入机器码</span><br><span class="line">-e 段地址：偏移地址        #从该位置开始写入机器码</span><br></pre></td></tr></table></figure>



<h2 id="3-寄存器（内存访问）"><a href="#3-寄存器（内存访问）" class="headerlink" title="3.寄存器（内存访问）"></a>3.寄存器（内存访问）</h2><ul>
<li><strong>字型数据</strong></li>
</ul>
<blockquote>
<p>​	CPU用16位寄存器存在出一个字。高八位存放高位字节，低八位存放低位字节。</p>
</blockquote>
<ul>
<li><strong>DS和[address]</strong></li>
</ul>
<p>​		<strong>物理地址&#x3D;段地址*16+偏移地址</strong>   （段地址<em>16  可以理解为段地址向左移四位），因此如果想要读写某个地址，首先应该知道其段地址和偏移地址，8086 CPU通过寄存器<strong>DS</strong>来获取段地址，[N]来表示偏移地址，*</em>[ … ]用来表示一个内存单元（）**。</p>
<p><strong>注意：8086CPU 不支持将数据直接送入段寄存器。</strong></p>
<ul>
<li>字型数据的传送</li>
</ul>
<p>​	eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,<span class="number">1000</span>H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov ax,[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>栈</strong></li>
</ul>
<p>​	使用8086 CPU编程时，可以将一段内存当做栈来使用。提供入栈和出栈指令，即<strong>PUSH 和 POP</strong></p>
<blockquote>
<p><strong>任意时刻，SS:SP 指向栈顶元素</strong> </p>
<p>同时，可以通过设置 SS,SP 寄存器的数据来修改栈的容量，地址。</p>
</blockquote>
<p>​	push pop指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push [0]         ;将 DS :0 处的字压入栈</span><br><span class="line">pop [2]          ;出栈，将数据送入 DS:0处</span><br></pre></td></tr></table></figure>









<h2 id="4-第一个程序"><a href="#4-第一个程序" class="headerlink" title="4.第一个程序"></a>4.第一个程序</h2><ul>
<li><strong>源程序（后缀 .asm）的编写</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;1.asm</span><br><span class="line">assume cs:codesg ;将用作代码段的段codesg和段寄存器cs联系起来。</span><br><span class="line"></span><br><span class="line">codesg segment ;定义一个段，段的名称为“codesg”，这个段从此开始</span><br><span class="line">         ;codesg是一个标号，作为一个段的名称，最终被编译连接成一个段的段地址</span><br><span class="line"></span><br><span class="line">  mov ax, 0123H</span><br><span class="line">  mov bx, 0456H </span><br><span class="line">  add ax, bx</span><br><span class="line">  add ax, ax </span><br><span class="line">  </span><br><span class="line">  mov ax, 4c00H </span><br><span class="line">  int 21H ;这两条指令实现程序的返回 ,相当于	return 0</span><br><span class="line">  </span><br><span class="line">codesg ends ;名称为“codesg”的段到此结束</span><br><span class="line"></span><br><span class="line">end ;编译器在编译汇编程序的过程中，碰到了伪指令end，结束对源程序的编译</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-bx-和loop指令"><a href="#5-bx-和loop指令" class="headerlink" title="5.[bx]和loop指令"></a>5.[bx]和loop指令</h2><blockquote>
<p><strong>bx</strong></p>
<p>​	[bx]也表示一个内存单元，它的偏移地址在bx中</p>
<p><strong>loop</strong></p>
<p>​	通用寄存器CX存储循环次数，循环一次：（cx）&#x3D; （cx）- 1；</p>
</blockquote>
<p>案例程序：</p>
<ol>
<li>实现2^12</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">  mov ax, 2</span><br><span class="line">  </span><br><span class="line">  mov cx, 11 ;循环次数</span><br><span class="line">s:  add ax, ax </span><br><span class="line">  loop s     ;在汇编语言中，标号代表一个地址，标号s实际上标识了一个地址，</span><br><span class="line">               ;这个地址处有一条指令：add ax，ax。</span><br><span class="line">               ;执行loop s时，首先要将（cx）减1，然后若（cx）不为0，则向前</span><br><span class="line">               ;转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。</span><br><span class="line">  </span><br><span class="line">  mov ax,4c00h </span><br><span class="line">  int 21h </span><br><span class="line">code ends </span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现将内存<code>ffff:0 ~ ffff:b</code>单元中的数据复制到<code>0:200 ~ 0:20b</code>单元中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">  mov ax, 0ffffh </span><br><span class="line">  mov ds, ax  	 ;（ds）= 0ffffh </span><br><span class="line">  mov ax, 0020h</span><br><span class="line">    mov es, ax     ;（es）= 0020h     0:200 等效于 0020:0</span><br><span class="line">    mov bx, 0       ;（bx）= 0，此时ds:bx指向ffff:0，es:bx指向0020:0</span><br><span class="line">    </span><br><span class="line">  mov cx，12  	    ;（cx）=12，循环12次</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">s:  mov dl，[bx]   ;（d1）=（（ds）* 16+（bx）），将ffff:bx中的字节数据送入dl </span><br><span class="line">  mov es:[bx]，dl 	;（（es）*16+（bx））=（d1），将dl中的数据送入0020:bx </span><br><span class="line">  inc bx  		;（bx）=（bx）+1</span><br><span class="line">  loop s </span><br><span class="line">  </span><br><span class="line">  mov ax，4c00h </span><br><span class="line">  int 21h </span><br><span class="line">code ends </span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="6-包含多个段的程序"><a href="#6-包含多个段的程序" class="headerlink" title="6.包含多个段的程序"></a>6.包含多个段的程序</h2><ul>
<li><ol>
<li>在代码中使用数据</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;计算 8 个数据的和存到 ax 寄存器</span><br><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line"></span><br><span class="line">  dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据</span><br><span class="line"></span><br><span class="line">  start:	mov bx, 0  ;标号start</span><br><span class="line">      mov ax, 0  </span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s:		add ax, cs:[bx]</span><br><span class="line">      add bx, 2</span><br><span class="line">      loop s </span><br><span class="line">      </span><br><span class="line">      mov ax, 4c00h </span><br><span class="line">      int 21h </span><br><span class="line">code ends</span><br><span class="line">end start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方</span><br><span class="line">       	 ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在代码中使用栈</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;利用栈，将程序中定义的数据逆序存放。</span><br><span class="line">assume cs:codesg </span><br><span class="line"></span><br><span class="line">codesg segment </span><br><span class="line">  dw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h ; 0-15单元</span><br><span class="line">  dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0 ; 16-47单元作为栈使用</span><br><span class="line">      </span><br><span class="line">  start:	mov ax, cs </span><br><span class="line">      mov ss, ax </span><br><span class="line">      mov sp, 30h ;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d</span><br><span class="line">      mov bx, 0</span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s:		push cs:[bx]</span><br><span class="line">      add bx, 2</span><br><span class="line">      loop s    ;以上将代码段0~15单元中的8个字型数据依次入栈</span><br><span class="line">      </span><br><span class="line">      mov bx, 0</span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s0:		pop cs:[bx]		</span><br><span class="line">      add bx，2</span><br><span class="line">      loop s0   ;以上依次出栈8个字型数据到代码段0~15单元中</span><br><span class="line">      </span><br><span class="line">      mov ax，4c00h </span><br><span class="line">      int 21h </span><br><span class="line">codesg ends </span><br><span class="line">end start  ;指明程序的入口在start处</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将数据、代码、栈放入不同的段</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack </span><br><span class="line"></span><br><span class="line">data segment </span><br><span class="line">  dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;0-15单元</span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">stack segment </span><br><span class="line">  dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;0-31单元</span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">  start:	mov ax, stack;将名称为“stack”的段的段地址送入ax</span><br><span class="line">      mov ss, ax</span><br><span class="line">      mov sp, 20h  ;设置栈顶ss:sp指向stack:20。 20h = 32d</span><br><span class="line">      </span><br><span class="line">      mov ax, data ;将名称为“data”的段的段地址送入ax</span><br><span class="line">      mov ds, ax   ;ds指向data段</span><br><span class="line">      </span><br><span class="line">      mov bx, 0    ;ds:bx指向data段中的第一个单元</span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s:	    push [bx]</span><br><span class="line">      add bx, 2</span><br><span class="line">      loop s       ;以上将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line">      </span><br><span class="line">      mov bx, 0</span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s0:		pop [bx]</span><br><span class="line">      add bx, 2</span><br><span class="line">      loop s0      ;以上依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line">      </span><br><span class="line">      mov ax, 4c00h </span><br><span class="line">      int 21h </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，</span><br><span class="line">;可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="7-更灵活灵活的定位内存地址的方法"><a href="#7-更灵活灵活的定位内存地址的方法" class="headerlink" title="7.更灵活灵活的定位内存地址的方法"></a>7.更灵活灵活的定位内存地址的方法</h2><pre><code>* **and 和 or 指令**
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al , 01100011B</span><br><span class="line">and al , 00111011B    ;按位与，执行后：al=00100011B</span><br><span class="line"></span><br><span class="line">mov al, 01100011B</span><br><span class="line">or al, 00111011B    ;按位或，执行后：al=01111011B</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>ASCII</strong></li>
</ul>
<ol>
<li>以字符的形式给出数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data </span><br><span class="line"></span><br><span class="line">data segment </span><br><span class="line">  db &#x27;unIx&#x27;   ;相当于“db 75H，6EH，49H，58H”</span><br><span class="line">  db &#x27;foRK&#x27;</span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov al, &#x27;a&#x27;  ;相当于“mov al, 61H”，“a”的ASCI码为61H；</span><br><span class="line">    mov b1, &#x27;b&#x27;</span><br><span class="line">    </span><br><span class="line">    mov ax, 4c00h </span><br><span class="line">    int 21h </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>大小写转换</li>
</ol>
<p>​		<strong>小写字母的ASCII码值比大写字母的ASCII码值大20H</strong></p>
<p>​		<strong>大写字母ASCII码的第5位为0，小写字母的第5位为1(其他一致)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg </span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">  db &#x27;BaSiC&#x27;</span><br><span class="line">  db &#x27;iNfOrMaTion&#x27;</span><br><span class="line">datasg end</span><br><span class="line"></span><br><span class="line">codesg segment </span><br><span class="line">  start:	mov ax, datasg </span><br><span class="line">      mov ds, ax	;设置ds 指向 datasg段</span><br><span class="line">    </span><br><span class="line">      mov bx, 0	;设置（bx）=0，ds:bx指向’BaSic’的第一个字母</span><br><span class="line">      </span><br><span class="line">      mov cx, 5     	 ;设置循环次数5，因为’Basic&#x27;有5个字母</span><br><span class="line">  s:		mov al, [bx]     ;将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">      and al, 11011111B;将al中的ASCII码的第5位置为0，变为大写字母</span><br><span class="line">      mov [bx], al	 ;将转变后的ASCII码写回原单元</span><br><span class="line">      inc bx		     ;（bx）加1，ds:bx指向下一个字母</span><br><span class="line">      loop s </span><br><span class="line">      </span><br><span class="line">      mov bx, 5	;设置（bx）=5，ds:bx指向，iNfOrMaTion&#x27;的第一个字母</span><br><span class="line">      </span><br><span class="line">      mov cx, 11	;设置循环次数11，因为‘iNfOrMaTion&#x27;有11个字母</span><br><span class="line">  s0:		mov al, [bx]</span><br><span class="line">      or al, 00100000B;将a1中的ASCII码的第5位置为1，变为小写字母</span><br><span class="line">      mov [bx], al </span><br><span class="line">      inc bx</span><br><span class="line">      loop s0</span><br><span class="line">      </span><br><span class="line">      mov ax, 4c00h </span><br><span class="line">      int 21h </span><br><span class="line">codesg ends</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>SI 和 DI</li>
</ol>
<p>​	SI 和 DI 是8086 CPU中和 bx 功能相近的寄存器，但是 SI 和 DI 不能分成连个该8为寄存器使用。</p>
<blockquote>
<p>idata : 立即数，直接的数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1                 ;对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）</span><br><span class="line">add bx, 2000h             ;在汇编语言中称为：立即数（idata）</span><br><span class="line">or bx, 00010000b</span><br><span class="line">mov al, &#x27;a&#x27;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>处理数据的长度</li>
</ol>
<blockquote>
<p>8086CPU的指令，可以处理两种尺寸的数据，byte和word（字节和字）。</p>
<p>通过寄<strong>存器名</strong>指明要处理的数据的尺寸。<br>例如： mov <strong>al</strong>, ds:[0] 寄存器al指明了数据为1字节</p>
<p>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte。<br>例如：mov byte ptr ds:[0], 1 byte ptr 指明了指令访问的内存单元是一个字节单元</p>
<p>有些<strong>指令默认</strong>了访问的是字单元还是字节单元<br>例如，push [1000H]，push 指令只进行<strong>字</strong>操作。</p>
</blockquote>
<ol start="6">
<li><strong>div指令、dd、dup、mul指令</strong></li>
</ol>
<blockquote>
<p>div ：除法指令。</p>
<p>除数：有8位和16位两种，在一个寄存器或内存单元中。</p>
<p>被除数：默认放在AX或DX和AX中，<br>如果除数为8位，被除数则为16位，默认在AX中存放；<br>如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</p>
<p>结果：<br>如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；<br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;利用除法指令计算100001/100。</span><br><span class="line">;100001D = 186A1H</span><br><span class="line">mov dx, 1</span><br><span class="line">mov ax, 86A1H ;(dx)*10000H+(ax)=100001</span><br><span class="line">mov bx, 100</span><br><span class="line">div bx</span><br><span class="line"></span><br><span class="line">;利用除法指令计算1001/100</span><br><span class="line">mov ax, 1001</span><br><span class="line">mov bl, 100</span><br><span class="line">div b1</span><br></pre></td></tr></table></figure>



<blockquote>
<p>dd：</p>
<ul>
<li><p>db 和 dw 定义字节型数据和字型数据。</p>
</li>
<li><p>dd 是用来定义dword（double word，<strong>双字（四个字节）</strong>）型数据的伪指令</p>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dd 100001</span><br><span class="line">dw 100</span><br><span class="line">dw 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>操作符：</p>
<p>与db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0)       ;定义了3个字节，它们的值都是0，相当于db 0，0，0。</span><br><span class="line">db 3 dup (0, 1, 2) ;定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0，1，2，0，1，2，0，1，2。</span><br><span class="line">db 3 dup (&#x27;abc&#x27;, &#x27;ABC&#x27;) ;定义了18个字节，它们是abcABCabcABCabcABCC，相当于db &#x27;abc&#x27;, &#x27;ABC&#x27; ,&#x27;abc&#x27; , &#x27;ABC, &#x27;abc&#x27;, &#x27;ABC&#x27;。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>mul 指令 ：</p>
<ul>
<li><p>mul是乘法指令，使用 mul 做乘法的时候：相乘的两个数：要么都是8位，要么都是16位。</p>
</li>
<li><p>乘数：</p>
<ul>
<li><ol>
<li>8 位： <code>AL</code>中和 <code>8位寄存器</code>或<code>内存字节单元</code>中；</li>
<li>16 位： <code>AX</code>中和 <code>16 位寄存器</code>或<code>内存字单元</code>中。</li>
</ol>
</li>
</ul>
</li>
<li><p>结果：</p>
<ul>
<li>8位：AX中；</li>
<li>16位：DX（高位）和 AX（低位）中</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; 8 位</span><br><span class="line">;计算100*10</span><br><span class="line">;100和10小于255，可以做8位乘法</span><br><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br><span class="line"></span><br><span class="line">;结果： (ax)=1000（03E8H） </span><br><span class="line"></span><br><span class="line">; 16 位置</span><br><span class="line"></span><br><span class="line">;计算100*10000</span><br><span class="line">;100小于255，可10000大于255，所以必须做16位乘法，程序如下：</span><br><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br><span class="line"></span><br><span class="line">;结果： (ax)=4240H，(dx)=000FH     （F4240H=1000000）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8-数据处理的两个基本问题"><a href="#8-数据处理的两个基本问题" class="headerlink" title="8.数据处理的两个基本问题"></a>8.数据处理的两个基本问题</h2><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><strong>只有四个寄存器可以通过 [ … ] 进行内存单元的寻址</strong> </p>
<ul>
<li>以下代码为错误代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[cx]</span><br><span class="line">mov ax,[dx]</span><br><span class="line">mov ax,[ax]</span><br><span class="line">mov ax,[ds]</span><br></pre></td></tr></table></figure>

<ul>
<li>在 [ … ] 中四个寄存器可以单独出现，或只能以四种组合出现</li>
</ul>
<blockquote>
<ol>
<li>bx 和 si</li>
<li>bx 和 di</li>
<li>bp 和 si</li>
<li>bp 和 di</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">            ;也可以加上data</span><br><span class="line">mov ax,[bx+si+idata</span><br><span class="line">mov ax,[bx+di+1]</span><br><span class="line">mov ax,[bp+si+2</span><br><span class="line">mov ax,[bp+di+3</span><br></pre></td></tr></table></figure>

<h3 id="处理的数据的大小"><a href="#处理的数据的大小" class="headerlink" title="处理的数据的大小"></a>处理的数据的大小</h3><ul>
<li>一般是字或者字节</li>
</ul>
<blockquote>
<p>在没有寄存器名的情况下可以使用 <code>X ptr</code>指明内存单元的长度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr []bx</span><br><span class="line">add word ptr [bx],2</span><br><span class="line"></span><br><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr []bx</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure>





<h2 id="9-转移指令"><a href="#9-转移指令" class="headerlink" title="9.转移指令"></a>9.转移指令</h2><blockquote>
<p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp ax        ; 段内转移</span><br><span class="line">jmp 1000:0     ; 段间转移</span><br></pre></td></tr></table></figure>

<p><strong>offset</strong></p>
<blockquote>
<p>操作符offset在编语言中是由编译器处理的符号，它的功能是<strong>取得标号的偏移地址</strong>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                  ;将s处的一条指令复制到s0处</span><br><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line"> s:   mov ax, bx                 ;（mov ax,bx 的机器码占两个字节）</span><br><span class="line">      mov si, offset s           ;获得标号s的偏移地址</span><br><span class="line">      mov di, offset s0          ;获得标号s0的偏移地址</span><br><span class="line">      </span><br><span class="line">      mov ax, cs:[si]</span><br><span class="line">      mov cs:[di], ax</span><br><span class="line"> s0:  nop                           ;（nop的机器码占一个字节）</span><br><span class="line">      nop</span><br><span class="line"> codesg ends</span><br><span class="line"> ends</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>jmp指令</strong></p>
<blockquote>
<p><strong>jmp 为无条件转移</strong>，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；</p>
<p>jmp 指令要给出两种信息：</p>
<ol>
<li><p>转移的目的地址</p>
</li>
<li><p>转移的距离（段间转移、段内短转移，段内近转移）</p>
<p>jmp short 标号 jmp near ptr 标号 jcxz 标号 loop 标号 等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</p>
</li>
</ol>
</blockquote>
<ol>
<li><strong>jmp short 标号</strong></li>
</ol>
<ul>
<li>实现段内短转移修改范围（-128-127）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,9527h</span><br><span class="line">jmp short s        ; 跳转到</span><br><span class="line">add ax,1111h</span><br><span class="line">s: mov ax,2222h      ; 这里</span><br><span class="line">mov ax 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>jmp near ptr</strong></li>
</ol>
<ul>
<li>实现段内近转移（修改范围大于（-128-127）但是小于-32768～32767，编译成功但链接失败），这是jmp short 实现不了的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,9527h</span><br><span class="line">jmp near ptr s        ; 跳转到</span><br><span class="line">db 128 dup(0)        ; 制造距离超过127</span><br><span class="line">s: mov ax,2222h      ; 这里</span><br><span class="line">mov ax 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>jmp far ptr</strong></li>
</ol>
<ul>
<li>实现段间转移（修改范围超过-32768～32767）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,9527h</span><br><span class="line">jmp near ptr s        ; 跳转到</span><br><span class="line">db 32768 dup(0)        ; 制造距离超过32767</span><br><span class="line">s: mov ax,2222h      ; 这里</span><br><span class="line">mov ax 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<ol start="3">
<li><strong>转移地址在寄存器或内存中的jmp指令</strong></li>
</ol>
<ul>
<li>jmp 寄存器，直接修改ip为寄存器的值</li>
<li>jmp word ptr 内存单元</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0123H</span><br><span class="line">mov ds:[0], ax</span><br><span class="line">jmp word ptr ds:[0]      ;执行后，(IP)=0123H</span><br></pre></td></tr></table></figure>



<p><strong>jxcz 标号</strong> </p>
<blockquote>
<p>如果(cx)&#x3D;0,转移到标号处执行；若(cx) !&#x3D; 0,继续向下执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">data segment</span><br><span class="line">  db 0,0,0</span><br><span class="line">data ends</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">stack segment</span><br><span class="line"> </span><br><span class="line">  dw 16 dup(0)</span><br><span class="line"> </span><br><span class="line">stack ends</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">code segment  </span><br><span class="line">start:  mov  ax,2000H</span><br><span class="line">    mov  ds,ax</span><br><span class="line">    mov  bx,0</span><br><span class="line"> </span><br><span class="line">s:    mov  ch,0</span><br><span class="line">    mov  cl,ds:[bx]</span><br><span class="line">    jcxz ok		;若(cx)==0，跳转至ok标号处执行</span><br><span class="line">    inc  bx		;继续循环，直至查找到第一个值为0的字节</span><br><span class="line">    jmp  short s</span><br><span class="line"> </span><br><span class="line">ok:    mov  dx,bx</span><br><span class="line">    mov  ax,4c00H</span><br><span class="line">    int  21H</span><br><span class="line">code ends</span><br><span class="line"> </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="10-call和ret指令"><a href="#10-call和ret指令" class="headerlink" title="10.call和ret指令"></a>10.call和ret指令</h2><ul>
<li><strong>ret和retf</strong></li>
</ul>
<blockquote>
<ul>
<li><strong>ret</strong>指令用栈中的数据，修改IP的内容，从而实现<strong>近转移</strong></li>
</ul>
<p>对于ret：相当于<strong>一次</strong> pop，把数据放在ip里</p>
<ul>
<li><strong>retf</strong>指令用栈中的数据，修改CS和IP的内容，从而实现<strong>远转移</strong>。</li>
</ul>
<p>对于ret：相当于<strong>两次</strong> pop，第一次数据放在ip里，第二次放cs里</p>
</blockquote>
<ul>
<li><strong>call指令</strong></li>
</ul>
<p>类似于jmp，<strong>但是</strong>多了一个功能：<strong>将当前的 IP 或 CS和IP 压入栈中</strong>，此外，call没有短转移</p>
<ul>
<li><strong>call和ret的连招</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,1</span><br><span class="line">      mov cx,3</span><br><span class="line">       call s ;（1）CPU指令缓冲器存放call指令，IP指向下一条指令（mov bx, ax），执行call指令，IP入栈，jmp</span><br><span class="line">       </span><br><span class="line">      mov bx,ax;（4）IP重新指向这里  bx = 8</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     s: add ax,ax</span><br><span class="line">       loop s;（2）循环3次ax = 8</span><br><span class="line">      ret;（3）return : pop IP</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="10-错题"><a href="#10-错题" class="headerlink" title="10.错题"></a>10.错题</h2><blockquote>
<p>一、下列关于8086CPU的工作原理的描述错误的是__3__。<br> 1、 汇编程序员可以通过对各种寄存器中内容的修改实现对CPU的控制。<br> 2、 CPU在访问内存时，采用“段地址*16+偏移地址”的形式给出要访问的内存单元的物理地址。<br>3、 任意时刻，CS:IP指向的内容即是此刻CPU正在执行的指令。<br> 4、 传送指令能够更改所有通用寄存器的内容。</p>
<p>注解：</p>
<pre><code> 1、正确，见课本P13
 2、正确 
 3、错误。课本P24，8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行。此处的含义是**将要执行**，比如输入T,CPU读取CS:IP的内容，载入指令执行，而不是正在执行。
 4、通用寄存器是AX、BX、CX、DX，传送指令是mov，mov指令可以改变4个通用寄存器的内容
</code></pre>
</blockquote>
<blockquote>
<p>六、下列说法中正确的是：<strong>4</strong><br>1、 8086CPU采用“段地址*16+偏移地址&#x3D;物理地址”的寻址模式，所以内存是由一个一个的段组成，每一个段有一个段地址。<br>2、 物理地址为ffff0H的内存单元的偏移地址可能为ffffH。<br>3、 一个段的大小可以是8Byte。<br>4、 在一段没有任何跳转指令的程序中，超出64K的部分将不会被执行。</p>
<p>注解：</p>
<pre><code> 1、第一句、第三句正确，第二句错误。内存没有分段，段的划分来自于CPU.见课本P22
 2、错误，不可能，若偏移地址为FFFFH，则段地址为EFFF1H，是不对的
 3、段大小最小16B(Byte)
 4、正确，CPU执行指令取决于CS;IP，IP最大65535，超过64K的IP不识别，CPU也就无法执行。
</code></pre>
</blockquote>
<blockquote>
<p>五、16位结构的CPU 不一定具备的特性是：<strong>4</strong><br>1、 运算器一次最多可以处理16位的数据<br>2、 寄存器的最大宽度为16位<br>3、 寄存器和运算器之间的通路为16位<br>4、 地址总线为16根</p>
<p>注解：见课本P18<br>      16位CPU特征：运算器一次最多可以处理16位的数据<br>                             寄存器的最大宽度为16位<br>                             寄存器和运算器之间的通路为16位<br>       8086CPU有20根地址总线，可以传送20位地址。故选择4</p>
</blockquote>
<blockquote>
<p>5.若将以1000H为段地址的整个段空间当作栈使用，那么寄存器SP的初始值最合理的设置是_____。 (1)<br>1、  0000H<br>2、  0001H<br>3、  FFFFH<br>4、  FFFEH</p>
<p>注解：以1000H为段地址的整个段空间，偏移地址为0-FFFFH，当栈中只有1个字时，偏移地址是FFFEH，当栈为空时，SP&#x3D;SP+2&#x3D;FFFF+2&#x3D;0000，所以选择1 </p>
<p>下列指令的书写正确的是： 3 。<br>1、 push al<br>2、 mov cs:[0],ds:[10]<br>3、 pop si<br>4、 mov ds:[0],2</p>
<p>解析：答案1错误，压堆指令一次性操作一个字；答案2错误，内存空间之间不能互相传送；答案3正确；答案4错误，不能将立即数送入内存空间</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-java学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/16/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >java学习笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/16/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-10-16T15:55:18.000Z" itemprop="datePublished">2023-10-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="JAVA学习笔记"><a href="#JAVA学习笔记" class="headerlink" title="JAVA学习笔记"></a>JAVA学习笔记</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><ul>
<li>初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1=“Java”；// 字符串常量值</span><br><span class="line">String str3=“Java”;  //  字符串常量，并且与str1地址相同</span><br><span class="line">String str2=new String(“Java”);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1.length()   <span class="comment">//带括号,与数组不同！！！</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串查找</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1.charAt(0);  // J</span><br><span class="line">str1.charAt(1);  // a</span><br><span class="line">str1.charAt(2);  // v</span><br><span class="line">str1.charAt(4);  // a</span><br><span class="line">str1.charAt(5);  // 报错</span><br></pre></td></tr></table></figure>

<ul>
<li>返回字符出现的第一个位置下标，否则返回-1</li>
</ul>
<p>a. 从字符串的头开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int index = str1.indexOf(&#x27;J&#x27;);</span><br><span class="line">System.out.println(index);//  0</span><br></pre></td></tr></table></figure>

<p>b. 从下表x开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int index1 = str1.indexOf(&#x27;a&#x27;,2);</span><br><span class="line">System.out.println(index1);  //3</span><br></pre></td></tr></table></figure>

<ul>
<li>返回字符串出现的位置下标, 从index 开始向<strong>后</strong>找 , 否则返回-1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;helloxawllxhxawllxh&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">index3</span> <span class="operator">=</span> s2.lastIndexOf(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    System.out.println(index3);<span class="comment">//13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回字符串出现的位置下标, 从index 开始向<strong>前</strong>找 , 否则返回-1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s2 = &quot;helloxawllxhxawllxh&quot;;</span><br><span class="line"> </span><br><span class="line">    int index3 = s2.lastIndexOf(&#x27;xawl&#x27;);</span><br><span class="line">    System.out.println(index3);//12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串的截取</strong></li>
</ul>
<ol>
<li>截取后面的字符串内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = &quot;adsasdasdasdasd&quot;;</span><br><span class="line">    String ret = str.substring(4);// 保留第4个</span><br><span class="line">    System.out.println(ret);//sdasdasdasd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>截取指定部分</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = &quot;adsasdasdasdasd&quot;;</span><br><span class="line">    String ret = str.substring(4,7);//截取[4,7)里面的字符</span><br><span class="line">    System.out.println(ret);//sda</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串的替换</strong></li>
</ul>
<ol>
<li>使用replace或者replaceAll</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;xawlxawlxawlxawl&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;xa&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret1</span> <span class="operator">=</span> str1.replaceAll(<span class="string">&quot;xa&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    System.out.println(ret);<span class="comment">//BwlBwlBwlBwl</span></span><br><span class="line">    System.out.println(ret1);<span class="comment">//BwlBwlBwlBwl</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//xawlxawlxawlxawl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串的拆分</strong></li>
</ul>
<p>​		使用split方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str1 = &quot;Hello this is xawl rjgc professional&quot;;</span><br><span class="line">    String[] ret = str1.split(&quot; &quot;);      //以空格为分隔符，拆分整个字符串为多个字符串</span><br><span class="line">    for (String s : ret) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/******************************************************/</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    String str1 = &quot;Hello this is xawl rjgc professional&quot;;</span><br><span class="line">    String[] ret = str1.split(&quot; &quot;,3);    //以空格为分隔符，拆分3个字符串</span><br><span class="line">    for (String s : ret) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 特殊字符(| + * . ,)作为分割符可能无法正确切分, 需要加上转义.</p>
<ul>
<li><p><strong>字符串的转化</strong></p>
<pre><code>  1. 将别的数据类型转为字符串**valueOf( elementType i)**
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = String.valueOf(1234);</span><br><span class="line">    String str1 = String.valueOf(12.34);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>小写字母转大写字母或者相反 <strong>toUpperCase()</strong>&amp;<strong>toLowerCase()</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">    String str3 = &quot;abcdef阿凡达&quot;;</span><br><span class="line">    String ret = str3.toUpperCase();</span><br><span class="line">    System.out.println(ret);//ABCDEF阿凡达</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h3><ul>
<li><p>初始化</p>
<p>  int [] a;&#x2F;&#x2F;创建一个数组引用<br>  a&#x3D;new int[4];<br>  int [] b&#x3D;{1,2,3,4};</p>
</li>
<li><p>数组的接口</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//数组的长度</span><br><span class="line">int Alength=a.length;</span><br></pre></td></tr></table></figure>

<ul>
<li>Arrays数组工具类</li>
</ul>
<ol>
<li>&#x2F;&#x2F;转化为String</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//转化为String</span><br><span class="line">String str=Arrays.tString(array);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数组拷贝和扩容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] tmp = Arrays.copyOf(array,2*array.length);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Arrays.binarySearch</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//查找成功的话会返回数据的位置</span><br><span class="line">int index = Arrays.binarySearch(arr, 55);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Arrays.equals（比较两个数组是否相等）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.equals(int[] a, int [] b);</span><br><span class="line">//当且仅当a.b非空，长度相同，元素相同时返回true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Arrays.fill(填充；一般用于初始化)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(array,val);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Arrays.sort(arr)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr);//默认升序</span><br></pre></td></tr></table></figure>



<h3 id="3-数据类型转换"><a href="#3-数据类型转换" class="headerlink" title="3.数据类型转换"></a>3.数据类型转换</h3><ul>
<li>数据类型的大小关系</li>
</ul>
<p>​																<strong>byte&lt;short&lt;char&lt;int&lt;long&lt;float&lt;double</strong></p>
<ul>
<li><p>强制数据类型的转换，一般来说，大的数据类型不能赋给小的数据类型。因而会有强制数据类型转换</p>
<p><strong>强制数据类型转换可能会导致数据的丢失</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num_1=<span class="number">20</span>;</span><br><span class="line"><span class="type">byte</span> num_2=(<span class="type">byte</span>) a;</span><br><span class="line"><span class="type">int</span> num_3=<span class="number">300</span>;</span><br><span class="line"><span class="type">byte</span> num_4=(<span class="type">byte</span>)num_3;<span class="comment">//数据丢失 num_4值为44</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Java-中super的用法"><a href="#4-Java-中super的用法" class="headerlink" title="4. Java 中super的用法"></a>4. Java 中super的用法</h3><p>​	<strong>当子类的构造方法内第一行没有出现“super()”时，系统会默认给它加上无参数的”super()”方法</strong>。</p>
<p>注意：</p>
<ol>
<li>当子类构造方法的第一行执行super()无参数方法，那么父类中一定要有无参数构造方法。</li>
<li>在一个类中写了有参数的构造方法时，无参数构造方法就会不存在，需要自己补上无参数的构造方法。</li>
</ol>
<ul>
<li>super使用案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">father</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">father</span><span class="params">(<span class="type">int</span> a)</span>&#123;<span class="built_in">this</span>.age=age;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> <span class="keyword">extends</span> <span class="title class_">father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">son</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><h3 id="Java-中-final-的用法"><a href="#Java-中-final-的用法" class="headerlink" title="Java 中   final  的用法"></a>Java 中   final  的用法</h3></li>
</ol>
<ul>
<li><p>解释：<strong>Java中，final 表示最终，也可以称为完结器，表示对象是最终形态的，不可改变的意思。</strong></p>
</li>
<li><p>使用时的注意事项</p>
</li>
</ul>
<blockquote>
<p>1）final 修饰变量，表示变量的值不可改变，此时该变量可被称为常量。</p>
<p>2）final 修饰方法，表示方法不能被子类重写；</p>
<blockquote>
<p>重写：子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写，又称为方法覆盖。</p>
</blockquote>
<p>3）final 用在类的前面表示该类不能有子类，即该类不可以被继承。</p>
</blockquote>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修饰变量</span></span><br><span class="line"><span class="comment">//final 变量经常和 static 关键字一起使用，作为常量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;regen&quot;</span>;</span><br><span class="line">NAME = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;regen&quot;</span>); <span class="comment">//invalid compilation error</span></span><br><span class="line"><span class="comment">//修饰方法</span></span><br><span class="line"><span class="comment">//被修饰的方法禁止被重写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user：&quot;</span>张三<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Reader extends User&#123;</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public final String getName()&#123;</span></span><br><span class="line"><span class="string">        return &quot;</span>李四<span class="string">&quot;; //compilation error: overridden method is final</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//final修饰类</span></span><br><span class="line"><span class="string">//例如 java 中的String类</span></span><br><span class="line"><span class="string">//表示该类 具有完整的功能，不能被继承</span></span><br><span class="line"><span class="string">public final class String</span></span><br><span class="line"><span class="string">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span></span><br><span class="line"><span class="string">    /** The value is used for character storage. */</span></span><br><span class="line"><span class="string">    private final char value[];</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点</li>
</ul>
<ol>
<li><p>final 关键字，提高了性能，JVM 和 Java 应用都会缓存 final 变量。</p>
</li>
<li><p>final 变量，可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</p>
</li>
</ol>
<h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><blockquote>
<p>java bean</p>
<blockquote>
<ul>
<li>提供一个默认的无参构造函数。</li>
<li>需要被序列化并且实现了 Serializable 接口。</li>
<li>可能有一系列可读写属性，并且一般是 private 的。</li>
<li>可能有一系列的 getter 或 setter 方法。</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    privete String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span> &#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> neweAge)</span> &#123;</span><br><span class="line">        age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1.JVM内存结构"></a>1.JVM内存结构</h3><pre><code>        * 对象的存储结构
                对象应该看作一个地址
                对象名指向堆中的首地址（swap 案例）
        基本数据类型比较的是数值，而引用数据类型比较的是内存地址
</code></pre>
<ul>
<li><strong>JVM运行时的数据区</strong></li>
</ul>
<p>​											<strong>堆、栈、方法区、程序计数器</strong></p>
<p><img src="/images/jvmRunZone.png" alt="jvmRunZone"></p>
<ul>
<li><strong>程序计数器</strong></li>
</ul>
<blockquote>
<p><strong>程序技计数器一个线程独享的数据区域，也就是说，每个线程之间的数据相互不干扰，是一个线程内存空间。</strong></p>
</blockquote>
<blockquote>
<p><strong>可以当成字节码的行号指示器</strong></p>
</blockquote>
<ul>
<li><strong>栈</strong></li>
</ul>
<p>​		JVM的栈包括<strong>Java虚拟机栈</strong>和本地方法栈</p>
<ol>
<li>Java虚拟机栈：执行Java方法服务。</li>
<li>本地方法栈： 执行JVM使用到的Native方法服务。</li>
</ol>
<blockquote>
<p>natine 方法是什么？</p>
<p>JDK 中有很多方法是使用 Native 修饰的。Native 方法不是以 Java 语言实现的，而是以本地语言实现的（比如 C 或 C++）</p>
</blockquote>
<ul>
<li><strong>JVM虚拟机栈</strong></li>
</ul>
<ol>
<li>栈是线程私有的，每个线程拥有独立的栈空间</li>
<li>栈的元素为栈帧</li>
</ol>
<ul>
<li><strong>Java堆</strong></li>
</ul>
<p>​			特点：</p>
<pre><code>                1. 是Java虚拟机管理内存中的最大一块区域。
                1. 被所有线程共享。
                1. 用来存放用 new 创建过的对象
</code></pre>
<p>​			堆内存的分类</p>
<p><img src="/images/javaHeap.png" alt="java heap"></p>
<ul>
<li><strong>方法区</strong></li>
</ul>
<p>​			特点：</p>
<ol>
<li>被所有线程共享</li>
<li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。</li>
<li>包含了常量池</li>
</ol>
<blockquote>
<p>常量池：</p>
<ol>
<li>常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</li>
</ol>
</blockquote>
<h3 id="2-包"><a href="#2-包" class="headerlink" title="2. 包"></a>2. 包</h3><h4 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1.命名规则"></a>1.命名规则</h4><ul>
<li>统一使用小写</li>
<li>单数形式</li>
<li>使用  <strong>.</strong> 分隔开</li>
<li>一般是网站的反写形式</li>
</ul>
<h4 id="包的权限"><a href="#包的权限" class="headerlink" title="包的权限"></a>包的权限</h4><pre><code>        * public 共有
        * protected 
</code></pre>
<h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h3><h4 id="1-多态的转型"><a href="#1-多态的转型" class="headerlink" title="1.多态的转型"></a>1.多态的转型</h4><ul>
<li>向上转型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 引用名 = new 子类类型();</span><br><span class="line">//右侧创建一个子类对象，把它当作父类看待使用</span><br></pre></td></tr></table></figure>

<ul>
<li>向下转型</li>
</ul>
<ol>
<li><strong>只能强制转换父类的引用，不能强制转换父类的对象</strong></li>
<li><strong>要求父类的引用必须指向的是当前目标类型的对象</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 引用名 = (子类类型) 父类引用;</span><br><span class="line">//用强制类型转换的格式，将父类引用类型转为子类引用类型</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>转型异常</strong></li>
</ul>
<p>​				可以利用操作符<strong>instanceof</strong>判断是否类型一致或为子类型（返回boolean类型）</p>
<h4 id="2-动态绑定"><a href="#2-动态绑定" class="headerlink" title="2. 动态绑定"></a>2. 动态绑定</h4><ul>
<li>​		当调用<strong>对象方法</strong>的时候，该方法会和该对象的<strong>运行类型</strong>绑定</li>
<li>​        当调用<strong>对象属性</strong>时，<strong>没有动态绑定</strong>机制，即哪里声明，哪里使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示动态绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();  </span><br><span class="line"></span><br><span class="line">    p1.mission();</span><br><span class="line">        <span class="comment">//结果 : 学生要好好学习！</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mission</span><span class="params">()</span> &#123;	</span><br><span class="line">    System.out.println(<span class="string">&quot;人要好好活着！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mission</span><span class="params">()</span> &#123;	</span><br><span class="line">    System.out.println(<span class="string">&quot;学生要好好学习！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-多态参数"><a href="#3-多态参数" class="headerlink" title="3. 多态参数"></a>3. 多态参数</h4><p><strong>多态参数</strong>：方法定义的<strong>形参类型</strong>为<strong>父类</strong>类型，<strong>实参类型</strong>允许为<strong>子类</strong>类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> polyparameter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示多态参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyParameter</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小蓝同学&quot;</span>);</span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;小绿老师&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需先 new 一个当前类的实例化，才能调用 test 方法</span></span><br><span class="line">    <span class="type">PolyParameter</span> <span class="variable">polyParameter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PolyParameter</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实参是子类</span></span><br><span class="line">    polyParameter.test(s1);<span class="comment">//输出 s1.study()</span></span><br><span class="line">        polyParameter.test(t1);  <span class="comment">//输出 t1.teach()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义方法test，形参为 Person 类型(形参是父类)</span></span><br><span class="line">  <span class="comment">//功能：调用学生的study或教师的teach方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Person p)</span> &#123;				<span class="comment">// 参数为父类</span></span><br><span class="line">        <span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            ((Student) p).study();   <span class="comment">//向下转型</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> Teacher)&#123;</span><br><span class="line">            ((Teacher) p).teach();  <span class="comment">//向下转型</span></span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//有参构造</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// getter 和 setter</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// study() 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;	</span><br><span class="line">    System.out.println(<span class="built_in">super</span>.getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;正在好好学习&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// teach() 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;	</span><br><span class="line">    System.out.println(<span class="built_in">super</span>.getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;正在好好教书&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="Java集成体系框架"><a href="#Java集成体系框架" class="headerlink" title="Java集成体系框架"></a>Java集成体系框架</h2><h3 id="整体框架："><a href="#整体框架：" class="headerlink" title="整体框架："></a>整体框架：</h3><p><img src="/images/JavaIntegrationFrame.png"></p>
<p>​			Java集合类主要由两个根接口Collection和Map派生出来。</p>
<h3 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h3><p><img src="/images/JavaIntegrationFrameCollection.png"></p>
<ul>
<li><strong>ArrayLIst</strong></li>
</ul>
<p>​		1.增删查改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; arrl =new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//增</span><br><span class="line">arr1.add( E e );</span><br><span class="line">//删</span><br><span class="line">remove(Object o) //从该集合中删除指定元素的单个实例</span><br><span class="line">clear()     //从此集合中删除所有元素</span><br><span class="line">//查</span><br><span class="line">arr1.getI(int index);    //获取第 i 个数，从零开始</span><br><span class="line">//改</span><br><span class="line">set(int index, E element)  //用指定的元素替换此列表中指定位置的元素。</span><br></pre></td></tr></table></figure>

<pre><code>    2. 迭代器
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1.iterator()     //返回一个集合的迭代器</span><br><span class="line">arr1.toArray()      //转数组</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>常见方法</li>
</ol>
<h3 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h3><p><img src="/images/JavaIntegrationFrameMap.png"></p>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类-abstract-class"><a href="#抽象类-abstract-class" class="headerlink" title="抽象类(abstract class )"></a>抽象类(abstract class )</h3><h3 id="接口。"><a href="#接口。" class="headerlink" title="接口。"></a>接口。</h3><pre><code>        Java不允许多重继承，但是接口可以实现多重继承，即一个类可以实现多个接口。
</code></pre>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ul>
<li>定义：JDBC（Java DataBase Connectivity：java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。</li>
</ul>
<h3 id="简单使用过程"><a href="#简单使用过程" class="headerlink" title="简单使用过程"></a>简单使用过程</h3><ol>
<li>导入jar包</li>
</ol>
<p>​		<strong>注意：使用与MySQL版本适配的jar包，使用与操作系统一致的jar包</strong></p>
<p>案例程序（链接云数据库）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;<span class="comment">//按照自己class名设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://142.171.33.151:3306/mydata&quot;</span>;<span class="comment">//注意格式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;connecting&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql;</span><br><span class="line">            sql = <span class="string">&quot;SELECT * FROM emp&quot;</span>;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环输出每一条数据</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;<span class="comment">//按照自己录入数据输出</span></span><br><span class="line">                System.out.println(</span><br><span class="line">                        rs.getInt(<span class="string">&quot;id&quot;</span>) +<span class="string">&quot;\t&quot;</span>+</span><br><span class="line">                                rs.getString(<span class="string">&quot;name&quot;</span>)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="literal">null</span>) stmt.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">            &#125;<span class="comment">// 什么都不做</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="literal">null</span>) conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goodbye!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-随手记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/09/%E9%9A%8F%E6%89%8B%E8%AE%B0/"
    >随手记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/09/%E9%9A%8F%E6%89%8B%E8%AE%B0/" class="article-date">
  <time datetime="2023-10-09T15:33:03.000Z" itemprop="datePublished">2023-10-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="困饿累睡不着"><a href="#困饿累睡不着" class="headerlink" title="困饿累睡不着"></a>困饿累睡不着</h1><p><img src="/images/myPoems_1.jpg"></p>
<p>​	上课的时候随便乱写的&lt;3,没想到我还是这么中二</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/" rel="tag">随手记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-python画画"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/06/python%E7%94%BB%E7%94%BB/"
    >python画画</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/06/python%E7%94%BB%E7%94%BB/" class="article-date">
  <time datetime="2023-10-06T06:55:02.000Z" itemprop="datePublished">2023-10-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>​		学校在国庆节和中秋节中举办了一个编程比赛：内容是在一个小时内用编程语言画出节日符号；例如月饼和国旗之类的。假期闲来无事，于是就浅浅参加了一下。</p>
<h2 id="使用python的TURTLE库"><a href="#使用python的TURTLE库" class="headerlink" title="使用python的TURTLE库"></a>使用python的TURTLE库</h2><p>​		说要用编程画画，我立马就想到了用python ，毕竟人生苦短，我用python。其实主要还是不想用字符串来在终端输出，过于麻烦。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识<img src="https://files.realpython.com/media/Turtle_EDIT_Graph.790c213ce0ba.jpg" alt="Python Turtle Coordinates New"></h2><pre><code>        * 中心点在screen中心
        * (0,0) 即 Home
        * 默认初始化画笔向右
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.right(<span class="number">90</span>)   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.left(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.backward(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://files.realpython.com/media/Update_-_Moving_Turtle_VIDEO_GIF.61623cf40fed.gif" alt="Python Turtle Moving Updated"></p>
<h3 id="内置图形"><a href="#内置图形" class="headerlink" title="内置图形"></a>内置图形</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.circle(<span class="number">60</span>)</span><br><span class="line">t.dot(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">turtle.bgcolor(<span class="string">&quot;blue&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="画笔的粗细"><a href="#画笔的粗细" class="headerlink" title="画笔的粗细"></a>画笔的粗细</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.pensize(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.forward(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="填充颜色"><a href="#填充颜色" class="headerlink" title="填充颜色"></a>填充颜色</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.begin_fill()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fd(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.lt(<span class="number">120</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fd(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.lt(<span class="number">120</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fd(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.end_fill()</span><br></pre></td></tr></table></figure>

<p><img src="https://files.realpython.com/media/Turtle_Begin_End_Fill_GIF.849f73374a22.gif" alt="Python Turtle Begin Fill End Fill New"></p>
<h3 id="绘制速度"><a href="#绘制速度" class="headerlink" title="绘制速度"></a>绘制速度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.speed(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.speed(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.forward(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="撤回"><a href="#撤回" class="headerlink" title="撤回"></a>撤回</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t.undo()</span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = t.clone()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.color(<span class="string">&quot;magenta&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.color(<span class="string">&quot;red&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.circle(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.circle(<span class="number">60</span>)</span><br></pre></td></tr></table></figure>

<h2 id="以上就是python-Turtle模组的基本语法"><a href="#以上就是python-Turtle模组的基本语法" class="headerlink" title="以上就是python Turtle模组的基本语法"></a>以上就是python Turtle模组的基本语法</h2><p>​	但是光会这些基本知识也不行，你还得有亿点点艺术细胞。毕竟它作为画画工具有一点简朴了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/turtle/" rel="tag">turtle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-python脚本制作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/04/python%E8%84%9A%E6%9C%AC%E5%88%B6%E4%BD%9C/"
    >python脚本制作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/04/python%E8%84%9A%E6%9C%AC%E5%88%B6%E4%BD%9C/" class="article-date">
  <time datetime="2023-10-04T05:25:57.000Z" itemprop="datePublished">2023-10-04</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​	我突然打算不用知识点记录的方式记录我的学习笔记，打算以发现问题解决问题的方法记录学习过程。</p>
<h1 id="1-记录的第一个脚本。"><a href="#1-记录的第一个脚本。" class="headerlink" title="1.记录的第一个脚本。"></a>1.记录的第一个脚本。</h1><h2 id="1-问题导入"><a href="#1-问题导入" class="headerlink" title="1.问题导入"></a>1.问题导入</h2><p>​	过去我常常把我拍的照片导入桌面，p完图之后再粘贴到我的移动硬盘留底，过程虽然不长，但是我就是懒。</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>​	我的桌面一般没有东西，所以我可以直接将整个桌面文件夹复制到我的目标目录，或者在匹配后缀位jpg或者png的文件转移到目标文件夹。</p>
<p><img src="/images/desktop.png" alt="desktop"></p>
<h2 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3.实现过程"></a>3.实现过程</h2><pre><code>1. 转移工作目录到桌面
1. 在目标文件夹创建文件夹
1. 复制文件到该文件夹
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">fileName=<span class="string">&quot;null&quot;</span></span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">&#x27;C:/Users/Regen/Desktop&#x27;</span>)<span class="comment">#转到desktop</span></span><br><span class="line"></span><br><span class="line">desktopPath=os.getcwd()<span class="comment">#记录桌面路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fileName=datetime.datetime.now().strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)<span class="comment">#以当前时间为文件夹名字</span></span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">&#x27;E:/代存外部硬盘&#x27;</span>)</span><br><span class="line">os.mkdir(fileName)<span class="comment">#创建文件夹</span></span><br><span class="line"></span><br><span class="line">fileDir=os.getcwd()</span><br><span class="line">fileDir=fileDir+<span class="string">&quot;\\&quot;</span>+fileName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src = desktopPath</span><br><span class="line">des = fileDir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(src):</span><br><span class="line">    <span class="comment">#遍历原文件夹中的文件</span></span><br><span class="line">    full_file_name = os.path.join(src, file)<span class="comment">#把文件的完整路径得到</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;要被复制的全文件路径全名:&quot;</span>,full_file_name)</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(full_file_name):<span class="comment">#用于判断某一对象(需提供绝对路径)是否为文件</span></span><br><span class="line">        shutil.copy(full_file_name, des)<span class="comment">#shutil.copy函数放入原文件的路径文件全名  然后放入目标文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-遇到的问题"><a href="#4-遇到的问题" class="headerlink" title="4.遇到的问题"></a>4.遇到的问题</h2><pre><code>1. 一开始想要直接复制整个文件夹，但是会遇到权限问题，windows的权限问题没有Linux好解决，进而转向遍历文件夹
1. 发现其实可以用windows自带的脚本语言，CMD实现（相当于Linux的shell脚本）
</code></pre>
<h2 id="5-收尾"><a href="#5-收尾" class="headerlink" title="5.收尾"></a>5.收尾</h2><p>​	很简单的脚本还写了两个小时。不过过程中又学会了一点东西。可以，好玩！</p>
<p>​	<img src="/images/wenjianzhuanyi.PNG" alt="result"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-C语言二级指针"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/01/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/"
    >C语言二级指针</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/01/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/" class="article-date">
  <time datetime="2023-10-01T15:55:07.000Z" itemprop="datePublished">2023-10-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="C语言的二级指针"><a href="#C语言的二级指针" class="headerlink" title="C语言的二级指针"></a>C语言的二级指针</h1><h2 id="1-起因。"><a href="#1-起因。" class="headerlink" title="1.起因。"></a>1.起因。</h2><p>​	想记录一下这个我难受的知识点。</p>
<p>​	事情的起因：在自己用C实现简单的数据结构 “ 栈 ”的时候，写了这样一段代码。在后面遍历的时候不论怎么修改都会出现<strong>segmentation fault。</strong> 后来通过debug才发现S的地址从来都没有发生变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(<span class="type">int</span> dataToStore,myStack S)</span>&#123;</span><br><span class="line">    ptrToNode tmp=(myStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MyStack));</span><br><span class="line">    S-&gt;nextNode=tmp;</span><br><span class="line">    tmp-&gt;lastNode=S;</span><br><span class="line">    tmp-&gt;data=dataToStore;</span><br><span class="line">    tmp-&gt;nextNode=<span class="literal">NULL</span>;</span><br><span class="line">    S= tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	以上代码错误的原因是：<strong>S作为一个指针参数被传入函数</strong> 虽然函数的末尾覆盖了S的地址，<strong>但这只是在这个函数开辟的栈空间里，结束后S的地址并不会变化</strong></p>
<h2 id="2-解决。"><a href="#2-解决。" class="headerlink" title="2.解决。"></a>2.解决。</h2><h3 id="1-方法一："><a href="#1-方法一：" class="headerlink" title="1.方法一："></a>1.方法一：</h3><p>​			在主函数覆盖S的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myStack <span class="title function_">pushStack</span><span class="params">(<span class="type">int</span> dataToStore,myStack S)</span>&#123;</span><br><span class="line">    ptrToNode tmp=(myStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MyStack));</span><br><span class="line">    S-&gt;nextNode=tmp;</span><br><span class="line">    tmp-&gt;lastNode=S;</span><br><span class="line">    tmp-&gt;data=dataToStore;</span><br><span class="line">    tmp-&gt;nextNode=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-方法二："><a href="#2-方法二：" class="headerlink" title="2.方法二："></a>2.方法二：</h3><p>​			传入二级指针，即可修改二级指针的值（一级指针的地址）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(<span class="type">int</span> dataToStore,myStack *S)</span>&#123;</span><br><span class="line">    ptrToNode tmp=(myStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MyStack));</span><br><span class="line">    *S-&gt;nextNode=tmp;</span><br><span class="line">    tmp-&gt;lastNode=*S;</span><br><span class="line">    tmp-&gt;data=dataToStore;</span><br><span class="line">    tmp-&gt;nextNode=<span class="literal">NULL</span>;</span><br><span class="line">    *S= tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-收尾。"><a href="#3-收尾。" class="headerlink" title="3.收尾。"></a>3.收尾。</h2><p>​		简单的实现栈这个数据结构其实不一定需要用到二级指针，只是我把问题复杂化了。带来了意向不到的难题。不过至少让我将二级指针收入囊中。不得不感叹一下任重道远啊。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-《再穷也要去旅游》"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/21/%E3%80%8A%E5%86%8D%E7%A9%B7%E4%B9%9F%E8%A6%81%E5%8E%BB%E6%97%85%E6%B8%B8%E3%80%8B/"
    >《再穷也要去旅游》</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/21/%E3%80%8A%E5%86%8D%E7%A9%B7%E4%B9%9F%E8%A6%81%E5%8E%BB%E6%97%85%E6%B8%B8%E3%80%8B/" class="article-date">
  <time datetime="2023-09-21T15:29:32.000Z" itemprop="datePublished">2023-09-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="《再穷也要去旅游》"><a href="#《再穷也要去旅游》" class="headerlink" title="《再穷也要去旅游》"></a>《再穷也要去旅游》</h1><p>​	我今天才开始接触这本书，初见时就是惊鸿一瞥，可能是比较贴切当代像我一样穷大学生的现状吧 &lt;3。</p>
<p>​	唉，我好像老是嘴上说着要去哪里哪里走一走，但是到头来总是会出现各种各样的阻挠。就像今年夏天，驾照啦，作业啦之类的。但是仔细想想，好像这只是给自己家里蹲找的借口而已。于是不了终了，开学时只得借大隐隐于市聊以自慰。</p>
<p>​	不行啊！这个寒假可不能在颓废了！你不是会骑摩托了吗？！这个寒假就加满油去野营吧！看看能否找到冬季银河的踪迹。（回家之前）</p>
<p>​	nmmd，这么冷，不是下雨就是下雪，这个世界又多了一个伤心的人。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/" rel="tag">随手记</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> Regen
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/touxiang.png" alt="Regen"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E7%AC%94%E8%AE%B0">笔记</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E8%AF%BB%E4%B9%A6">读书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0">随手记</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/regenalipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/regenwechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=536623501&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>