<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Regen&#39;s first page</title>
    <url>/2023/09/12/Regen-s-first-page/</url>
    <content><![CDATA[<h1 id="HOLA"><a href="#HOLA" class="headerlink" title="HOLA!!!!"></a>HOLA!!!!</h1><h1 id="INTRODUCTION-TOTHISBLOG"><a href="#INTRODUCTION-TOTHISBLOG" class="headerlink" title="INTRODUCTION 	TO	THIS	BLOG !!!!!!"></a>INTRODUCTION 	TO	THIS	BLOG !!!!!!</h1><p>​	<strong>这个博客目前是由国内代码平台 Gitee 托管。Gitee（码云）相当于中国国内的github,所以在这里托管可以不用挂代理。访问速度也是比较快的</strong>。</p>
<p>​	<strong>这个博客是基于开源框架HEXO,全站都是静态的，也许后续会更换框架试试WordPress等开源框架，不过需要购买云服务器了，这都是后话。</strong></p>
<p>​		查看链接：<a href="(https://github.com/hexojs/hexo)">HEXO</a></p>
<p>​	<strong>同时这个博客的主题也是开源的。名字是ayer。可以在github上面搜到。</strong></p>
<p>​		查看链接：<a href="(https://github.com/Shen-Yu/hexo-theme-ayer)">AYER</a></p>
<p>​	<strong>本网站所有的笔记（MarkDowm格式）都同步更新到了github</strong></p>
<p>​		查看链接：<a href="https://github.com/regenm/Notes">regenm&#x2F;Notes</a></p>
<p>​	感谢开源大佬们的贡献，让我这样的小白也可以有自己的博客，同时也希望自己在不久的将来也能在开源社区做出一点贡献。</p>
<h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><h2 id="Blog-转到了github"><a href="#Blog-转到了github" class="headerlink" title="Blog 转到了github !"></a><strong>Blog 转到了github !</strong></h2><ul>
<li><p>原因</p>
<p> 由于最近gitee的gitee pages服务不太稳定，可能是不让用了？因此转到了github，发现速度不必gitee慢！打算以后长期使用github了！</p>
<p> <img src="/images/gitee_issue_pages.png" alt="gitee issues pages can not update"></p>
</li>
</ul>
<p><a href="https://github.com/regenm/regenm.github.io">new Blog repo</a></p>
<h1 id="Important-Update"><a href="#Important-Update" class="headerlink" title="Important Update"></a>Important Update</h1><p>更新Theme！</p>
<p>这是以前的博客样式：</p>
<p><img src="/../images/oldBlog/1.png" alt="1"></p>
<p><img src="/../images/oldBlog/2.png" alt="2"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>about</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MD语法尝试插入图片到博客</title>
    <url>/2023/09/16/MD%E8%AF%AD%E6%B3%95%E5%B0%9D%E8%AF%95%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%88%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="1-COVER1"><a href="#1-COVER1" class="headerlink" title="1.COVER1"></a>1.COVER1</h1><h1 id=""><a href="#" class="headerlink" title=""></a><img src="/images/cover1.jpg"></h1><h1 id="2-COVER2"><a href="#2-COVER2" class="headerlink" title="2.COVER2"></a>2.COVER2</h1><p><img src="/images/cover2.jpg"></p>
<h1 id="3-COVER3"><a href="#3-COVER3" class="headerlink" title="3.COVER3"></a>3.COVER3</h1><p><img src="/images/cover1.jpg">	</p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>MD语法学习笔记</title>
    <url>/2023/09/16/MD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MD语法学习笔记"><a href="#MD语法学习笔记" class="headerlink" title="MD语法学习笔记"></a>MD语法学习笔记</h1><h2 id="1-基本符号："><a href="#1-基本符号：" class="headerlink" title="1.基本符号："></a>1.基本符号：</h2><p>​	md文档中基本标记都是基于 * - +. &gt; 这几个符号的组合操作</p>
<h2 id="2-标题。"><a href="#2-标题。" class="headerlink" title="2.标题。"></a>2.标题。</h2><p>​	MD总共有六级标题</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 标题1 # </span></span><br><span class="line"><span class="section">## 标题2 ##</span></span><br><span class="line"><span class="section">### 标题3 ###</span></span><br><span class="line"><span class="section">#### 标题4 ####</span></span><br><span class="line"><span class="section">##### 标题5 #####</span></span><br><span class="line"><span class="section">###### 标题6 #######</span></span><br></pre></td></tr></table></figure>

<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><h2 id="3-列表。"><a href="#3-列表。" class="headerlink" title="3.列表。"></a>3.列表。</h2><ul>
<li>无序列表</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span> a</span><br><span class="line"><span class="bullet">+</span> b</span><br><span class="line"><span class="bullet">+</span> c</span><br><span class="line"> </span><br><span class="line"><span class="bullet">-</span> d</span><br><span class="line"><span class="bullet">-</span> e</span><br><span class="line"><span class="bullet">-</span> f</span><br><span class="line"> </span><br><span class="line"><span class="bullet">*</span> g</span><br><span class="line"><span class="bullet">*</span> h</span><br><span class="line"><span class="bullet">*</span> i</span><br></pre></td></tr></table></figure>

<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
<ul>
<li>d</li>
<li>e</li>
<li>f</li>
</ul>
<ul>
<li>g</li>
<li>h</li>
<li>i</li>
</ul>
<ul>
<li>有序列表</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">有序列表</span><br><span class="line"><span class="bullet">1.</span> abc</span><br><span class="line"><span class="bullet">2.</span> abc</span><br><span class="line"><span class="bullet">3.</span> dada</span><br><span class="line"> </span><br><span class="line">错序列表</span><br><span class="line"><span class="bullet">2.</span> awfa</span><br><span class="line"><span class="bullet">5.</span> awef</span><br><span class="line"><span class="bullet">25.</span> dfaf</span><br></pre></td></tr></table></figure>



<p>有序列表</p>
<ol>
<li>abc</li>
<li>abc</li>
<li>dada</li>
</ol>
<p>错序列表<br>2. awfa<br>5. awef<br>25. dfaf</p>
<ul>
<li>嵌套列表</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">无序</span><br><span class="line"><span class="bullet">+</span> a</span><br><span class="line"><span class="bullet">  +</span> a1</span><br><span class="line"><span class="bullet">  +</span> a2</span><br><span class="line"><span class="bullet">+</span> ba</span><br><span class="line"><span class="bullet">+</span> c</span><br><span class="line"> </span><br><span class="line">有序</span><br><span class="line"><span class="bullet">1.</span> a</span><br><span class="line"><span class="bullet">   1.</span> adac</span><br><span class="line"><span class="bullet">      1.</span> adaw</span><br><span class="line"><span class="bullet">   2.</span> adfsda</span><br><span class="line"><span class="bullet">2.</span> ad</span><br><span class="line"><span class="bullet">3.</span> sad</span><br></pre></td></tr></table></figure>

<p>无序</p>
<ul>
<li>a<ul>
<li>a1</li>
<li>a2</li>
</ul>
</li>
<li>ba</li>
<li>c</li>
</ul>
<p>有序</p>
<ol>
<li>a<ol>
<li>adac<ol>
<li>adaw</li>
</ol>
</li>
<li>adfsda</li>
</ol>
</li>
<li>ad</li>
<li>sad</li>
</ol>
<h2 id="4-引用块。"><a href="#4-引用块。" class="headerlink" title="4.引用块。"></a>4.引用块。</h2><ul>
<li>引用</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">引用</span><br><span class="line"><span class="quote">&gt; 引用1</span></span><br><span class="line">引用1 引用1</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>引用</p>
<blockquote>
<p>引用1<br>引用1 引用1</p>
</blockquote>
<ul>
<li>嵌套引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 嵌套引用</span><br><span class="line">&gt; 嵌套引用1 </span><br><span class="line">&gt;&gt; 嵌套引用1 </span><br></pre></td></tr></table></figure>

<p> 嵌套引用</p>
<blockquote>
<p>嵌套引用1 </p>
<blockquote>
<p>嵌套引用1 </p>
</blockquote>
</blockquote>
<h2 id="5-代码块。"><a href="#5-代码块。" class="headerlink" title="5.代码块。"></a>5.代码块。</h2><ul>
<li>单行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码块</span><br><span class="line">`</span><br><span class="line">adaawf</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>代码块<br><code>adaawf</code></p>
<ul>
<li>多行代码块</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">adaawfwrfwr</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adaawfwrfwr</span><br></pre></td></tr></table></figure>

<h2 id="6-链接。"><a href="#6-链接。" class="headerlink" title="6.链接。"></a>6.链接。</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">BAIDU</span>](<span class="link">www.baidu.com</span>)</span><br></pre></td></tr></table></figure>

<p><a href="www.baidu.com">BAIDU</a></p>
<h2 id="7-图片。"><a href="#7-图片。" class="headerlink" title="7.图片。"></a>7.图片。</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片</span>](<span class="link">https://note.youdao.com/favicon.ico</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/favicon.ico" alt="图片"></p>
<h2 id="8-分割线。"><a href="#8-分割线。" class="headerlink" title="8.	分割线。"></a>8.	分割线。</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">分割线</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"><span class="section">- - -</span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line"><span class="strong">****</span>*</span><br><span class="line"><span class="bullet">*</span> * *</span><br><span class="line"><span class="strong">____</span></span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<hr>
<hr>
<h2 id="9-表格。"><a href="#9-表格。" class="headerlink" title="9.表格。"></a>9.表格。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表格</span><br><span class="line">|123|234|345|</span><br><span class="line">|:-|:-:|-:|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">//例子二</span><br><span class="line">|123|234|345|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">//例子三</span><br><span class="line">123|234|345</span><br><span class="line">:-|:-:|-:</span><br><span class="line">abc|bcd|cde</span><br><span class="line">abc|bcd|cde</span><br><span class="line">abc|bcd|cde</span><br></pre></td></tr></table></figure>

<p>表格</p>
<table>
<thead>
<tr>
<th align="left">123</th>
<th align="center">234</th>
<th align="right">345</th>
</tr>
</thead>
<tbody><tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">&#x2F;&#x2F;例子二</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">123</td>
<td align="center">234</td>
<td align="right">345</td>
</tr>
<tr>
<td align="left">:—</td>
<td align="center">:—:</td>
<td align="right">—:</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">&#x2F;&#x2F;例子三</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">123</td>
<td align="center">234</td>
<td align="right">345</td>
</tr>
<tr>
<td align="left">:-</td>
<td align="center">:-:</td>
<td align="right">-:</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">bcd</td>
<td align="right">cde</td>
</tr>
</tbody></table>
<h2 id="10-字体。"><a href="#10-字体。" class="headerlink" title="10.字体。"></a>10.字体。</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//斜体</span><br><span class="line"><span class="emphasis">*md*</span></span><br><span class="line"> </span><br><span class="line">//粗体</span><br><span class="line"><span class="strong">**md**</span></span><br><span class="line"> </span><br><span class="line">//斜体</span><br><span class="line"><span class="emphasis">_md_</span></span><br><span class="line"> </span><br><span class="line">//斜体</span><br><span class="line"><span class="strong">__md__</span></span><br><span class="line"> </span><br><span class="line">//转义</span><br><span class="line"> </span><br><span class="line">\+</span><br><span class="line"> </span><br><span class="line">//删除线</span><br><span class="line"> </span><br><span class="line">~~删除~~</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;斜体<br><em>md</em></p>
<p>&#x2F;&#x2F;粗体<br><strong>md</strong></p>
<p>&#x2F;&#x2F;斜体<br><em>md</em></p>
<p>&#x2F;&#x2F;斜体<br><strong>md</strong></p>
<p>&#x2F;&#x2F;转义</p>
<p>+</p>
<p>&#x2F;&#x2F;删除线</p>
<p><del>删除</del></p>
<h2 id="11-表情！-smile"><a href="#11-表情！-smile" class="headerlink" title="11.表情！:smile:"></a>11.表情！:smile:</h2><p>:santa:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">格式</span><br><span class="line">:内容描述:</span><br><span class="line">例如：</span><br><span class="line">:smile:</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 学习笔记</title>
    <url>/2023/09/16/vim-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="VIM普通模式"><a href="#VIM普通模式" class="headerlink" title="* VIM普通模式"></a>* VIM普通模式</h1><p>​	① 移动光标 ② 复制 粘贴 ③ 剪切 粘贴 删除 ④ 撤销与恢复</p>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><p><strong>光标上下左右移动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h       #左移</span><br><span class="line">j      #下移</span><br><span class="line">k      #上移</span><br><span class="line">l      #右移</span><br></pre></td></tr></table></figure>

<p><strong>移动多行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4h       #左移4格</span><br><span class="line">4j      #上移4行</span><br><span class="line">4k      #下移4行</span><br><span class="line">4l      #右移4格</span><br></pre></td></tr></table></figure>

<p><strong>跳转到单词末尾或者开头(下一个空格前)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">w      # word</span><br><span class="line">b      # begining</span><br></pre></td></tr></table></figure>

<p><strong>跳转到文档开始或末尾</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gg        # 跳转到文档开头</span><br><span class="line">G  (shift + g)   # 跳转到文档末尾</span><br></pre></td></tr></table></figure>

<p><strong>上下翻页</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + u  #向上翻页</span><br><span class="line">ctrl + d  #向下翻页</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>快速到最近的某个字母</strong>（区分大小写）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fu      #到最近1的u</span><br><span class="line">fc      #到最近的c</span><br><span class="line">fK      #到最近的K</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>​	<strong>y</strong></p>
<ul>
<li>复制单词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yaw      # y(yank)  aw(a word)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>复制n行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yy      # 复制本行</span><br><span class="line"></span><br><span class="line">nyy      # 复制n行 包括当前行</span><br><span class="line"></span><br><span class="line">y4j      # 向下复制5行 包括当前行</span><br><span class="line">y4k      # 向上复制5行 包括当前行</span><br><span class="line">y4h      # 向左复制4个字符 不包括光标在闪烁那个字符</span><br><span class="line">y4l      # 向右复制4个字符 包括光标在闪烁那个字符</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p>​	<strong>p</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p      # 小写p,复制到光标后的一行</span><br></pre></td></tr></table></figure>

<h2 id="剪切删除"><a href="#剪切删除" class="headerlink" title="剪切删除"></a>剪切删除</h2><ul>
<li><p><strong>d</strong>命令其实可以看成剪切，不复制出来就变成<strong>删除</strong>了。</p>
</li>
<li><p>删除行</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd      # 删除光标所在行</span><br><span class="line">ndd      # 删除n行 包括当前行</span><br><span class="line"></span><br><span class="line">d4j      # 向下删除5行 包括当前行</span><br><span class="line">d4k      # 向上删除5行 包括当前行</span><br><span class="line">d4h      # 向左删除4个字符 不包括光标在闪烁那个字符</span><br><span class="line">d4l      # 向右删除4个字符 包括光标在闪烁那个字符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>删除到本行末尾</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D</span><br></pre></td></tr></table></figure>

<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>​	<strong>c</strong></p>
<ul>
<li>替换单词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">caw     # change a word</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>替换行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cc      # 删除行，并且进入编辑模式</span><br><span class="line">c4j      # 删除下4行+本行，并且进入编辑模式</span><br></pre></td></tr></table></figure>



<p>* </p>
<h2 id="撤销恢复"><a href="#撤销恢复" class="headerlink" title="撤销恢复"></a>撤销恢复</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u       # (undo)</span><br></pre></td></tr></table></figure>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:wq      # 保存并退出</span><br></pre></td></tr></table></figure>

<h1 id="VIM-可视化模式（VISUAL）"><a href="#VIM-可视化模式（VISUAL）" class="headerlink" title="* VIM 可视化模式（VISUAL）"></a>* VIM 可视化模式（VISUAL）</h1><p>​	<strong>v</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v      # 进入可视化模式</span><br></pre></td></tr></table></figure>

<p>​	进入可视化模式后移动光标即可选中该部分内容进行操作，例如：</p>
<ul>
<li>d				# 删除</li>
<li>y		        # 复制 </li>
<li>c                # 替换</li>
</ul>
<h1 id="客制化"><a href="#客制化" class="headerlink" title="客制化"></a>客制化</h1><ul>
<li>NERDtree</li>
</ul>
<blockquote>
<p>文件夹，文件，管理（树形结构）</p>
</blockquote>
<p>​	</p>
<p><strong>vim学习网站</strong></p>
<p>​	<a href="https://vim-adventures.com/">VIM GAME</a></p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>PHOTOGRAPHY!</title>
    <url>/2023/09/20/PHOTOGRAPHY/</url>
    <content><![CDATA[<h1 id="星空拍摄笔记"><a href="#星空拍摄笔记" class="headerlink" title="星空拍摄笔记"></a>星空拍摄笔记</h1><p><strong>一定要带快门线！</strong></p>
<h2 id="参数的选择"><a href="#参数的选择" class="headerlink" title="参数的选择"></a>参数的选择</h2><h3 id="一，焦段："><a href="#一，焦段：" class="headerlink" title="一，焦段："></a>一，焦段：</h3><p>​	一般常见焦段为12-40，使用广角&amp;超广角镜头最佳。</p>
<h3 id="二，光圈："><a href="#二，光圈：" class="headerlink" title="二，光圈："></a>二，光圈：</h3><p>​	直接拉到最大，不过有一些镜头西需要收一收获得更好的成像。</p>
<h3 id="三，对焦："><a href="#三，对焦：" class="headerlink" title="三，对焦："></a>三，对焦：</h3><p>​	手动直接拉到无穷远，但是可能不够准确，可以打开屏幕，放大一颗比较亮的星星进行微调。</p>
<h3 id="四，曝光："><a href="#四，曝光：" class="headerlink" title="四，曝光："></a>四，曝光：</h3><p>​	“500”法则：500除以镜头的焦段（全画幅焦段），得到的数字便是你可以使用的最长快门时间。</p>
<p>​	例如：</p>
<p>200mm（全画幅）：理想快门速度约为2.5秒（500除以200mm）</p>
<p>24mm（全画幅）：理想快门速度约为20秒（500除以24mm）</p>
<p>16mm（全画幅）：理想快门速度约为31秒（500除以16mm）</p>
<p>14mm（全画幅）：理想快门速度约为35秒（500除以14mm）</p>
<h3 id="五，感光度："><a href="#五，感光度：" class="headerlink" title="五，感光度："></a>五，感光度：</h3><p>​	常用2000-6400的感光度拍摄银河（偶尔1600）<br>​	如果是拍摄星轨的话建议直接100，拉长曝光时间。</p>
<h3 id="六，白平衡："><a href="#六，白平衡：" class="headerlink" title="六，白平衡："></a>六，白平衡：</h3><p>（相机内的色温值越低，拍摄的照片色调越冷，颜色越蓝；反之，色调越暖，颜色越黄）</p>
<h1 id="烟花拍摄笔记"><a href="#烟花拍摄笔记" class="headerlink" title="烟花拍摄笔记"></a>烟花拍摄笔记</h1><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><ul>
<li>注意风向，别去下风处</li>
<li>采用长曝光，需要三脚架，快门线</li>
</ul>
<h2 id="2-参数的选择"><a href="#2-参数的选择" class="headerlink" title="2.参数的选择"></a>2.参数的选择</h2><ul>
<li>iso 最低</li>
<li>小光圈 f&#x2F;8 到 f&#x2F;16</li>
</ul>
<blockquote>
<p><em>光圈越大，烟火的线条越粗；光圈越小，烟火的线条越细</em></p>
<p><em>距离施放点越<strong>近</strong>、亮度越<strong>高</strong>→ 使用f&#x2F;13-18的小光圈，减少进光量、并可使烟火线条较细</em></p>
<p><em>距离施放点越<strong>远</strong>、亮度越<strong>低</strong>→ 使用f&#x2F;8-11的大光圈，增加进光量、并可使烟火线条较明显</em></p>
</blockquote>
<blockquote>
<p>快门速度需要根据<strong>拍摄远近</strong>和<strong>光圈大小</strong>来微调，但秒数至少要大于「烟火从升空到完整爆开」的时间，如此才能拍出一个完整的烟火形状；若时间太短，只会拍出部分绽放的烟火；时间太长则可能会过曝。</p>
</blockquote>
<h1 id="2023-8-28"><a href="#2023-8-28" class="headerlink" title="2023.8.28"></a>2023.8.28</h1><img src=" /images/2023828.jpg" width="400" height="400" alt="With Guitar In The Rain">

<p>​	小雨，很喜欢下雨的时候路灯下的氛围感。于是就拿起三脚架背上吉他就出发咯。要是有灯就好了qwq.hexo</p>
<h1 id="2023-10-2"><a href="#2023-10-2" class="headerlink" title="2023.10.2"></a>2023.10.2</h1><p><img src="/images/bookintheleaves.jpg" width="400" height="400" alt="bookInTheLeaves"/><br/></p>
<p>​	这本书的名字是《杀死一只知更鸟》，那天下午阳光正好，所以我就踩着脚踏车愉快地出门了。带着我的小单反，不过过几天我应该就能换新镜头了。希望那时可以拍出更好看的照片。不过同时，还得好好学摄影，毕竟打铁还需自身硬。</p>
<h1 id="2023-10-28"><a href="#2023-10-28" class="headerlink" title="2023.10.28"></a>2023.10.28</h1><p><img src="/images/202310281.jpg" alt="gentle sunlight cheers me up"></p>
<p><img src="/images/202310282.jpg" alt="one building&#39;s glow"></p>
<p>​	阳台外面就是一个小湖，每天都能看到日落。中午时光练练吉他，看看书，简单的快乐。</p>
<h1 id="2023-11-11"><a href="#2023-11-11" class="headerlink" title="2023.11.11"></a>2023.11.11</h1><img src=" /images/202311111.jpg" width="400" height="300" alt="NIKON GUYS">
]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>About me</title>
    <url>/2023/09/20/about-me/</url>
    <content><![CDATA[<h1 id="Regen-m-smile"><a href="#Regen-m-smile" class="headerlink" title="Regen_m	:smile:"></a>Regen_m	:smile:</h1><p>​	这是我的cyber name。这一页就用来介绍介绍我自己吧！</p>
<h1 id="首先，"><a href="#首先，" class="headerlink" title="首先，"></a>首先，</h1><p>​		我是个热血到爆炸的中二傻呗同时也是乐观到极致的麻瓜。兴趣比较广泛，喜欢DIY设计 ,电子设计，手工制作，弹吉他，摄影等等。同时二次元纯度也非常之高。</p>
<h1 id="虽然，"><a href="#虽然，" class="headerlink" title="虽然，"></a>虽然，</h1><p>​		不知道有谁会看到这个网页，但我打算在接下来的大学生活中利用这个博客记录记录自己的学习，生活历程。这个博客既能记录我的学习笔记，还可以分享我的所见所闻，让我的分享欲有地方释放哈哈哈哈。</p>
<h1 id="总之，"><a href="#总之，" class="headerlink" title="总之，"></a>总之，</h1><p>​		自我介绍就到这里啦！晚安。哦对了，这是我的<code>qq 3525936749</code>，邮箱同。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>about</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记</title>
    <url>/2023/09/21/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-两数之和。"><a href="#1-两数之和。" class="headerlink" title="1.两数之和。"></a>1.两数之和。</h1><p>获得技能：哈希表，c++容器MAP。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a;<span class="comment">//提供一对一的hash</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span></span>;<span class="comment">//用来承载结果，初始化一个大小为2，值为-1的容器b</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">count</span>(target-nums[i])&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b[<span class="number">0</span>]=a[target-nums[i]];</span><br><span class="line">                b[<span class="number">1</span>]=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[nums[i]]=i;<span class="comment">//反过来放入map中，用来获取结果下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="2-链表逆转。（非-力扣-）"><a href="#2-链表逆转。（非-力扣-）" class="headerlink" title="2.链表逆转。（非 力扣 ）"></a>2.链表逆转。（非 力扣 ）</h1><h3 id="1-迭代法"><a href="#1-迭代法" class="headerlink" title="1.迭代法"></a>1.迭代法</h3><ul>
<li>需要保存：<ul>
<li>1.当前节点上一节点</li>
<li>2.当前节点下一节点</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">List <span class="title function_">Reverse</span><span class="params">( List L )</span></span><br><span class="line">&#123;    </span><br><span class="line">    List first=<span class="literal">NULL</span>;</span><br><span class="line">    List tmp;</span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)      <span class="comment">//	L为当前节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp=L-&gt;Next;    <span class="comment">//   tmp保存下一节点</span></span><br><span class="line">        L-&gt;Next=first;    <span class="comment">//   修改指向</span></span><br><span class="line">        first=L;      <span class="comment">//	保存当前节点</span></span><br><span class="line">        L=tmp;        <span class="comment">//	转到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;      <span class="comment">//  返回头结点（不是L,L循环结束后为空）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h3><ul>
<li>两次循环即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">translateLinklist</span><span class="params">(Linklist&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stk;<span class="comment">//定义栈</span></span><br><span class="line">  </span><br><span class="line">  Linklist p = L-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (p)  <span class="comment">//依次读取栈的内容，也就是第一步</span></span><br><span class="line">  &#123;</span><br><span class="line">    stk.<span class="built_in">push</span>(p-&gt;data);</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p = L-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (p)   <span class="comment">//依次出栈，更换链表中的数据，也就是第二步</span></span><br><span class="line">  &#123;</span><br><span class="line">    p-&gt;data = stk.<span class="built_in">top</span>();</span><br><span class="line">    stk.<span class="built_in">pop</span>();</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-无重复字符的最长子串。"><a href="#3-无重复字符的最长子串。" class="headerlink" title="3.无重复字符的最长子串。"></a>3.无重复字符的最长子串。</h1><p>获得技能：队列，滑动窗口</p>
<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; lookup; <span class="comment">//队列模板</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> maxStr = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (lookup.<span class="built_in">find</span>(s[i]) != lookup.<span class="built_in">end</span>())&#123;</span><br><span class="line">                lookup.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxStr = <span class="built_in">max</span>(maxStr,i-left+<span class="number">1</span>);</span><br><span class="line">            lookup.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-寻找两个正序数组的中位数。"><a href="#4-寻找两个正序数组的中位数。" class="headerlink" title="4.寻找两个正序数组的中位数。"></a>4.寻找两个正序数组的中位数。</h1><p>​	获得技能：二分查找。</p>
<p>​	</p>
<p>​	由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 <code>k</code> 个数，我们可以每次循环排除掉 <code>k/2</code> 个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">//因为数组是从索引0开始的，因此我们在这里必须+1，即索引(k+1)的数，才是第k个数。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k</span></span><br><span class="line">        <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> start1, <span class="type">int</span> end1, <span class="type">int</span>[] nums2, <span class="type">int</span> start2, <span class="type">int</span> end2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//因为索引和算数不同6-0=6，但是是有7个数的，因为end初始就是数组长度-1构成的。</span></span><br><span class="line">        <span class="comment">//最后len代表当前数组(也可能是经过递归排除后的数组)，符合当前条件的元素的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1</span></span><br><span class="line">        <span class="comment">//就是如果len1长度小于len2，把getKth()中参数互换位置，即原来的len2就变成了len1，即len1，永远比len2小</span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="comment">//如果一个数组中没有了元素，那么即从剩余数组nums2的其实start2开始加k再-1.</span></span><br><span class="line">        <span class="comment">//因为k代表个数，而不是索引，那么从nums2后再找k个数，那个就是start2 + k-1索引处就行了。因为还包含nums2[start2]也是一个数。因为它在上次迭代时并没有被排除</span></span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果k=1，表明最接近中位数了，即两个数组中start索引处，谁的值小，中位数就是谁(start索引之前表示经过迭代已经被排出的不合格的元素，即数组没被抛弃的逻辑上的范围是nums[start]---&gt;nums[end])。</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了防止数组长度小于 k/2,每次比较都会从当前数组所生长度和k/2作比较，取其中的小的(如果取大的，数组就会越界)</span></span><br><span class="line">        <span class="comment">//然后素组如果len1小于k / 2，表示数组经过下一次遍历就会到末尾，然后后面就会在那个剩余的数组中寻找中位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果nums1[i] &gt; nums2[j]，表示nums2数组中包含j索引，之前的元素，逻辑上全部淘汰，即下次从J+1开始。</span></span><br><span class="line">        <span class="comment">//而k则变为k - (j - start2 + 1)，即减去逻辑上排出的元素的个数(要加1，因为索引相减，相对于实际排除的时要少一个的)</span></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><p>​	给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<pre><code>* 中心扩展
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>||len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;<span class="comment">//记录回文子串起始位置</span></span><br><span class="line">        <span class="type">int</span> end=<span class="number">0</span>;<span class="comment">//记录回文子串终止位置</span></span><br><span class="line">        <span class="type">int</span> mlen=<span class="number">0</span>;<span class="comment">//记录最大回文子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len1=<span class="built_in">expendaroundcenter</span>(s,i,i);<span class="comment">//一个元素为中心</span></span><br><span class="line">            <span class="type">int</span> len2=<span class="built_in">expendaroundcenter</span>(s,i,i+<span class="number">1</span>);<span class="comment">//两个元素为中心</span></span><br><span class="line">            mlen=<span class="built_in">max</span>(<span class="built_in">max</span>(len1,len2),mlen);</span><br><span class="line">            <span class="keyword">if</span>(mlen&gt;end-start+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                start=i-(mlen<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+mlen/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,mlen);</span><br><span class="line">        <span class="comment">//该函数的意思是获取从start开始长度为mlen长度的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">expendaroundcenter</span><span class="params">(string s,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//计算以left和right为中心的回文串长度</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> L=left;</span><br><span class="line">        <span class="type">int</span> R=right;</span><br><span class="line">        <span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;s.<span class="built_in">length</span>() &amp;&amp; s[R]==s[L])</span><br><span class="line">        &#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R-L<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<pre><code>* 动态规划
</code></pre>
<p>​		</p>
<p>​			思想：如果S[ i , j ]是回文串，那么S[ i-1 , j -1]也是回文串 ， 假设</p>
<p><img src="/images/leecode4.PNG" alt="formula"></p>
<p>​			需要注意 : <strong>i&gt;j</strong>的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">boolean</span>[][] P = <span class="keyword">new</span> <span class="title class_">boolean</span>[length][length];<span class="comment">//公式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxPal</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt;= length; len++) <span class="comment">//遍历所有的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; length; start++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end &gt;= length) <span class="comment">//下标已经越界，结束本次循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            P[start][end] = (len == <span class="number">1</span> || len == <span class="number">2</span> || P[start + <span class="number">1</span>][end - <span class="number">1</span>]) &amp;&amp; s.charAt(start) == s.charAt(end); <span class="comment">//长度为 1 和 2 的单独判断下</span></span><br><span class="line">            <span class="keyword">if</span> (P[start][end] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                maxPal = s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> maxPal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-约瑟夫环问题"><a href="#6-约瑟夫环问题" class="headerlink" title="6.约瑟夫环问题"></a>6.约瑟夫环问题</h1><ol>
<li>直接用数组实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//用数组实现约瑟夫环问题</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>]=&#123;<span class="number">0</span>&#125;;   <span class="comment">//元素值为0表示未出局 </span></span><br><span class="line"><span class="comment">//i既代表数组的下标，也代表每个人的编号</span></span><br><span class="line"><span class="comment">//k是用来计数的，一旦k的值达到m，代表此人需要出局，并且k需要重新计数，这样才能够找出所有需要出局的人</span></span><br><span class="line"><span class="comment">//数组的0代表未出局的人，数组非0代表出局的人，未出局的人需要报数，出局的人不需要报数 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> N,M;</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>,i=<span class="number">0</span>,k=<span class="number">0</span>;  <span class="comment">//cnt表示目前出局的人数 </span></span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;  <span class="comment">//表示总共有n人，数到数字m时出局 </span></span><br><span class="line">  <span class="keyword">while</span>(cnt!=N) <span class="comment">//因为要求N个人的出局顺序，因此当cnt（用来统计已经出局的人）未达到n时，需要循环不断报数 </span></span><br><span class="line">  &#123;</span><br><span class="line">    i++;   <span class="comment">//i是每个人的编号 </span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;N) i=<span class="number">1</span>;  <span class="comment">//这里需要特别注意：i的值是不断累加的，一旦发现i的值&gt;N，那么i需要重新从第1个人开始</span></span><br><span class="line">                  <span class="comment">//数组要从第一个元素重新开始一个一个往后判断 </span></span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="number">0</span>)   <span class="comment">//只有元素值为0的人 才需要报数，元素值为非0的代表已经出局了，不用报数 </span></span><br><span class="line">    &#123;</span><br><span class="line">      k++;</span><br><span class="line">      <span class="keyword">if</span>(k==M)     <span class="comment">//代表已经某个人已经报了M这个数，需要出局 </span></span><br><span class="line">      &#123;</span><br><span class="line">        a[i]=<span class="number">1</span>;  <span class="comment">//编号为i的这个人出局 </span></span><br><span class="line">        cnt++;   <span class="comment">//出局的人数+1 </span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">//输出出局的人的编号 </span></span><br><span class="line">        k=<span class="number">0</span>;   <span class="comment">//清空k，让下一个人重新从1开始报数   </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>循环链表</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//用链表实现约瑟夫环问题 （循环链表） </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>  //<span class="title">typedef</span>用来重命名<span class="keyword">struct</span> <span class="title">node</span>这种数据类型，将其命名为<span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">ysflb</span><span class="params">(<span class="type">int</span> N,<span class="type">int</span> M)</span>  <span class="comment">//总共有N个人，报到数字为M的人出局 </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化循环链表</span></span><br><span class="line">  Node *head = <span class="literal">NULL</span>,*p=<span class="literal">NULL</span>,*r=<span class="literal">NULL</span>;   <span class="comment">//head为头指针，指向链表的第一个结点，一开始赋值为NULL,代表不指向任何结点 </span></span><br><span class="line">  head = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//让head指向一个实际的空间</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span>==head)  <span class="comment">//内存空间可能会申请失败,大多数情况不会申请失败 </span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Memory Failed!&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  head-&gt;data=<span class="number">1</span>;       <span class="comment">//从1开始编号 </span></span><br><span class="line">  head-&gt;next=<span class="literal">NULL</span>;    <span class="comment">//一开始整个链表只有一个Node(结点)，这个Node有两个域，分别是data和next</span></span><br><span class="line">                      <span class="comment">//data从1开始，next指向NULL，总共需要N个结点，现在创建了一个，还需要N-1个 </span></span><br><span class="line">    p=head;             <span class="comment">//head要保持不能改变，才能够找到链表的起始位置，一开始p也指向第一个结点</span></span><br><span class="line">                      <span class="comment">//p等一下会被使用，用它可以便于创建剩下的N-1个结点 </span></span><br><span class="line">             </span><br><span class="line">  <span class="comment">//尾插法创建链表,已经有一个1号结点了，还需要创建剩下的n-1个结点 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    r=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); </span><br><span class="line">    r-&gt;data=i;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//插入结点 </span></span><br><span class="line">    p-&gt;next=r;</span><br><span class="line">    p=r;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建循环链表</span></span><br><span class="line">  p-&gt;next=head;   <span class="comment">//最后一个结点的next指向头结点</span></span><br><span class="line">  p=head;         <span class="comment">//为后续方便，将p指向头结点</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//约瑟夫环的模拟</span></span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next!= p)  <span class="comment">//如果p的next=p，说明目前只有一个元素 </span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i++)  <span class="comment">//报到数字为M的时候出局 </span></span><br><span class="line">    &#123;</span><br><span class="line">        r=p;   <span class="comment">//保留出局的前一个结点 </span></span><br><span class="line">        p=p-&gt;next; <span class="comment">//p指向的是要出局的这个结点，需要保留前一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    r-&gt;next=p-&gt;next;    <span class="comment">//删除p的目的，此时p指向哪里？  ：  </span></span><br><span class="line">    p=p-&gt;next;  <span class="comment">//更新p重新进行报数 </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;p-&gt;data; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  ysflb(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="7-列车调度问题"><a href="#7-列车调度问题" class="headerlink" title="7.列车调度问题"></a>7.列车调度问题</h1><p>​	建立一个数组，当输入一个列车序号时开辟轨道，再输入一个列车序号，在所有轨道中<strong>查找比列车序号大的列车序号</strong>，替换它，如果没有比它大的，则另开辟一个轨道。用top记录开辟轨道的数量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="type">int</span> i,m,j,top=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">0</span>||a[top<span class="number">-1</span>]&lt;m)&#123;  <span class="comment">//当top==0时，开辟轨道，当输入的列车序号比最上的轨道列车序号还大时，开辟轨道</span></span><br><span class="line">      a[top++]=m;</span><br><span class="line">    &#125;<span class="keyword">else</span>                   <span class="comment">//二分查找</span></span><br><span class="line">    &#123; </span><br><span class="line">      <span class="type">int</span> high=top<span class="number">-1</span>,low=<span class="number">0</span>,mid;</span><br><span class="line">      <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">      &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;m)</span><br><span class="line">        &#123;</span><br><span class="line">          high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="comment">//a[mid]=m;</span></span><br><span class="line">      a[low]=m;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,top);            <span class="comment">//轨道数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Data-Structure-and-Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言二级指针</title>
    <url>/2023/10/01/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="C语言的二级指针"><a href="#C语言的二级指针" class="headerlink" title="C语言的二级指针"></a>C语言的二级指针</h1><h2 id="1-起因。"><a href="#1-起因。" class="headerlink" title="1.起因。"></a>1.起因。</h2><p>​	想记录一下这个我难受的知识点。</p>
<p>​	事情的起因：在自己用C实现简单的数据结构 “ 栈 ”的时候，写了这样一段代码。在后面遍历的时候不论怎么修改都会出现<strong>segmentation fault。</strong> 后来通过debug才发现S的地址从来都没有发生变化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(<span class="type">int</span> dataToStore,myStack S)</span>&#123;</span><br><span class="line">    ptrToNode tmp=(myStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MyStack));</span><br><span class="line">    S-&gt;nextNode=tmp;</span><br><span class="line">    tmp-&gt;lastNode=S;</span><br><span class="line">    tmp-&gt;data=dataToStore;</span><br><span class="line">    tmp-&gt;nextNode=<span class="literal">NULL</span>;</span><br><span class="line">    S= tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	以上代码错误的原因是：<strong>S作为一个指针参数被传入函数</strong> 虽然函数的末尾覆盖了S的地址，<strong>但这只是在这个函数开辟的栈空间里，结束后S的地址并不会变化</strong></p>
<h2 id="2-解决。"><a href="#2-解决。" class="headerlink" title="2.解决。"></a>2.解决。</h2><h3 id="1-方法一："><a href="#1-方法一：" class="headerlink" title="1.方法一："></a>1.方法一：</h3><p>​			在主函数覆盖S的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">myStack <span class="title function_">pushStack</span><span class="params">(<span class="type">int</span> dataToStore,myStack S)</span>&#123;</span><br><span class="line">    ptrToNode tmp=(myStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MyStack));</span><br><span class="line">    S-&gt;nextNode=tmp;</span><br><span class="line">    tmp-&gt;lastNode=S;</span><br><span class="line">    tmp-&gt;data=dataToStore;</span><br><span class="line">    tmp-&gt;nextNode=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-方法二："><a href="#2-方法二：" class="headerlink" title="2.方法二："></a>2.方法二：</h3><p>​			传入二级指针，即可修改二级指针的值（一级指针的地址）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(<span class="type">int</span> dataToStore,myStack *S)</span>&#123;</span><br><span class="line">    ptrToNode tmp=(myStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MyStack));</span><br><span class="line">    *S-&gt;nextNode=tmp;</span><br><span class="line">    tmp-&gt;lastNode=*S;</span><br><span class="line">    tmp-&gt;data=dataToStore;</span><br><span class="line">    tmp-&gt;nextNode=<span class="literal">NULL</span>;</span><br><span class="line">    *S= tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-收尾。"><a href="#3-收尾。" class="headerlink" title="3.收尾。"></a>3.收尾。</h2><p>​		简单的实现栈这个数据结构其实不一定需要用到二级指针，只是我把问题复杂化了。带来了意向不到的难题。不过至少让我将二级指针收入囊中。不得不感叹一下任重道远啊。</p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>python脚本制作</title>
    <url>/2023/10/04/python%E8%84%9A%E6%9C%AC%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p>​	我突然打算不用知识点记录的方式记录我的学习笔记，打算以发现问题解决问题的方法记录学习过程。</p>
<h1 id="1-记录的第一个脚本。"><a href="#1-记录的第一个脚本。" class="headerlink" title="1.记录的第一个脚本。"></a>1.记录的第一个脚本。</h1><h2 id="1-问题导入"><a href="#1-问题导入" class="headerlink" title="1.问题导入"></a>1.问题导入</h2><p>​	过去我常常把我拍的照片导入桌面，p完图之后再粘贴到我的移动硬盘留底，过程虽然不长，但是我就是懒。</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>​	我的桌面一般没有东西，所以我可以直接将整个桌面文件夹复制到我的目标目录，或者在匹配后缀位jpg或者png的文件转移到目标文件夹。</p>
<p><img src="/images/desktop.png" alt="desktop"></p>
<h2 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3.实现过程"></a>3.实现过程</h2><pre><code>1. 转移工作目录到桌面
1. 在目标文件夹创建文件夹
1. 复制文件到该文件夹
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">fileName=<span class="string">&quot;null&quot;</span></span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">&#x27;C:/Users/Regen/Desktop&#x27;</span>)<span class="comment">#转到desktop</span></span><br><span class="line"></span><br><span class="line">desktopPath=os.getcwd()<span class="comment">#记录桌面路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fileName=datetime.datetime.now().strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)<span class="comment">#以当前时间为文件夹名字</span></span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">&#x27;E:/代存外部硬盘&#x27;</span>)</span><br><span class="line">os.mkdir(fileName)<span class="comment">#创建文件夹</span></span><br><span class="line"></span><br><span class="line">fileDir=os.getcwd()</span><br><span class="line">fileDir=fileDir+<span class="string">&quot;\\&quot;</span>+fileName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src = desktopPath</span><br><span class="line">des = fileDir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(src):</span><br><span class="line">    <span class="comment">#遍历原文件夹中的文件</span></span><br><span class="line">    full_file_name = os.path.join(src, file)<span class="comment">#把文件的完整路径得到</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;要被复制的全文件路径全名:&quot;</span>,full_file_name)</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(full_file_name):<span class="comment">#用于判断某一对象(需提供绝对路径)是否为文件</span></span><br><span class="line">        shutil.copy(full_file_name, des)<span class="comment">#shutil.copy函数放入原文件的路径文件全名  然后放入目标文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-遇到的问题"><a href="#4-遇到的问题" class="headerlink" title="4.遇到的问题"></a>4.遇到的问题</h2><pre><code>1. 一开始想要直接复制整个文件夹，但是会遇到权限问题，windows的权限问题没有Linux好解决，进而转向遍历文件夹
1. 发现其实可以用windows自带的脚本语言，CMD实现（相当于Linux的shell脚本）
</code></pre>
<h2 id="5-收尾"><a href="#5-收尾" class="headerlink" title="5.收尾"></a>5.收尾</h2><p>​	很简单的脚本还写了两个小时。不过过程中又学会了一点东西。可以，好玩！</p>
<p>​	<img src="/images/wenjianzhuanyi.PNG" alt="result"></p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python画画</title>
    <url>/2023/10/06/python%E7%94%BB%E7%94%BB/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>​		学校在国庆节和中秋节中举办了一个编程比赛：内容是在一个小时内用编程语言画出节日符号；例如月饼和国旗之类的。假期闲来无事，于是就浅浅参加了一下。</p>
<h2 id="使用python的TURTLE库"><a href="#使用python的TURTLE库" class="headerlink" title="使用python的TURTLE库"></a>使用python的TURTLE库</h2><p>​		说要用编程画画，我立马就想到了用python ，毕竟人生苦短，我用python。其实主要还是不想用字符串来在终端输出，过于麻烦。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识<img src="https://files.realpython.com/media/Turtle_EDIT_Graph.790c213ce0ba.jpg" alt="Python Turtle Coordinates New"></h2><pre><code>        * 中心点在screen中心
        * (0,0) 即 Home
        * 默认初始化画笔向右
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.right(<span class="number">90</span>)   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.left(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.backward(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://files.realpython.com/media/Update_-_Moving_Turtle_VIDEO_GIF.61623cf40fed.gif" alt="Python Turtle Moving Updated"></p>
<h3 id="内置图形"><a href="#内置图形" class="headerlink" title="内置图形"></a>内置图形</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t.circle(<span class="number">60</span>)</span><br><span class="line">t.dot(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">turtle.bgcolor(<span class="string">&quot;blue&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="画笔的粗细"><a href="#画笔的粗细" class="headerlink" title="画笔的粗细"></a>画笔的粗细</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.pensize(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.forward(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="填充颜色"><a href="#填充颜色" class="headerlink" title="填充颜色"></a>填充颜色</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.begin_fill()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fd(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.lt(<span class="number">120</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fd(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.lt(<span class="number">120</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fd(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.end_fill()</span><br></pre></td></tr></table></figure>

<p><img src="https://files.realpython.com/media/Turtle_Begin_End_Fill_GIF.849f73374a22.gif" alt="Python Turtle Begin Fill End Fill New"></p>
<h3 id="绘制速度"><a href="#绘制速度" class="headerlink" title="绘制速度"></a>绘制速度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.speed(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.speed(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.forward(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="撤回"><a href="#撤回" class="headerlink" title="撤回"></a>撤回</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t.undo()</span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = t.clone()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.color(<span class="string">&quot;magenta&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.color(<span class="string">&quot;red&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.circle(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.circle(<span class="number">60</span>)</span><br></pre></td></tr></table></figure>

<h2 id="以上就是python-Turtle模组的基本语法"><a href="#以上就是python-Turtle模组的基本语法" class="headerlink" title="以上就是python Turtle模组的基本语法"></a>以上就是python Turtle模组的基本语法</h2><p>​	但是光会这些基本知识也不行，你还得有亿点点艺术细胞。毕竟它作为画画工具有一点简朴了。</p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习笔记</title>
    <url>/2023/10/16/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JAVA学习笔记"><a href="#JAVA学习笔记" class="headerlink" title="JAVA学习笔记"></a>JAVA学习笔记</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><ul>
<li>初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1=“Java”；// 字符串常量值</span><br><span class="line">String str3=“Java”;  //  字符串常量，并且与str1地址相同</span><br><span class="line">String str2=new String(“Java”);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str1.length()   <span class="comment">//带括号,与数组不同！！！</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串查找</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str1.charAt(0);  // J</span><br><span class="line">str1.charAt(1);  // a</span><br><span class="line">str1.charAt(2);  // v</span><br><span class="line">str1.charAt(4);  // a</span><br><span class="line">str1.charAt(5);  // 报错</span><br></pre></td></tr></table></figure>

<ul>
<li>返回字符出现的第一个位置下标，否则返回-1</li>
</ul>
<p>a. 从字符串的头开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int index = str1.indexOf(&#x27;J&#x27;);</span><br><span class="line">System.out.println(index);//  0</span><br></pre></td></tr></table></figure>

<p>b. 从下表x开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int index1 = str1.indexOf(&#x27;a&#x27;,2);</span><br><span class="line">System.out.println(index1);  //3</span><br></pre></td></tr></table></figure>

<ul>
<li>返回字符串出现的位置下标, 从index 开始向<strong>后</strong>找 , 否则返回-1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;helloxawllxhxawllxh&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">index3</span> <span class="operator">=</span> s2.lastIndexOf(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    System.out.println(index3);<span class="comment">//13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回字符串出现的位置下标, 从index 开始向<strong>前</strong>找 , 否则返回-1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s2 = &quot;helloxawllxhxawllxh&quot;;</span><br><span class="line"> </span><br><span class="line">    int index3 = s2.lastIndexOf(&#x27;xawl&#x27;);</span><br><span class="line">    System.out.println(index3);//12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串的截取</strong></li>
</ul>
<ol>
<li>截取后面的字符串内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = &quot;adsasdasdasdasd&quot;;</span><br><span class="line">    String ret = str.substring(4);// 保留第4个</span><br><span class="line">    System.out.println(ret);//sdasdasdasd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>截取指定部分</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = &quot;adsasdasdasdasd&quot;;</span><br><span class="line">    String ret = str.substring(4,7);//截取[4,7)里面的字符</span><br><span class="line">    System.out.println(ret);//sda</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串的替换</strong></li>
</ul>
<ol>
<li>使用replace或者replaceAll</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;xawlxawlxawlxawl&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;xa&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret1</span> <span class="operator">=</span> str1.replaceAll(<span class="string">&quot;xa&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    System.out.println(ret);<span class="comment">//BwlBwlBwlBwl</span></span><br><span class="line">    System.out.println(ret1);<span class="comment">//BwlBwlBwlBwl</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//xawlxawlxawlxawl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串的拆分</strong></li>
</ul>
<p>​		使用split方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str1 = &quot;Hello this is xawl rjgc professional&quot;;</span><br><span class="line">    String[] ret = str1.split(&quot; &quot;);      //以空格为分隔符，拆分整个字符串为多个字符串</span><br><span class="line">    for (String s : ret) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/******************************************************/</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    String str1 = &quot;Hello this is xawl rjgc professional&quot;;</span><br><span class="line">    String[] ret = str1.split(&quot; &quot;,3);    //以空格为分隔符，拆分3个字符串</span><br><span class="line">    for (String s : ret) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 特殊字符(| + * . ,)作为分割符可能无法正确切分, 需要加上转义.</p>
<ul>
<li><p><strong>字符串的转化</strong></p>
<pre><code>  1. 将别的数据类型转为字符串**valueOf( elementType i)**
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = String.valueOf(1234);</span><br><span class="line">    String str1 = String.valueOf(12.34);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>小写字母转大写字母或者相反 <strong>toUpperCase()</strong>&amp;<strong>toLowerCase()</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">    String str3 = &quot;abcdef阿凡达&quot;;</span><br><span class="line">    String ret = str3.toUpperCase();</span><br><span class="line">    System.out.println(ret);//ABCDEF阿凡达</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h3><ul>
<li><p>初始化</p>
<p>  int [] a;&#x2F;&#x2F;创建一个数组引用<br>  a&#x3D;new int[4];<br>  int [] b&#x3D;{1,2,3,4};</p>
</li>
<li><p>数组的接口</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//数组的长度</span><br><span class="line">int Alength=a.length;</span><br></pre></td></tr></table></figure>

<ul>
<li>Arrays数组工具类</li>
</ul>
<ol>
<li>&#x2F;&#x2F;转化为String</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//转化为String</span><br><span class="line">String str=Arrays.tString(array);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数组拷贝和扩容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] tmp = Arrays.copyOf(array,2*array.length);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Arrays.binarySearch</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查找成功的话会返回数据的位置</span><br><span class="line">int index = Arrays.binarySearch(arr, 55);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Arrays.equals（比较两个数组是否相等）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.equals(int[] a, int [] b);</span><br><span class="line">//当且仅当a.b非空，长度相同，元素相同时返回true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Arrays.fill(填充；一般用于初始化)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.fill(array,val);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Arrays.sort(arr)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr);//默认升序</span><br></pre></td></tr></table></figure>



<h3 id="3-数据类型转换"><a href="#3-数据类型转换" class="headerlink" title="3.数据类型转换"></a>3.数据类型转换</h3><ul>
<li>数据类型的大小关系</li>
</ul>
<p>​																<strong>byte&lt;short&lt;char&lt;int&lt;long&lt;float&lt;double</strong></p>
<ul>
<li><p>强制数据类型的转换，一般来说，大的数据类型不能赋给小的数据类型。因而会有强制数据类型转换</p>
<p><strong>强制数据类型转换可能会导致数据的丢失</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num_1=<span class="number">20</span>;</span><br><span class="line"><span class="type">byte</span> num_2=(<span class="type">byte</span>) a;</span><br><span class="line"><span class="type">int</span> num_3=<span class="number">300</span>;</span><br><span class="line"><span class="type">byte</span> num_4=(<span class="type">byte</span>)num_3;<span class="comment">//数据丢失 num_4值为44</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Java-中super的用法"><a href="#4-Java-中super的用法" class="headerlink" title="4. Java 中super的用法"></a>4. Java 中super的用法</h3><p>​	<strong>当子类的构造方法内第一行没有出现“super()”时，系统会默认给它加上无参数的”super()”方法</strong>。</p>
<p>注意：</p>
<ol>
<li>当子类构造方法的第一行执行super()无参数方法，那么父类中一定要有无参数构造方法。</li>
<li>在一个类中写了有参数的构造方法时，无参数构造方法就会不存在，需要自己补上无参数的构造方法。</li>
</ol>
<ul>
<li>super使用案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">father</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">father</span><span class="params">(<span class="type">int</span> a)</span>&#123;<span class="built_in">this</span>.age=age;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> <span class="keyword">extends</span> <span class="title class_">father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">son</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><h3 id="Java-中-final-的用法"><a href="#Java-中-final-的用法" class="headerlink" title="Java 中   final  的用法"></a>Java 中   final  的用法</h3></li>
</ol>
<ul>
<li><p>解释：<strong>Java中，final 表示最终，也可以称为完结器，表示对象是最终形态的，不可改变的意思。</strong></p>
</li>
<li><p>使用时的注意事项</p>
</li>
</ul>
<blockquote>
<p>1）final 修饰变量，表示变量的值不可改变，此时该变量可被称为常量。</p>
<p>2）final 修饰方法，表示方法不能被子类重写；</p>
<blockquote>
<p>重写：子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写，又称为方法覆盖。</p>
</blockquote>
<p>3）final 用在类的前面表示该类不能有子类，即该类不可以被继承。</p>
</blockquote>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修饰变量</span></span><br><span class="line"><span class="comment">//final 变量经常和 static 关键字一起使用，作为常量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;regen&quot;</span>;</span><br><span class="line">NAME = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;regen&quot;</span>); <span class="comment">//invalid compilation error</span></span><br><span class="line"><span class="comment">//修饰方法</span></span><br><span class="line"><span class="comment">//被修饰的方法禁止被重写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user：&quot;</span>张三<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Reader extends User&#123;</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public final String getName()&#123;</span></span><br><span class="line"><span class="string">        return &quot;</span>李四<span class="string">&quot;; //compilation error: overridden method is final</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//final修饰类</span></span><br><span class="line"><span class="string">//例如 java 中的String类</span></span><br><span class="line"><span class="string">//表示该类 具有完整的功能，不能被继承</span></span><br><span class="line"><span class="string">public final class String</span></span><br><span class="line"><span class="string">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span></span><br><span class="line"><span class="string">    /** The value is used for character storage. */</span></span><br><span class="line"><span class="string">    private final char value[];</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点</li>
</ul>
<ol>
<li><p>final 关键字，提高了性能，JVM 和 Java 应用都会缓存 final 变量。</p>
</li>
<li><p>final 变量，可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</p>
</li>
</ol>
<h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><blockquote>
<p>java bean</p>
<blockquote>
<ul>
<li>提供一个默认的无参构造函数。</li>
<li>需要被序列化并且实现了 Serializable 接口。</li>
<li>可能有一系列可读写属性，并且一般是 private 的。</li>
<li>可能有一系列的 getter 或 setter 方法。</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    privete String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span> &#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> neweAge)</span> &#123;</span><br><span class="line">        age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1.JVM内存结构"></a>1.JVM内存结构</h3><pre><code>        * 对象的存储结构
                对象应该看作一个地址
                对象名指向堆中的首地址（swap 案例）
        基本数据类型比较的是数值，而引用数据类型比较的是内存地址
</code></pre>
<ul>
<li><strong>JVM运行时的数据区</strong></li>
</ul>
<p>​											<strong>堆、栈、方法区、程序计数器</strong></p>
<p><img src="/images/jvmRunZone.png" alt="jvmRunZone"></p>
<ul>
<li><strong>程序计数器</strong></li>
</ul>
<blockquote>
<p><strong>程序技计数器一个线程独享的数据区域，也就是说，每个线程之间的数据相互不干扰，是一个线程内存空间。</strong></p>
</blockquote>
<blockquote>
<p><strong>可以当成字节码的行号指示器</strong></p>
</blockquote>
<ul>
<li><strong>栈</strong></li>
</ul>
<p>​		JVM的栈包括<strong>Java虚拟机栈</strong>和本地方法栈</p>
<ol>
<li>Java虚拟机栈：执行Java方法服务。</li>
<li>本地方法栈： 执行JVM使用到的Native方法服务。</li>
</ol>
<blockquote>
<p>natine 方法是什么？</p>
<p>JDK 中有很多方法是使用 Native 修饰的。Native 方法不是以 Java 语言实现的，而是以本地语言实现的（比如 C 或 C++）</p>
</blockquote>
<ul>
<li><strong>JVM虚拟机栈</strong></li>
</ul>
<ol>
<li>栈是线程私有的，每个线程拥有独立的栈空间</li>
<li>栈的元素为栈帧</li>
</ol>
<ul>
<li><strong>Java堆</strong></li>
</ul>
<p>​			特点：</p>
<pre><code>                1. 是Java虚拟机管理内存中的最大一块区域。
                1. 被所有线程共享。
                1. 用来存放用 new 创建过的对象
</code></pre>
<p>​			堆内存的分类</p>
<p><img src="/images/javaHeap.png" alt="java heap"></p>
<ul>
<li><strong>方法区</strong></li>
</ul>
<p>​			特点：</p>
<ol>
<li>被所有线程共享</li>
<li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。</li>
<li>包含了常量池</li>
</ol>
<blockquote>
<p>常量池：</p>
<ol>
<li>常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</li>
</ol>
</blockquote>
<h3 id="2-包"><a href="#2-包" class="headerlink" title="2. 包"></a>2. 包</h3><h4 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1.命名规则"></a>1.命名规则</h4><ul>
<li>统一使用小写</li>
<li>单数形式</li>
<li>使用  <strong>.</strong> 分隔开</li>
<li>一般是网站的反写形式</li>
</ul>
<h4 id="包的权限"><a href="#包的权限" class="headerlink" title="包的权限"></a>包的权限</h4><pre><code>        * public 共有
        * protected 
</code></pre>
<h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h3><h4 id="1-多态的转型"><a href="#1-多态的转型" class="headerlink" title="1.多态的转型"></a>1.多态的转型</h4><ul>
<li>向上转型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类类型 引用名 = new 子类类型();</span><br><span class="line">//右侧创建一个子类对象，把它当作父类看待使用</span><br></pre></td></tr></table></figure>

<ul>
<li>向下转型</li>
</ul>
<ol>
<li><strong>只能强制转换父类的引用，不能强制转换父类的对象</strong></li>
<li><strong>要求父类的引用必须指向的是当前目标类型的对象</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子类类型 引用名 = (子类类型) 父类引用;</span><br><span class="line">//用强制类型转换的格式，将父类引用类型转为子类引用类型</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>转型异常</strong></li>
</ul>
<p>​				可以利用操作符<strong>instanceof</strong>判断是否类型一致或为子类型（返回boolean类型）</p>
<h4 id="2-动态绑定"><a href="#2-动态绑定" class="headerlink" title="2. 动态绑定"></a>2. 动态绑定</h4><ul>
<li>​		当调用<strong>对象方法</strong>的时候，该方法会和该对象的<strong>运行类型</strong>绑定</li>
<li>​        当调用<strong>对象属性</strong>时，<strong>没有动态绑定</strong>机制，即哪里声明，哪里使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示动态绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();  </span><br><span class="line"></span><br><span class="line">    p1.mission();</span><br><span class="line">        <span class="comment">//结果 : 学生要好好学习！</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mission</span><span class="params">()</span> &#123;	</span><br><span class="line">    System.out.println(<span class="string">&quot;人要好好活着！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mission</span><span class="params">()</span> &#123;	</span><br><span class="line">    System.out.println(<span class="string">&quot;学生要好好学习！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-多态参数"><a href="#3-多态参数" class="headerlink" title="3. 多态参数"></a>3. 多态参数</h4><p><strong>多态参数</strong>：方法定义的<strong>形参类型</strong>为<strong>父类</strong>类型，<strong>实参类型</strong>允许为<strong>子类</strong>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> polyparameter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示多态参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyParameter</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小蓝同学&quot;</span>);</span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;小绿老师&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需先 new 一个当前类的实例化，才能调用 test 方法</span></span><br><span class="line">    <span class="type">PolyParameter</span> <span class="variable">polyParameter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PolyParameter</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实参是子类</span></span><br><span class="line">    polyParameter.test(s1);<span class="comment">//输出 s1.study()</span></span><br><span class="line">        polyParameter.test(t1);  <span class="comment">//输出 t1.teach()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义方法test，形参为 Person 类型(形参是父类)</span></span><br><span class="line">  <span class="comment">//功能：调用学生的study或教师的teach方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Person p)</span> &#123;				<span class="comment">// 参数为父类</span></span><br><span class="line">        <span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            ((Student) p).study();   <span class="comment">//向下转型</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> Teacher)&#123;</span><br><span class="line">            ((Teacher) p).teach();  <span class="comment">//向下转型</span></span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//有参构造</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// getter 和 setter</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// study() 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;	</span><br><span class="line">    System.out.println(<span class="built_in">super</span>.getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;正在好好学习&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// teach() 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;	</span><br><span class="line">    System.out.println(<span class="built_in">super</span>.getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;正在好好教书&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="Java集成体系框架"><a href="#Java集成体系框架" class="headerlink" title="Java集成体系框架"></a>Java集成体系框架</h2><h3 id="整体框架："><a href="#整体框架：" class="headerlink" title="整体框架："></a>整体框架：</h3><p><img src="/images/JavaIntegrationFrame.png"></p>
<p>​			Java集合类主要由两个根接口Collection和Map派生出来。</p>
<h3 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h3><p><img src="/images/JavaIntegrationFrameCollection.png"></p>
<ul>
<li><strong>ArrayLIst</strong></li>
</ul>
<p>​		1.增删查改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; arrl =new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//增</span><br><span class="line">arr1.add( E e );</span><br><span class="line">//删</span><br><span class="line">remove(Object o) //从该集合中删除指定元素的单个实例</span><br><span class="line">clear()     //从此集合中删除所有元素</span><br><span class="line">//查</span><br><span class="line">arr1.getI(int index);    //获取第 i 个数，从零开始</span><br><span class="line">//改</span><br><span class="line">set(int index, E element)  //用指定的元素替换此列表中指定位置的元素。</span><br></pre></td></tr></table></figure>

<pre><code>    2. 迭代器
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr1.iterator()     //返回一个集合的迭代器</span><br><span class="line">arr1.toArray()      //转数组</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>常见方法</li>
</ol>
<h3 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h3><p><img src="/images/JavaIntegrationFrameMap.png"></p>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类-abstract-class"><a href="#抽象类-abstract-class" class="headerlink" title="抽象类(abstract class )"></a>抽象类(abstract class )</h3><h3 id="接口。"><a href="#接口。" class="headerlink" title="接口。"></a>接口。</h3><pre><code>        Java不允许多重继承，但是接口可以实现多重继承，即一个类可以实现多个接口。
</code></pre>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ul>
<li>定义：JDBC（Java DataBase Connectivity：java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。</li>
</ul>
<h3 id="简单使用过程"><a href="#简单使用过程" class="headerlink" title="简单使用过程"></a>简单使用过程</h3><ol>
<li>导入jar包</li>
</ol>
<p>​		<strong>注意：使用与MySQL版本适配的jar包，使用与操作系统一致的jar包</strong></p>
<p>案例程序（链接云数据库）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;<span class="comment">//按照自己class名设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://142.171.33.151:3306/mydata&quot;</span>;<span class="comment">//注意格式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;connecting&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql;</span><br><span class="line">            sql = <span class="string">&quot;SELECT * FROM emp&quot;</span>;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环输出每一条数据</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;<span class="comment">//按照自己录入数据输出</span></span><br><span class="line">                System.out.println(</span><br><span class="line">                        rs.getInt(<span class="string">&quot;id&quot;</span>) +<span class="string">&quot;\t&quot;</span>+</span><br><span class="line">                                rs.getString(<span class="string">&quot;name&quot;</span>)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="literal">null</span>) stmt.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">            &#125;<span class="comment">// 什么都不做</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="literal">null</span>) conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goodbye!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机笔记</title>
    <url>/2023/10/26/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>git test message</p>
<ul>
<li><h1 id="Information-Data-sheet"><a href="#Information-Data-sheet" class="headerlink" title="Information	&amp;  	Data sheet"></a>Information	&amp;  	Data sheet</h1></li>
</ul>
<p>Based on –AT89C51.</p>
<blockquote>
<p>The <strong>Atmel AT89 series</strong> is an <a href="https://en.wikipedia.org/wiki/Intel_8051">Intel 8051</a>-compatible family of 8 bit <a href="https://en.wikipedia.org/wiki/Microcontroller">microcontrollers</a> (μCs) manufactured by the <a href="https://en.wikipedia.org/wiki/Atmel">Atmel Corporation</a>.</p>
<p>Based on the Intel 8051 core, the AT89 series remains very popular as general purpose microcontrollers, due to their industry standard instruction set, their low unit cost, and the availability of these chips in DIL (DIP) packages. This allows a great amount of legacy code to be reused without modification in new applications. While less powerful than the newer AT90 series of <a href="https://en.wikipedia.org/wiki/Atmel_AVR">AVR</a> <a href="https://en.wikipedia.org/wiki/RISC">RISC</a> microcontrollers, new product development has continued with the AT89 series for the aforementioned advantages.</p>
<p>More recently, the AT89 series has been augmented with 8051-cored special function microcontrollers, specifically in the areas of <a href="https://en.wikipedia.org/wiki/Universal_Serial_Bus">USB</a>, <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I²C</a> (two wire interface), <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> and <a href="https://en.wikipedia.org/wiki/Controller_Area_Network">CAN</a> bus controllers, <a href="https://en.wikipedia.org/wiki/MP3">MP3</a> decoders and hardware <a href="https://en.wikipedia.org/wiki/Pulse-width_modulation">PWM</a>.</p>
</blockquote>
<p>Data sheet url links : <a href="https://rocelec.widen.net/view/pdf/gywrtkuql9/ATMLS01727-1.pdf?t.download=true&u=5oefqw">Data Sheet PDF Downloads</a> </p>
<blockquote>
<p><img src="/images/featuresofat89c51.png" alt="features of AT89C51"></p>
</blockquote>
<p>​						<strong>The following I would not like to just write down the points. The post will be focused on application layer</strong></p>
<h1 id="Project-1-1：TIME-BOMB"><a href="#Project-1-1：TIME-BOMB" class="headerlink" title="Project_1_1：TIME BOMB"></a>Project_1_1：<strong>TIME BOMB</strong></h1><p>​	It’s actually very easy to make a TIME BOMB than you can imagine.You will just need some TNT and an at89c51 chip(&lt;3).</p>
<p>Now that we fixed the Bomb (got some TNT). What about the  timer ? Yep, we can use the <strong>AT89C51</strong> chip.</p>
<p><strong>Timer</strong> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delayN10ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> N)</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(N;N&gt;<span class="number">0</span>;N--)</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);         <span class="comment">//different types of chips have different delay functions</span></span><br><span class="line">                   <span class="comment">//and it&#x27;s also related to the crystal oscillator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>what about the next to do after the timer is set? yep , light it.</p>
<p>We can use a switch or a relay to light it . When the switch (connected between vcc and gnd) is on , the heat will light the TNT. EZ game.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delayN10ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> N)</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(N;N&gt;<span class="number">0</span>;N--)</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);         <span class="comment">//different types of chips have different delay functions</span></span><br><span class="line">                   <span class="comment">//and it&#x27;s also related to the crystal oscillator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    delayN10ms(<span class="number">10000</span>);<span class="comment">//10s</span></span><br><span class="line">    P1=<span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/timeBomb.png" alt=" schematic "></p>
<h1 id="project-1-2-CANCEL-the-TIME-BOMB"><a href="#project-1-2-CANCEL-the-TIME-BOMB" class="headerlink" title="project_1_2 : CANCEL the TIME BOMB"></a>project_1_2 : CANCEL the TIME BOMB</h1><p>​	Now that we create a time bomb , we are going to  use it to rob a bank . However your </p>
<p>incompetent teammates set the bomb  early! You guys are to be exposed to TNT in just 10s . What are you going to do ? </p>
<ul>
<li>Yes ,for sure you can reset the chip. </li>
<li>Also we can use a technique called <strong>INTERRUPTION</strong></li>
</ul>
<blockquote>
<p>Now we are  going to talk about <strong>INTERRUPTION</strong></p>
<p>The chip AT89C51 has six interrupt sources .</p>
<p><strong>What is an interrupt ?</strong></p>
<blockquote>
<p>An interrupt is an external or internal event to get the CPU’s attention. Once the controller detects the interrupt, it suspends the current job and executes a special service routine know as Interrupt Service Routine(ISR).</p>
<p>Upon activation of an interrupt, the microcontroller goes through the following steps</p>
<ol>
<li><p>First it finishes the instruction it is executing and saves the address of the next instruction (PC) on the stack.</p>
</li>
<li><p>It also saves the current status of all the interrupts internally.</p>
</li>
<li><p>It jumps to a fixed location in memory, called the interrupt vector table, that holds the address of the ISR. The microcontroller gets the address of the ISR from the interrupt vector table and jumps to it It starts to execute the interrupt service subroutine until it reaches the last instruction of the subroutine which is RETI (return from interrupt)</p>
</li>
<li><p>Upon executing the RETI instruction, the microcontroller returns to the place where it was interrupted.</p>
</li>
<li><p>First, it gets the program counter (PC) address from the stack by popping the top two bytes of the stack into the PC.</p>
</li>
<li><p>Then it starts to execute from that address.</p>
<p><a href="http://exploreembedded.com/wiki/6.8051_Interrupts">information from here</a></p>
</li>
</ol>
</blockquote>
<p><strong>8051 interrupt Structure</strong></p>
<blockquote>
<p>8051 Microcontroller has six interrupt sources as shown in the table below:</p>
<table>
<thead>
<tr>
<th>Interrupt</th>
<th>ROM Location(Hex)</th>
<th>Pin</th>
<th>Flag Clearing</th>
<th>Interrupt no. in C</th>
</tr>
</thead>
<tbody><tr>
<td>Reset</td>
<td>0000</td>
<td>9</td>
<td>Auto</td>
<td>–</td>
</tr>
<tr>
<td>External HW Interrupt 0 (INT0)</td>
<td>0003</td>
<td>P3.2(12)</td>
<td>Auto</td>
<td>0</td>
</tr>
<tr>
<td>Timer 0 Interrupt(TF0)</td>
<td>000B</td>
<td>-</td>
<td>Auto</td>
<td>1</td>
</tr>
<tr>
<td>External HW Interrupt 1 (INT1)</td>
<td>0013</td>
<td>P3.3(13)</td>
<td>Auto</td>
<td>2</td>
</tr>
<tr>
<td>Timer 1 Interrupt(TF1)</td>
<td>001B</td>
<td>-</td>
<td>Auto</td>
<td>3</td>
</tr>
<tr>
<td>Serial Com Interrupt(RI and TI)</td>
<td>0023</td>
<td>-</td>
<td>Program SW</td>
<td>4</td>
</tr>
</tbody></table>
<ul>
<li>the reset vector has just 3 bytes allocated to it, meaning it can hold a jump instruction to the location where the main program is stored.</li>
<li>The other interrupts have 8 bytes allocated to each of them, hence a small Interrupt service routine(ISR) can be placed here. However, if the ISR needs to larger in length, it has to placed else where and the allocated 8 bytes need to have the code that simple redirects the control to the ISR.</li>
<li><em>INT0</em> and <em>INT1</em> are external interrupts on P3.2 and P3.3 respectively. These can be configured to be low level triggered or edge triggered interrupt sources.</li>
<li><em>TF0</em> and <em>TF1</em> are timer overflow interrupts for timer 0 and 1 respectively</li>
<li>The <em>Serial COM Interrupt</em> can be configured to trigger upon transmit or receipt of a byte during serial communication.</li>
</ul>
</blockquote>
<p><strong>enable interruption</strong></p>
<blockquote>
<p><img src="/images/structureof51interruption.jpg" alt="structure of 51 interrupt "></p>
</blockquote>
</blockquote>
<p>**example code using external interrupt **</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    IP = <span class="number">0x04</span>; </span><br><span class="line">   EA=<span class="number">1</span>;</span><br><span class="line">   EX0=<span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">   IT0 = <span class="number">1</span>; <span class="comment">// set edge triggerin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  setUp();</span><br><span class="line">   delayNms(<span class="number">10000</span>);<span class="comment">//10s</span></span><br><span class="line">    P1=<span class="number">0x00</span>;        <span class="comment">//start BOMB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123;</span><br><span class="line"></span><br><span class="line">     P1=<span class="number">0xff</span>;			<span class="comment">//cancel the timer</span></span><br><span class="line">    P2=<span class="number">0x00</span>;       <span class="comment">//to display</span></span><br><span class="line">    delayN10ms(<span class="number">1000</span>);   <span class="comment">// pause 10s for your survive</span></span><br><span class="line">    P2=<span class="number">0xff</span>;       <span class="comment">//to display</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/images/gif.gif" alt="simple example"></p>
</blockquote>
<p>Now you can run away safely ;D.</p>
<p>**The above codes are just some rough examples . **</p>
<h1 id="Project-1-3-the-final-version-of-the-time-bomb"><a href="#Project-1-3-the-final-version-of-the-time-bomb" class="headerlink" title="Project_1_3 : the final version of the time bomb"></a>Project_1_3 : the final version of the time bomb</h1><h2 id="First-we-are-going-to-design-the-schematic-seriously"><a href="#First-we-are-going-to-design-the-schematic-seriously" class="headerlink" title="First , we are going to design the schematic seriously."></a>First , we are going to design the schematic seriously.</h2><p><img src="/images/finalbomb.png" alt="the final schematic"></p>
<h3 id="codes"><a href="#codes" class="headerlink" title="codes:"></a><strong>codes:</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg51.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit button_1=P2^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delayNms</span><span class="params">(<span class="type">int</span> N)</span>    <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);</span><br><span class="line">  N--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bombStart</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//setup</span></span><br><span class="line">   IP = <span class="number">0x04</span>; </span><br><span class="line">    EA=<span class="number">1</span>;</span><br><span class="line">    EX0=<span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">    IT0 = <span class="number">1</span>; <span class="comment">// set edge triggering</span></span><br><span class="line">    P2 =<span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(button_1==<span class="number">0</span>)&#123;</span><br><span class="line">        bombStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bombStart</span><span class="params">()</span>&#123;</span><br><span class="line">  delayNms(<span class="number">10000</span>);</span><br><span class="line">  P1=<span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123; </span><br><span class="line"></span><br><span class="line">   P1=<span class="number">0xff</span>;<span class="comment">//cancel the timer</span></span><br><span class="line">  delayNms(<span class="number">10000</span>); <span class="comment">// increase 10s for your survive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>explanations:</strong></p>
<ol>
<li>Once the bomb is set up , you need to press the start button to start the bomb.</li>
<li>Once you start the bomb , you have 10 s to run away .</li>
<li>If you want to delay the bomb , press the button “PAUSE” .<ul>
<li><strong>ps</strong>: there is no way you can cancel the bomb unless you reset or cut off the power .</li>
</ul>
</li>
</ol>
<p><strong>other information</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IT1 = <span class="number">1</span>; <span class="comment">// Enable external interrupt 1 to trigger by a falling edge signal. </span></span><br><span class="line"></span><br><span class="line">IT1 = <span class="number">0</span>; <span class="comment">// Enable a low level signal on external interrupt 1 to generate an interrupt.</span></span><br><span class="line"></span><br><span class="line">IT0 = <span class="number">1</span>; <span class="comment">// Enable external interrupt 0 to trigger by a falling edge signal.</span></span><br><span class="line"></span><br><span class="line">IT0 = <span class="number">0</span>; <span class="comment">// Enable a low level signal on external interrupt 1 to generate an interrupt.</span></span><br></pre></td></tr></table></figure>

<h1 id="Project-1-4-Use-a-TIMER-interrupt-to-set-the-bomb"><a href="#Project-1-4-Use-a-TIMER-interrupt-to-set-the-bomb" class="headerlink" title="Project_1_4: Use a TIMER interrupt to  set the bomb"></a>Project_1_4: Use a TIMER interrupt to  set the bomb</h1><p>​	To control the timer and specify our needs&#x2F;logic we have to configure the timers first. For configuring and controlling the 89c51 microcontroller timers we have four registers. These registers are associated with timers of 89c51 micro controller. Each register plays an important role in controlling and configuring the timer. </p>
<blockquote>
<p>**Registers that are associated with timers.  **</p>
<p>- </p>
<ul>
<li>(Timer Control register)</li>
<li>TMOD   (Timer Mode register)</li>
<li>TH0&#x2F;TL0 (Timer 0, 16-bit register, High bits goes to TH0, Low bits goes to TL0)</li>
<li>TH1&#x2F;TL1 (Timer 1, 16-bit register, High bits goes to TH1, Low bits goes to TL1)</li>
</ul>
</blockquote>
<p><strong>Formula if TIMER INTERRUPT</strong></p>
<p>TH0&#x2F;TL0(Timer-0) &#x3D; TH1&#x2F;TL1(Timer-1)</p>
<p>These two registers TH and TL are timer high byte and timer low byte registers. 0 and 1 are the timers numbers. These are 16-bit registers. we Load our time delays&#x2F;counter value in these registers. Recall 8051 timer counter can count up to 65535 and 16 bits cover 65535 in binary. Since 8051(89c51,89c52) is an 8-bit microcontroller, so to load 65535 we need two registers one representing the high byte and other the low byte. we access these register in two bytes one byte for TH(timer high byte) and TL(timer low byte). TH and TL together makes 16-bits(TH 8-bit, TL8-bit).  TH0 and TL0 are byte addressable only.</p>
<ul>
<li>how to set them then ? There is an  example .</li>
</ul>
<blockquote>
<p><img src="https://b2600043.smushcdn.com/2600043/wp-content/uploads/2/2/1/5/22159166/1434719730.png?lossy=0&strip=1&webp=1" alt="Calculating Delay for 8051(89c51,89c52) microcontroller"></p>
</blockquote>
<h3 id="TCON-Timer-control-Register-of-8051-Microcontroller"><a href="#TCON-Timer-control-Register-of-8051-Microcontroller" class="headerlink" title="TCON(Timer control) Register of 8051 Microcontroller"></a>TCON(Timer control) Register of 8051 Microcontroller</h3><p>TCON(Timer Control) is an 8-bit register. It’s bits are used for generating interrupts on gpio pins internal or external. The most important bits of the timers TRx and TFx are also in it. TRx(timer run) and TFx(timer overflow) bits which we use in almost all our timer applications are in it. When we initialize TRx with 1, TRx&#x3D;1 it means start the timer, When the specified time is over the timer it self make TFx&#x3D;1 which means that the delay value is reached. Once TFx&#x3D;1 stop the timer by initializing TRx with 0 TRx&#x3D;0(Stop Timer). Now if we again want to run the timer make TRx&#x3D;1. In the diagram you can see the SFR for TCON register, the bit’s used for interrupt handling and the timer run and timer over flow bits. If you want to access the individual bits of the registers, you can access them by their names. You can also access whole register it self by its name. At the bottom of the page their is a small example explaining it. </p>
<h2 id="Now-we-are-going-to-upgrade-our-Bomb"><a href="#Now-we-are-going-to-upgrade-our-Bomb" class="headerlink" title="Now we are going to upgrade our Bomb!"></a>Now we are going to upgrade our Bomb!</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"> </span><br><span class="line">sbit led=P2^<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//配置定时器0工作模式16位计时</span></span><br><span class="line">    <span class="comment">//set T0 working mode with 16 bits</span></span><br><span class="line">  TMOD&amp;=<span class="number">0xF0</span>;</span><br><span class="line">    TMOD|=<span class="number">0x01</span>;</span><br><span class="line">  <span class="comment">//给初值，定制10ms</span></span><br><span class="line">    <span class="comment">//set initial value , create 10 ms delay</span></span><br><span class="line">  TL0=<span class="number">0x00</span>;</span><br><span class="line">  TH0=<span class="number">0xDC</span>;</span><br><span class="line">  </span><br><span class="line">  TR0=<span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">        <span class="comment">// turn on T0</span></span><br><span class="line">  TF0=<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//打开定时器0中断</span></span><br><span class="line">    <span class="comment">//turn on T0 interrupt</span></span><br><span class="line">  ET0=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//打开总中断</span></span><br><span class="line">    <span class="comment">// turn on general interrupt</span></span><br><span class="line">  EA=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  led=<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  Time0Init();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ;<span class="comment">//do noting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0Rountime</span><span class="params">()</span>  interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">      cnt++;						<span class="comment">//cnt++用来记录第一次爆表，cnt是1次</span></span><br><span class="line">            						<span class="comment">// record the interrupt times</span></span><br><span class="line">                    <span class="comment">//重新给初值</span></span><br><span class="line">                        <span class="comment">//reset the initial value</span></span><br><span class="line">      TL0=<span class="number">0x00</span>;</span><br><span class="line">      TH0=<span class="number">0xDC</span>;</span><br><span class="line">      <span class="keyword">if</span>(cnt==<span class="number">1000</span>)				<span class="comment">//爆表100次，经过10s，led就亮</span></span><br><span class="line">                              <span class="comment">// after 100 times which the time passes 1s</span></span><br><span class="line">      &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;					<span class="comment">//当1s时，让count从0开始，计算下一次的1s</span></span><br><span class="line">                            <span class="comment">// set the cnt again</span></span><br><span class="line">        P1=<span class="number">0x00</span>;				<span class="comment">//BOMb!!!</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-What-if-we-get-many-BOMBs-which-they-are-set-at-different-palces"><a href="#1-What-if-we-get-many-BOMBs-which-they-are-set-at-different-palces" class="headerlink" title="1. What if we get many BOMBs which they are set at different palces ?"></a>1. What if we get many BOMBs which they are set at different palces ?</h2><ul>
<li><strong>Explode with a delay ( such as 1 s )</strong></li>
</ul>
<blockquote>
<p>Solution KEY : </p>
<p>​				Once the first BOMB is about to explode , it sends a signal to another BOMB.</p>
<p><strong>the signal :</strong></p>
<ol>
<li>Voltage （like 0 v  —&gt; 1 v  or reverse it ）</li>
<li>Waves of Voltage ( PULSE )</li>
<li>Serial text</li>
</ol>
</blockquote>
<h2 id="1-Voltage"><a href="#1-Voltage" class="headerlink" title="1. Voltage"></a>1. Voltage</h2><p>​	Once the first bomb is about to explode, it sends a Voltage signal to the second and so on.</p>
<p>​	We can use one of a pin to do this work .</p>
<ul>
<li>The first BOMB</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    delayN10ms(<span class="number">10000</span>);   <span class="comment">//10s</span></span><br><span class="line">    P2<span class="number">.1</span>=<span class="number">0</span>;       <span class="comment">// send a signal ( 5v ) </span></span><br><span class="line">    P1=<span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>The second BOMB</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;   </span><br><span class="line">      <span class="keyword">if</span>(P2<span class="number">.1</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            delayN10ms(<span class="number">10000</span>);   <span class="comment">//10s</span></span><br><span class="line">            P2<span class="number">.2</span>=<span class="number">0</span>;       <span class="comment">// send a signal to the third BOMB (send to P2.1) ( 5v ) </span></span><br><span class="line">            P1=<span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Through-Plain-Text（by-serial-）"><a href="#2-Through-Plain-Text（by-serial-）" class="headerlink" title="2. Through Plain Text（by serial ）"></a>2. Through Plain Text（by serial ）</h2><blockquote>
<p>The procedure :</p>
<ol>
<li>Set the first bomb</li>
<li>Connect to the the second Bomb and the third one so on</li>
<li>Start the first Bomb</li>
<li>the second before the first Bomb is about to explode ,it send a message “BOMB”</li>
</ol>
</blockquote>
<p><strong>The schematic</strong></p>
<p><img src="/images/theFinalBomb.png" alt="the final version"></p>
<p><strong>The first BOMB.</strong> 	</p>
<ul>
<li>Transmit  signal ( We only use the send module, so we just need one pin ( <strong>TX</strong> ))</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg51.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;; <span class="comment">//数码管驱动</span></span><br><span class="line"></span><br><span class="line">sbit start = P1^<span class="number">7</span>;</span><br><span class="line">sbit bomb  = P1^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> timeS=<span class="number">9</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delayNms</span><span class="params">(<span class="type">int</span> N)</span>    <span class="comment">// @11.0592MHz   延时函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);</span><br><span class="line">                N--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">serialInit</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        TH1=<span class="number">0xFD</span>;   <span class="comment">//Set timer 1 for BAUD=9600</span></span><br><span class="line">        TMOD=<span class="number">0x20</span>;   <span class="comment">//Set Timer 1 in Mode 2 8-bit Auto reload          </span></span><br><span class="line">        SCON=<span class="number">0x50</span>;   <span class="comment">//Set serial reception enable and Mode 1 8-bit UART</span></span><br><span class="line">        TR1=<span class="number">1</span>;     <span class="comment">//Start Timer 1</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptSetUp</span><span class="params">()</span>&#123;</span><br><span class="line">        IP  =  <span class="number">0x04</span>; </span><br><span class="line">     EA  =  <span class="number">1</span>;</span><br><span class="line">     EX0 =  <span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">        EX1 =  <span class="number">1</span>;</span><br><span class="line">     IT0 =  <span class="number">1</span>; <span class="comment">// set edge triggerin</span></span><br><span class="line">        IT1 =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> Message[<span class="number">15</span>]=&#123;<span class="string">&quot;BOMB&quot;</span>&#125;;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = Message[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        serialInit();<span class="comment">// initialize</span></span><br><span class="line">        interruptSetUp();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(start==<span class="number">0</span>)&#123;</span><br><span class="line">                        timeS=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                                P0=seg[timeS];</span><br><span class="line">                                delayNms(<span class="number">500</span>);</span><br><span class="line">                                timeS--;</span><br><span class="line">                                <span class="keyword">if</span>(timeS==<span class="number">-1</span>)&#123;</span><br><span class="line">                                        sendSignal();</span><br><span class="line">                                        delayNms(<span class="number">10</span>);</span><br><span class="line">                                        bomb=<span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123;    <span class="comment">// stop all the BOMBs entirely </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int1</span><span class="params">(<span class="type">void</span>)</span> interrupt 2&#123;</span><br><span class="line">        delayNms(<span class="number">5000</span>);        <span class="comment">//pause for 5 seconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The second BOMB</p>
<ul>
<li>Receive the signal from the last BOMB</li>
<li>Transmit signal to the third</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;; <span class="comment">//数码管驱动</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Message[<span class="number">15</span>]=&#123;<span class="string">&quot;BOMB&quot;</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> receivedMessage[<span class="number">15</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  r=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> timeS=<span class="number">9</span>;</span><br><span class="line">sbit bomb  = P1^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delayNms</span><span class="params">(<span class="type">int</span> N)</span>    <span class="comment">//@11.0592MHz   延时函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);</span><br><span class="line">                N--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptSetUp</span><span class="params">()</span>&#123;</span><br><span class="line">        IP  =  <span class="number">0x04</span>; </span><br><span class="line">   EA  =  <span class="number">1</span>;</span><br><span class="line">   EX0 =  <span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">        EX1 =  <span class="number">1</span>;</span><br><span class="line">   IT0 =  <span class="number">1</span>; <span class="comment">// set edge triggerin</span></span><br><span class="line">        IT1 =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">()</span>    <span class="comment">//9600bps@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  PCON &amp;= <span class="number">0x7F</span>;		<span class="comment">//波特率不倍速</span></span><br><span class="line">  SCON = <span class="number">0x50</span>;		<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;		<span class="comment">//清除定时器1模式位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;		<span class="comment">//设定定时器1为8位自动重装方式</span></span><br><span class="line">  TL1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时初值</span></span><br><span class="line">  TH1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时器重装值		</span></span><br><span class="line">  TR1 = <span class="number">1</span>;			<span class="comment">//启动定时器1</span></span><br><span class="line">  ET1 = <span class="number">0</span>;        	<span class="comment">//禁止定时器1中断</span></span><br><span class="line">  EA=<span class="number">1</span>;				<span class="comment">//开放总中断 </span></span><br><span class="line">  ES=<span class="number">1</span>;				<span class="comment">//开放串口中断</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Uartsend</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte)</span><span class="comment">//发送</span></span><br><span class="line">&#123;</span><br><span class="line">  receivedMessage[r]=byte;<span class="comment">//把数据写入发送缓冲区SBUF</span></span><br><span class="line">        r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = Message[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendReceivedSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = receivedMessage[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_ISR</span><span class="params">()</span> interrupt 4     <span class="comment">//串口中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(RI==<span class="number">1</span>)<span class="comment">//接收中断</span></span><br><span class="line">  &#123;</span><br><span class="line">    Uartsend(SBUF);<span class="comment">//把接收的数据发送到计算机</span></span><br><span class="line">    RI=<span class="number">0</span>;<span class="comment">//软件清零</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compareMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(receivedMessage[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>&amp;&amp;receivedMessage[<span class="number">1</span>]==<span class="string">&#x27;O&#x27;</span>&amp;&amp;receivedMessage[<span class="number">2</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;receivedMessage[<span class="number">3</span>]==<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  UartInit();</span><br><span class="line">        interruptSetUp();</span><br><span class="line">       </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">if</span>(compareMessage()==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                                P0=seg[timeS];</span><br><span class="line">                                delayNms(<span class="number">500</span>);</span><br><span class="line">                                timeS--;</span><br><span class="line">                                <span class="keyword">if</span>(timeS==<span class="number">-1</span>)&#123;</span><br><span class="line">                                        sendSignal();</span><br><span class="line">                                        delayNms(<span class="number">10</span>);</span><br><span class="line">                                        bomb=<span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int1</span><span class="params">(<span class="type">void</span>)</span> interrupt 2&#123;</span><br><span class="line">        delayNms(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>The THird BOMB.</strong></p>
<p>Actually it  does the same thing as the second one .</p>
<ul>
<li>Receive the signal from the last BOMB</li>
<li>Transmit signal to the third one</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;; <span class="comment">//数码管驱动</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Message[<span class="number">15</span>]=&#123;<span class="string">&quot;BOMB&quot;</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> receivedMessage[<span class="number">15</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  r=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> timeS=<span class="number">9</span>;</span><br><span class="line">sbit bomb  = P1^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delayNms</span><span class="params">(<span class="type">int</span> N)</span>    <span class="comment">//@11.0592MHz   延时函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1275</span>;i&gt;<span class="number">0</span>;i--);</span><br><span class="line">                N--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptSetUp</span><span class="params">()</span>&#123;</span><br><span class="line">        IP  =  <span class="number">0x04</span>; </span><br><span class="line">   EA  =  <span class="number">1</span>;</span><br><span class="line">   EX0 =  <span class="number">1</span>; <span class="comment">// allow external interrupt INT0</span></span><br><span class="line">        EX1 =  <span class="number">1</span>;</span><br><span class="line">   IT0 =  <span class="number">1</span>; <span class="comment">// set edge triggerin</span></span><br><span class="line">        IT1 =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">()</span>    <span class="comment">//9600bps@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  PCON &amp;= <span class="number">0x7F</span>;		<span class="comment">//波特率不倍速</span></span><br><span class="line">  SCON = <span class="number">0x50</span>;		<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;		<span class="comment">//清除定时器1模式位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;		<span class="comment">//设定定时器1为8位自动重装方式</span></span><br><span class="line">  TL1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时初值</span></span><br><span class="line">  TH1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时器重装值		</span></span><br><span class="line">  TR1 = <span class="number">1</span>;			<span class="comment">//启动定时器1</span></span><br><span class="line">  ET1 = <span class="number">0</span>;        	<span class="comment">//禁止定时器1中断</span></span><br><span class="line">  EA=<span class="number">1</span>;				<span class="comment">//开放总中断 </span></span><br><span class="line">  ES=<span class="number">1</span>;				<span class="comment">//开放串口中断</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Uartsend</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte)</span><span class="comment">//发送</span></span><br><span class="line">&#123;</span><br><span class="line">  receivedMessage[r]=byte;<span class="comment">//把数据写入发送缓冲区SBUF</span></span><br><span class="line">        r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = Message[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendReceivedSignal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">       delayNms(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         SBUF = receivedMessage[i];  <span class="comment">//Send one by one each byte to serial</span></span><br><span class="line">         <span class="keyword">while</span>(TI==<span class="number">0</span>);      <span class="comment">//Wait for Transmition complition</span></span><br><span class="line">     TI=<span class="number">0</span>;     <span class="comment">//Clear Transmit Intterupt flag</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_ISR</span><span class="params">()</span> interrupt 4     <span class="comment">//串口中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(RI==<span class="number">1</span>)<span class="comment">//接收中断</span></span><br><span class="line">  &#123;</span><br><span class="line">    Uartsend(SBUF);<span class="comment">//把接收的数据发送到计算机</span></span><br><span class="line">    RI=<span class="number">0</span>;<span class="comment">//软件清零</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compareMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(receivedMessage[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>&amp;&amp;receivedMessage[<span class="number">1</span>]==<span class="string">&#x27;O&#x27;</span>&amp;&amp;receivedMessage[<span class="number">2</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;receivedMessage[<span class="number">3</span>]==<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  UartInit();</span><br><span class="line">        interruptSetUp();</span><br><span class="line">       </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">if</span>(compareMessage()==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                                P0=seg[timeS];</span><br><span class="line">                                delayNms(<span class="number">500</span>);</span><br><span class="line">                                timeS--;</span><br><span class="line">                                <span class="keyword">if</span>(timeS==<span class="number">-1</span>)&#123;</span><br><span class="line">                                        sendSignal();</span><br><span class="line">                                        delayNms(<span class="number">10</span>);</span><br><span class="line">                                        bomb=<span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">(<span class="type">void</span>)</span> interrupt 0&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int1</span><span class="params">(<span class="type">void</span>)</span> interrupt 2&#123;</span><br><span class="line">        delayNms(<span class="number">5000</span>);</span><br><span class="line">&#125;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">()</span>    <span class="comment">//9600bps@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  PCON &amp;= <span class="number">0x7F</span>;		<span class="comment">//波特率不倍速</span></span><br><span class="line">  SCON = <span class="number">0x50</span>;		<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;		<span class="comment">//清除定时器1模式位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;		<span class="comment">//设定定时器1为8位自动重装方式</span></span><br><span class="line">  TL1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时初值</span></span><br><span class="line">  TH1 = <span class="number">0xFD</span>;			<span class="comment">//设定定时器重装值		</span></span><br><span class="line">  TR1 = <span class="number">1</span>;			<span class="comment">//启动定时器1</span></span><br><span class="line">  ET1 = <span class="number">0</span>;        	<span class="comment">//禁止定时器1中断</span></span><br><span class="line">  EA=<span class="number">1</span>;				<span class="comment">//开放总中断 </span></span><br><span class="line">  ES=<span class="number">1</span>;				<span class="comment">//开放串口中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Uartsend</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte)</span><span class="comment">//发送</span></span><br><span class="line">&#123;</span><br><span class="line">  SBUF=byte;<span class="comment">//把数据写入发送缓冲区SBUF</span></span><br><span class="line">  <span class="comment">//数据发送完成的标志是TI=1；所以等待数据传送完</span></span><br><span class="line">  <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">  TI=<span class="number">0</span>;<span class="comment">//软件清零</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_ISR</span><span class="params">()</span> interrupt 4<span class="comment">//串口中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(RI==<span class="number">1</span>)<span class="comment">//接收中断</span></span><br><span class="line">  &#123;</span><br><span class="line">    Uartsend(SBUF);<span class="comment">//把接收的数据发送到下一个</span></span><br><span class="line">    RI=<span class="number">0</span>;<span class="comment">//软件清零</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  UartInit();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>This is the end of our BOMB</strong></p>
<p>Good luck .</p>
]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>c51</tag>
      </tags>
  </entry>
  <entry>
    <title>微机原理与接口技术笔记</title>
    <url>/2023/10/26/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="汇编语言（8086为例）"><a href="#汇编语言（8086为例）" class="headerlink" title="汇编语言（8086为例）"></a>汇编语言（8086为例）</h1><p>—-基于《汇编语言第三版》王爽</p>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><ul>
<li>8086 CPU的简介</li>
</ul>
<blockquote>
<p>(1) 16位微处理器；</p>
<p>(2) 采用<strong>高速运算性能</strong>的 <code>HMOS</code> 工艺制造，芯片上集成了2.9万只晶体管；</p>
<p>(3) 使用单一的 <code>+5V</code> 电源，<code>40</code> 条引脚双列直插式封装；</p>
<p>(4) 时钟频率为 <code>5MHz~10MHz</code> ，基本指令执行时间为<code>0.3ms~0.6ms</code> ；</p>
<p>(5) 16根数据线和 20根地址线，可寻址的地址空间达 <code>1MB</code> (毕竟 16根地址线只可以寻址 64KB，太小了) ；</p>
</blockquote>
<ul>
<li>冯诺依曼架构</li>
</ul>
<blockquote>
<p><strong>冯·诺伊曼结构</strong>（英语：Von Neumann architecture），也称<strong>范·诺伊曼模型</strong>（Von Neumann model）或<strong>普林斯顿结构</strong>（Princeton architecture），是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。该结构包含：运算器、控制器、存储器、输入设备、输出设备。</p>
<blockquote>
<p>结构特点：</p>
<ol>
<li>以运算单元为中心</li>
<li>采用存储程序原理</li>
<li>存储器是按地址访问、线性编址的空间</li>
<li>控制流由指令流产生</li>
<li>指令由操作码和地址码组成</li>
<li>数据以二进制编码</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>存储单元</li>
</ul>
<blockquote>
<p>1 KB&#x3D;1024 B(字节)</p>
<p>1 字（word）&#x3D;2 字节</p>
<p>1 B&#x3D;8 bit</p>
</blockquote>
<ul>
<li>总线</li>
</ul>
<p>​	总线包含：<strong>数据总线，地址总线，控制总线</strong></p>
<p>​				<strong>地址总线</strong>：假设一个CPU有N根地址总线（即地址总线宽度为N），最多可以寻找2的N次方个内存单元。</p>
<p>​				<strong>数据总线</strong>：N根数据总线一次可以传输N位二进制数据。</p>
<p>​				8088 CPU数据总线宽度为8；8086 CPU数据总线宽度为16。</p>
<p>​				<strong>控制总线</strong>：N根代表N种控制。</p>
<h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.寄存器"></a>2.寄存器</h2><p>​		一个典型的CPU由：运算器，控制器，寄存器等器件构成。同时他们通过总线在内部相连接（地址，数据，控制）。对于汇编程序员来说，CPU的主要器件就是寄存器。</p>
<p>​		8086寄存器特征：16位  (数据最大为2^16-1)</p>
<p>​		8086 CPU的寄存器种类：</p>
<p><img src="/images/registerof8086.png" alt="register of Intel 8086"></p>
<blockquote>
<ul>
<li>AX</li>
<li>BX</li>
<li>CX</li>
<li>DX    &#x2F;&#x2F;    以上四个为通用寄存器，用于存放一般性数据</li>
<li>SI</li>
<li>DI</li>
<li>SP</li>
<li>BP</li>
<li>IP</li>
<li>CS</li>
<li>SS</li>
</ul>
</blockquote>
<ul>
<li><strong>通用寄存器</strong></li>
</ul>
<p>​		<em>AX,BX,CX,DX四个寄存器通常用来存放一般性数据，因此内成为通用寄存器</em>。</p>
<blockquote>
<p>8086的上一代CPU的寄存器是8位的，为了兼容性，这四个寄存器也可以当丞8个8位寄存器使用。</p>
<ul>
<li><p>AX—-AH,AL</p>
</li>
<li><p>BX—-BH,BL</p>
</li>
<li><p>CX—-DH,DL</p>
</li>
<li><p>DX—-DH,DL	    （L和H指的是low和high，即低位和高位）</p>
</li>
</ul>
</blockquote>
<ul>
<li>8086 CPU的物理地址给出方法</li>
</ul>
<p>​		<strong>物理地址&#x3D;段地址*16+偏移地址</strong>   （段地址*16  可以理解为段地址向左移四位）</p>
<blockquote>
<p>一个物理地址可以可以有不同的段地址和偏移地址</p>
<p>偏移地址为16位，寻址能力为2^16即 64 KB，所以一个段的长度不能超过 64 KB</p>
</blockquote>
<ul>
<li><strong>段寄存器</strong></li>
</ul>
<blockquote>
<p>8086 CPU 的段寄存器：</p>
<ul>
<li>CS</li>
<li>DS</li>
<li>SS</li>
<li>ES</li>
</ul>
</blockquote>
<ul>
<li>CS 和 IP</li>
</ul>
<p>​	对于8086 CPU来说，CS和IP一起指示了当前要读取指令的地址：CS :IP ，执行该位置的语句后IP会自动增加，从而可以进行下一指令的执行。</p>
<ul>
<li><p>CS 和 IP 寄存器的修改</p>
</li>
<li><p>* </p>
<ul>
<li>情况一：当你在写汇编脚本或者直接向内存中写入汇编指令时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用 JMP 指令</span><br><span class="line">使用方法： JMP 段地址：偏移地址</span><br><span class="line">eg: JMP 2AE3:3   //CS=2AE3,IP= 0003（均为16进制）</span><br><span class="line">或者（不想改变段地址时）</span><br><span class="line">JMP ax,    # 修改IP为 AX的值</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>情况二： 在debug.exe（MASM32）中想要修改当前程序运行位置时(后面将会介绍)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如在 dosBox中：</span><br><span class="line">debug.exe #进入debug模式</span><br><span class="line">-r CS</span><br><span class="line">CS 073f</span><br><span class="line">:XXXX(输入你需要位置)  # IP寄存器同理，通用寄存器也同上</span><br></pre></td></tr></table></figure>


</li>
<li><p>代码段</p>
</li>
</ul>
<p>​		即定义一片区域用于输入需要执行的代码。</p>
<ul>
<li><strong>debug的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-r              #显示CPU各个寄存器的值</span><br><span class="line">-r 寄存器名字    	 	 #修改寄存器的值</span><br><span class="line"></span><br><span class="line">-d              #查看当前地址的内容</span><br><span class="line">-d 段地址：偏移地址       #查看该段的地址</span><br><span class="line"></span><br><span class="line">-a              #从当前位置开始写入汇编指令</span><br><span class="line">-a 段地址：偏移地址        #从该位置开始写入汇编指令</span><br><span class="line"></span><br><span class="line">-e                        #从当前位置开始写入机器码</span><br><span class="line">-e 段地址：偏移地址        #从该位置开始写入机器码</span><br></pre></td></tr></table></figure>



<h2 id="3-寄存器（内存访问）"><a href="#3-寄存器（内存访问）" class="headerlink" title="3.寄存器（内存访问）"></a>3.寄存器（内存访问）</h2><ul>
<li><strong>字型数据</strong></li>
</ul>
<blockquote>
<p>​	CPU用16位寄存器存在出一个字。高八位存放高位字节，低八位存放低位字节。</p>
</blockquote>
<ul>
<li><strong>DS和[address]</strong></li>
</ul>
<p>​		<strong>物理地址&#x3D;段地址*16+偏移地址</strong>   （段地址<em>16  可以理解为段地址向左移四位），因此如果想要读写某个地址，首先应该知道其段地址和偏移地址，8086 CPU通过寄存器<strong>DS</strong>来获取段地址，[N]来表示偏移地址，*</em>[ … ]用来表示一个内存单元（）**。</p>
<p><strong>注意：8086CPU 不支持将数据直接送入段寄存器。</strong></p>
<ul>
<li>字型数据的传送</li>
</ul>
<p>​	eg:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov bx,<span class="number">1000</span>H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov ax,[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>栈</strong></li>
</ul>
<p>​	使用8086 CPU编程时，可以将一段内存当做栈来使用。提供入栈和出栈指令，即<strong>PUSH 和 POP</strong></p>
<blockquote>
<p><strong>任意时刻，SS:SP 指向栈顶元素</strong> </p>
<p>同时，可以通过设置 SS,SP 寄存器的数据来修改栈的容量，地址。</p>
</blockquote>
<p>​	push pop指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push [0]         ;将 DS :0 处的字压入栈</span><br><span class="line">pop [2]          ;出栈，将数据送入 DS:0处</span><br></pre></td></tr></table></figure>









<h2 id="4-第一个程序"><a href="#4-第一个程序" class="headerlink" title="4.第一个程序"></a>4.第一个程序</h2><ul>
<li><strong>源程序（后缀 .asm）的编写</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;1.asm</span><br><span class="line">assume cs:codesg ;将用作代码段的段codesg和段寄存器cs联系起来。</span><br><span class="line"></span><br><span class="line">codesg segment ;定义一个段，段的名称为“codesg”，这个段从此开始</span><br><span class="line">         ;codesg是一个标号，作为一个段的名称，最终被编译连接成一个段的段地址</span><br><span class="line"></span><br><span class="line">  mov ax, 0123H</span><br><span class="line">  mov bx, 0456H </span><br><span class="line">  add ax, bx</span><br><span class="line">  add ax, ax </span><br><span class="line">  </span><br><span class="line">  mov ax, 4c00H </span><br><span class="line">  int 21H ;这两条指令实现程序的返回 ,相当于	return 0</span><br><span class="line">  </span><br><span class="line">codesg ends ;名称为“codesg”的段到此结束</span><br><span class="line"></span><br><span class="line">end ;编译器在编译汇编程序的过程中，碰到了伪指令end，结束对源程序的编译</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-bx-和loop指令"><a href="#5-bx-和loop指令" class="headerlink" title="5.[bx]和loop指令"></a>5.[bx]和loop指令</h2><blockquote>
<p><strong>bx</strong></p>
<p>​	[bx]也表示一个内存单元，它的偏移地址在bx中</p>
<p><strong>loop</strong></p>
<p>​	通用寄存器CX存储循环次数，循环一次：（cx）&#x3D; （cx）- 1；</p>
</blockquote>
<p>案例程序：</p>
<ol>
<li>实现2^12</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">  mov ax, 2</span><br><span class="line">  </span><br><span class="line">  mov cx, 11 ;循环次数</span><br><span class="line">s:  add ax, ax </span><br><span class="line">  loop s     ;在汇编语言中，标号代表一个地址，标号s实际上标识了一个地址，</span><br><span class="line">               ;这个地址处有一条指令：add ax，ax。</span><br><span class="line">               ;执行loop s时，首先要将（cx）减1，然后若（cx）不为0，则向前</span><br><span class="line">               ;转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。</span><br><span class="line">  </span><br><span class="line">  mov ax,4c00h </span><br><span class="line">  int 21h </span><br><span class="line">code ends </span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现将内存<code>ffff:0 ~ ffff:b</code>单元中的数据复制到<code>0:200 ~ 0:20b</code>单元中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">  mov ax, 0ffffh </span><br><span class="line">  mov ds, ax  	 ;（ds）= 0ffffh </span><br><span class="line">  mov ax, 0020h</span><br><span class="line">    mov es, ax     ;（es）= 0020h     0:200 等效于 0020:0</span><br><span class="line">    mov bx, 0       ;（bx）= 0，此时ds:bx指向ffff:0，es:bx指向0020:0</span><br><span class="line">    </span><br><span class="line">  mov cx，12  	    ;（cx）=12，循环12次</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">s:  mov dl，[bx]   ;（d1）=（（ds）* 16+（bx）），将ffff:bx中的字节数据送入dl </span><br><span class="line">  mov es:[bx]，dl 	;（（es）*16+（bx））=（d1），将dl中的数据送入0020:bx </span><br><span class="line">  inc bx  		;（bx）=（bx）+1</span><br><span class="line">  loop s </span><br><span class="line">  </span><br><span class="line">  mov ax，4c00h </span><br><span class="line">  int 21h </span><br><span class="line">code ends </span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="6-包含多个段的程序"><a href="#6-包含多个段的程序" class="headerlink" title="6.包含多个段的程序"></a>6.包含多个段的程序</h2><ul>
<li><ol>
<li>在代码中使用数据</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;计算 8 个数据的和存到 ax 寄存器</span><br><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line"></span><br><span class="line">  dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据</span><br><span class="line"></span><br><span class="line">  start:	mov bx, 0  ;标号start</span><br><span class="line">      mov ax, 0  </span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s:		add ax, cs:[bx]</span><br><span class="line">      add bx, 2</span><br><span class="line">      loop s </span><br><span class="line">      </span><br><span class="line">      mov ax, 4c00h </span><br><span class="line">      int 21h </span><br><span class="line">code ends</span><br><span class="line">end start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方</span><br><span class="line">       	 ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在代码中使用栈</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;利用栈，将程序中定义的数据逆序存放。</span><br><span class="line">assume cs:codesg </span><br><span class="line"></span><br><span class="line">codesg segment </span><br><span class="line">  dw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h ; 0-15单元</span><br><span class="line">  dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0 ; 16-47单元作为栈使用</span><br><span class="line">      </span><br><span class="line">  start:	mov ax, cs </span><br><span class="line">      mov ss, ax </span><br><span class="line">      mov sp, 30h ;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d</span><br><span class="line">      mov bx, 0</span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s:		push cs:[bx]</span><br><span class="line">      add bx, 2</span><br><span class="line">      loop s    ;以上将代码段0~15单元中的8个字型数据依次入栈</span><br><span class="line">      </span><br><span class="line">      mov bx, 0</span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s0:		pop cs:[bx]		</span><br><span class="line">      add bx，2</span><br><span class="line">      loop s0   ;以上依次出栈8个字型数据到代码段0~15单元中</span><br><span class="line">      </span><br><span class="line">      mov ax，4c00h </span><br><span class="line">      int 21h </span><br><span class="line">codesg ends </span><br><span class="line">end start  ;指明程序的入口在start处</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将数据、代码、栈放入不同的段</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack </span><br><span class="line"></span><br><span class="line">data segment </span><br><span class="line">  dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;0-15单元</span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">stack segment </span><br><span class="line">  dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;0-31单元</span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">  start:	mov ax, stack;将名称为“stack”的段的段地址送入ax</span><br><span class="line">      mov ss, ax</span><br><span class="line">      mov sp, 20h  ;设置栈顶ss:sp指向stack:20。 20h = 32d</span><br><span class="line">      </span><br><span class="line">      mov ax, data ;将名称为“data”的段的段地址送入ax</span><br><span class="line">      mov ds, ax   ;ds指向data段</span><br><span class="line">      </span><br><span class="line">      mov bx, 0    ;ds:bx指向data段中的第一个单元</span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s:	    push [bx]</span><br><span class="line">      add bx, 2</span><br><span class="line">      loop s       ;以上将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line">      </span><br><span class="line">      mov bx, 0</span><br><span class="line">      </span><br><span class="line">      mov cx, 8</span><br><span class="line">  s0:		pop [bx]</span><br><span class="line">      add bx, 2</span><br><span class="line">      loop s0      ;以上依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line">      </span><br><span class="line">      mov ax, 4c00h </span><br><span class="line">      int 21h </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，</span><br><span class="line">;可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="7-更灵活灵活的定位内存地址的方法"><a href="#7-更灵活灵活的定位内存地址的方法" class="headerlink" title="7.更灵活灵活的定位内存地址的方法"></a>7.更灵活灵活的定位内存地址的方法</h2><pre><code>* **and 和 or 指令**
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al , 01100011B</span><br><span class="line">and al , 00111011B    ;按位与，执行后：al=00100011B</span><br><span class="line"></span><br><span class="line">mov al, 01100011B</span><br><span class="line">or al, 00111011B    ;按位或，执行后：al=01111011B</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>ASCII</strong></li>
</ul>
<ol>
<li>以字符的形式给出数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data </span><br><span class="line"></span><br><span class="line">data segment </span><br><span class="line">  db &#x27;unIx&#x27;   ;相当于“db 75H，6EH，49H，58H”</span><br><span class="line">  db &#x27;foRK&#x27;</span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov al, &#x27;a&#x27;  ;相当于“mov al, 61H”，“a”的ASCI码为61H；</span><br><span class="line">    mov b1, &#x27;b&#x27;</span><br><span class="line">    </span><br><span class="line">    mov ax, 4c00h </span><br><span class="line">    int 21h </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>大小写转换</li>
</ol>
<p>​		<strong>小写字母的ASCII码值比大写字母的ASCII码值大20H</strong></p>
<p>​		<strong>大写字母ASCII码的第5位为0，小写字母的第5位为1(其他一致)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg </span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">  db &#x27;BaSiC&#x27;</span><br><span class="line">  db &#x27;iNfOrMaTion&#x27;</span><br><span class="line">datasg end</span><br><span class="line"></span><br><span class="line">codesg segment </span><br><span class="line">  start:	mov ax, datasg </span><br><span class="line">      mov ds, ax	;设置ds 指向 datasg段</span><br><span class="line">    </span><br><span class="line">      mov bx, 0	;设置（bx）=0，ds:bx指向’BaSic’的第一个字母</span><br><span class="line">      </span><br><span class="line">      mov cx, 5     	 ;设置循环次数5，因为’Basic&#x27;有5个字母</span><br><span class="line">  s:		mov al, [bx]     ;将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">      and al, 11011111B;将al中的ASCII码的第5位置为0，变为大写字母</span><br><span class="line">      mov [bx], al	 ;将转变后的ASCII码写回原单元</span><br><span class="line">      inc bx		     ;（bx）加1，ds:bx指向下一个字母</span><br><span class="line">      loop s </span><br><span class="line">      </span><br><span class="line">      mov bx, 5	;设置（bx）=5，ds:bx指向，iNfOrMaTion&#x27;的第一个字母</span><br><span class="line">      </span><br><span class="line">      mov cx, 11	;设置循环次数11，因为‘iNfOrMaTion&#x27;有11个字母</span><br><span class="line">  s0:		mov al, [bx]</span><br><span class="line">      or al, 00100000B;将a1中的ASCII码的第5位置为1，变为小写字母</span><br><span class="line">      mov [bx], al </span><br><span class="line">      inc bx</span><br><span class="line">      loop s0</span><br><span class="line">      </span><br><span class="line">      mov ax, 4c00h </span><br><span class="line">      int 21h </span><br><span class="line">codesg ends</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>SI 和 DI</li>
</ol>
<p>​	SI 和 DI 是8086 CPU中和 bx 功能相近的寄存器，但是 SI 和 DI 不能分成连个该8为寄存器使用。</p>
<blockquote>
<p>idata : 立即数，直接的数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 1                 ;对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）</span><br><span class="line">add bx, 2000h             ;在汇编语言中称为：立即数（idata）</span><br><span class="line">or bx, 00010000b</span><br><span class="line">mov al, &#x27;a&#x27;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>处理数据的长度</li>
</ol>
<blockquote>
<p>8086CPU的指令，可以处理两种尺寸的数据，byte和word（字节和字）。</p>
<p>通过寄<strong>存器名</strong>指明要处理的数据的尺寸。<br>例如： mov <strong>al</strong>, ds:[0] 寄存器al指明了数据为1字节</p>
<p>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte。<br>例如：mov byte ptr ds:[0], 1 byte ptr 指明了指令访问的内存单元是一个字节单元</p>
<p>有些<strong>指令默认</strong>了访问的是字单元还是字节单元<br>例如，push [1000H]，push 指令只进行<strong>字</strong>操作。</p>
</blockquote>
<ol start="6">
<li><strong>div指令、dd、dup、mul指令</strong></li>
</ol>
<blockquote>
<p>div ：除法指令。</p>
<p>除数：有8位和16位两种，在一个寄存器或内存单元中。</p>
<p>被除数：默认放在AX或DX和AX中，<br>如果除数为8位，被除数则为16位，默认在AX中存放；<br>如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</p>
<p>结果：<br>如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；<br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;利用除法指令计算100001/100。</span><br><span class="line">;100001D = 186A1H</span><br><span class="line">mov dx, 1</span><br><span class="line">mov ax, 86A1H ;(dx)*10000H+(ax)=100001</span><br><span class="line">mov bx, 100</span><br><span class="line">div bx</span><br><span class="line"></span><br><span class="line">;利用除法指令计算1001/100</span><br><span class="line">mov ax, 1001</span><br><span class="line">mov bl, 100</span><br><span class="line">div b1</span><br></pre></td></tr></table></figure>



<blockquote>
<p>dd：</p>
<ul>
<li><p>db 和 dw 定义字节型数据和字型数据。</p>
</li>
<li><p>dd 是用来定义dword（double word，<strong>双字（四个字节）</strong>）型数据的伪指令</p>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd 100001</span><br><span class="line">dw 100</span><br><span class="line">dw 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>操作符：</p>
<p>与db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db 3 dup (0)       ;定义了3个字节，它们的值都是0，相当于db 0，0，0。</span><br><span class="line">db 3 dup (0, 1, 2) ;定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0，1，2，0，1，2，0，1，2。</span><br><span class="line">db 3 dup (&#x27;abc&#x27;, &#x27;ABC&#x27;) ;定义了18个字节，它们是abcABCabcABCabcABCC，相当于db &#x27;abc&#x27;, &#x27;ABC&#x27; ,&#x27;abc&#x27; , &#x27;ABC, &#x27;abc&#x27;, &#x27;ABC&#x27;。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>mul 指令 ：</p>
<ul>
<li><p>mul是乘法指令，使用 mul 做乘法的时候：相乘的两个数：要么都是8位，要么都是16位。</p>
</li>
<li><p>乘数：</p>
<ul>
<li><ol>
<li>8 位： <code>AL</code>中和 <code>8位寄存器</code>或<code>内存字节单元</code>中；</li>
<li>16 位： <code>AX</code>中和 <code>16 位寄存器</code>或<code>内存字单元</code>中。</li>
</ol>
</li>
</ul>
</li>
<li><p>结果：</p>
<ul>
<li>8位：AX中；</li>
<li>16位：DX（高位）和 AX（低位）中</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 8 位</span><br><span class="line">;计算100*10</span><br><span class="line">;100和10小于255，可以做8位乘法</span><br><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br><span class="line"></span><br><span class="line">;结果： (ax)=1000（03E8H） </span><br><span class="line"></span><br><span class="line">; 16 位置</span><br><span class="line"></span><br><span class="line">;计算100*10000</span><br><span class="line">;100小于255，可10000大于255，所以必须做16位乘法，程序如下：</span><br><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br><span class="line"></span><br><span class="line">;结果： (ax)=4240H，(dx)=000FH     （F4240H=1000000）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8-数据处理的两个基本问题"><a href="#8-数据处理的两个基本问题" class="headerlink" title="8.数据处理的两个基本问题"></a>8.数据处理的两个基本问题</h2><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><strong>只有四个寄存器可以通过 [ … ] 进行内存单元的寻址</strong> </p>
<ul>
<li>以下代码为错误代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,[cx]</span><br><span class="line">mov ax,[dx]</span><br><span class="line">mov ax,[ax]</span><br><span class="line">mov ax,[ds]</span><br></pre></td></tr></table></figure>

<ul>
<li>在 [ … ] 中四个寄存器可以单独出现，或只能以四种组合出现</li>
</ul>
<blockquote>
<ol>
<li>bx 和 si</li>
<li>bx 和 di</li>
<li>bp 和 si</li>
<li>bp 和 di</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">            ;也可以加上data</span><br><span class="line">mov ax,[bx+si+idata</span><br><span class="line">mov ax,[bx+di+1]</span><br><span class="line">mov ax,[bp+si+2</span><br><span class="line">mov ax,[bp+di+3</span><br></pre></td></tr></table></figure>

<h3 id="处理的数据的大小"><a href="#处理的数据的大小" class="headerlink" title="处理的数据的大小"></a>处理的数据的大小</h3><ul>
<li>一般是字或者字节</li>
</ul>
<blockquote>
<p>在没有寄存器名的情况下可以使用 <code>X ptr</code>指明内存单元的长度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr []bx</span><br><span class="line">add word ptr [bx],2</span><br><span class="line"></span><br><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr []bx</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure>





<h2 id="9-转移指令"><a href="#9-转移指令" class="headerlink" title="9.转移指令"></a>9.转移指令</h2><blockquote>
<p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp ax        ; 段内转移</span><br><span class="line">jmp 1000:0     ; 段间转移</span><br></pre></td></tr></table></figure>

<p><strong>offset</strong></p>
<blockquote>
<p>操作符offset在编语言中是由编译器处理的符号，它的功能是<strong>取得标号的偏移地址</strong>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  ;将s处的一条指令复制到s0处</span><br><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line"> s:   mov ax, bx                 ;（mov ax,bx 的机器码占两个字节）</span><br><span class="line">      mov si, offset s           ;获得标号s的偏移地址</span><br><span class="line">      mov di, offset s0          ;获得标号s0的偏移地址</span><br><span class="line">      </span><br><span class="line">      mov ax, cs:[si]</span><br><span class="line">      mov cs:[di], ax</span><br><span class="line"> s0:  nop                           ;（nop的机器码占一个字节）</span><br><span class="line">      nop</span><br><span class="line"> codesg ends</span><br><span class="line"> ends</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>jmp指令</strong></p>
<blockquote>
<p><strong>jmp 为无条件转移</strong>，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；</p>
<p>jmp 指令要给出两种信息：</p>
<ol>
<li><p>转移的目的地址</p>
</li>
<li><p>转移的距离（段间转移、段内短转移，段内近转移）</p>
<p>jmp short 标号 jmp near ptr 标号 jcxz 标号 loop 标号 等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</p>
</li>
</ol>
</blockquote>
<ol>
<li><strong>jmp short 标号</strong></li>
</ol>
<ul>
<li>实现段内短转移修改范围（-128-127）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,9527h</span><br><span class="line">jmp short s        ; 跳转到</span><br><span class="line">add ax,1111h</span><br><span class="line">s: mov ax,2222h      ; 这里</span><br><span class="line">mov ax 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>jmp near ptr</strong></li>
</ol>
<ul>
<li>实现段内近转移（修改范围大于（-128-127）但是小于-32768～32767，编译成功但链接失败），这是jmp short 实现不了的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,9527h</span><br><span class="line">jmp near ptr s        ; 跳转到</span><br><span class="line">db 128 dup(0)        ; 制造距离超过127</span><br><span class="line">s: mov ax,2222h      ; 这里</span><br><span class="line">mov ax 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>jmp far ptr</strong></li>
</ol>
<ul>
<li>实现段间转移（修改范围超过-32768～32767）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,9527h</span><br><span class="line">jmp near ptr s        ; 跳转到</span><br><span class="line">db 32768 dup(0)        ; 制造距离超过32767</span><br><span class="line">s: mov ax,2222h      ; 这里</span><br><span class="line">mov ax 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<ol start="3">
<li><strong>转移地址在寄存器或内存中的jmp指令</strong></li>
</ol>
<ul>
<li>jmp 寄存器，直接修改ip为寄存器的值</li>
<li>jmp word ptr 内存单元</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 0123H</span><br><span class="line">mov ds:[0], ax</span><br><span class="line">jmp word ptr ds:[0]      ;执行后，(IP)=0123H</span><br></pre></td></tr></table></figure>



<p><strong>jxcz 标号</strong> </p>
<blockquote>
<p>如果(cx)&#x3D;0,转移到标号处执行；若(cx) !&#x3D; 0,继续向下执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">data segment</span><br><span class="line">  db 0,0,0</span><br><span class="line">data ends</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">stack segment</span><br><span class="line"> </span><br><span class="line">  dw 16 dup(0)</span><br><span class="line"> </span><br><span class="line">stack ends</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">code segment  </span><br><span class="line">start:  mov  ax,2000H</span><br><span class="line">    mov  ds,ax</span><br><span class="line">    mov  bx,0</span><br><span class="line"> </span><br><span class="line">s:    mov  ch,0</span><br><span class="line">    mov  cl,ds:[bx]</span><br><span class="line">    jcxz ok		;若(cx)==0，跳转至ok标号处执行</span><br><span class="line">    inc  bx		;继续循环，直至查找到第一个值为0的字节</span><br><span class="line">    jmp  short s</span><br><span class="line"> </span><br><span class="line">ok:    mov  dx,bx</span><br><span class="line">    mov  ax,4c00H</span><br><span class="line">    int  21H</span><br><span class="line">code ends</span><br><span class="line"> </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="10-call和ret指令"><a href="#10-call和ret指令" class="headerlink" title="10.call和ret指令"></a>10.call和ret指令</h2><ul>
<li><strong>ret和retf</strong></li>
</ul>
<blockquote>
<ul>
<li><strong>ret</strong>指令用栈中的数据，修改IP的内容，从而实现<strong>近转移</strong></li>
</ul>
<p>对于ret：相当于<strong>一次</strong> pop，把数据放在ip里</p>
<ul>
<li><strong>retf</strong>指令用栈中的数据，修改CS和IP的内容，从而实现<strong>远转移</strong>。</li>
</ul>
<p>对于ret：相当于<strong>两次</strong> pop，第一次数据放在ip里，第二次放cs里</p>
</blockquote>
<ul>
<li><strong>call指令</strong></li>
</ul>
<p>类似于jmp，<strong>但是</strong>多了一个功能：<strong>将当前的 IP 或 CS和IP 压入栈中</strong>，此外，call没有短转移</p>
<ul>
<li><strong>call和ret的连招</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,1</span><br><span class="line">      mov cx,3</span><br><span class="line">       call s ;（1）CPU指令缓冲器存放call指令，IP指向下一条指令（mov bx, ax），执行call指令，IP入栈，jmp</span><br><span class="line">       </span><br><span class="line">      mov bx,ax;（4）IP重新指向这里  bx = 8</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     s: add ax,ax</span><br><span class="line">       loop s;（2）循环3次ax = 8</span><br><span class="line">      ret;（3）return : pop IP</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="10-错题"><a href="#10-错题" class="headerlink" title="10.错题"></a>10.错题</h2><blockquote>
<p>一、下列关于8086CPU的工作原理的描述错误的是__3__。<br> 1、 汇编程序员可以通过对各种寄存器中内容的修改实现对CPU的控制。<br> 2、 CPU在访问内存时，采用“段地址*16+偏移地址”的形式给出要访问的内存单元的物理地址。<br>3、 任意时刻，CS:IP指向的内容即是此刻CPU正在执行的指令。<br> 4、 传送指令能够更改所有通用寄存器的内容。</p>
<p>注解：</p>
<pre><code> 1、正确，见课本P13
 2、正确 
 3、错误。课本P24，8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行。此处的含义是**将要执行**，比如输入T,CPU读取CS:IP的内容，载入指令执行，而不是正在执行。
 4、通用寄存器是AX、BX、CX、DX，传送指令是mov，mov指令可以改变4个通用寄存器的内容
</code></pre>
</blockquote>
<blockquote>
<p>六、下列说法中正确的是：<strong>4</strong><br>1、 8086CPU采用“段地址*16+偏移地址&#x3D;物理地址”的寻址模式，所以内存是由一个一个的段组成，每一个段有一个段地址。<br>2、 物理地址为ffff0H的内存单元的偏移地址可能为ffffH。<br>3、 一个段的大小可以是8Byte。<br>4、 在一段没有任何跳转指令的程序中，超出64K的部分将不会被执行。</p>
<p>注解：</p>
<pre><code> 1、第一句、第三句正确，第二句错误。内存没有分段，段的划分来自于CPU.见课本P22
 2、错误，不可能，若偏移地址为FFFFH，则段地址为EFFF1H，是不对的
 3、段大小最小16B(Byte)
 4、正确，CPU执行指令取决于CS;IP，IP最大65535，超过64K的IP不识别，CPU也就无法执行。
</code></pre>
</blockquote>
<blockquote>
<p>五、16位结构的CPU 不一定具备的特性是：<strong>4</strong><br>1、 运算器一次最多可以处理16位的数据<br>2、 寄存器的最大宽度为16位<br>3、 寄存器和运算器之间的通路为16位<br>4、 地址总线为16根</p>
<p>注解：见课本P18<br>      16位CPU特征：运算器一次最多可以处理16位的数据<br>                             寄存器的最大宽度为16位<br>                             寄存器和运算器之间的通路为16位<br>       8086CPU有20根地址总线，可以传送20位地址。故选择4</p>
</blockquote>
<blockquote>
<p>5.若将以1000H为段地址的整个段空间当作栈使用，那么寄存器SP的初始值最合理的设置是_____。 (1)<br>1、  0000H<br>2、  0001H<br>3、  FFFFH<br>4、  FFFEH</p>
<p>注解：以1000H为段地址的整个段空间，偏移地址为0-FFFFH，当栈中只有1个字时，偏移地址是FFFEH，当栈为空时，SP&#x3D;SP+2&#x3D;FFFF+2&#x3D;0000，所以选择1 </p>
<p>下列指令的书写正确的是： 3 。<br>1、 push al<br>2、 mov cs:[0],ds:[10]<br>3、 pop si<br>4、 mov ds:[0],2</p>
<p>解析：答案1错误，压堆指令一次性操作一个字；答案2错误，内存空间之间不能互相传送；答案3正确；答案4错误，不能将立即数送入内存空间</p>
</blockquote>
]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql学习笔记</title>
    <url>/2023/10/31/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MySQL学习笔记（8-0）"><a href="#MySQL学习笔记（8-0）" class="headerlink" title="MySQL学习笔记（8.0）"></a>MySQL学习笔记（8.0）</h1><p>​		一切只因花几十块买了一年的云服务器。刚好目前需要用 用 JDBC ，于是就把数据库部署到了服务器上面。然而这其中却遇到了难以想象的困难（后来才发现没有必要这么弄，且一般也不这么弄，安全性大打折扣）。</p>
<h2 id="1-部署环境以及初始化配置"><a href="#1-部署环境以及初始化配置" class="headerlink" title="1.部署环境以及初始化配置"></a>1.部署环境以及初始化配置</h2><ul>
<li>Ubuntu</li>
</ul>
<h3 id="1-下载安装，配置密码"><a href="#1-下载安装，配置密码" class="headerlink" title="1.下载安装，配置密码"></a>1.下载安装，配置密码</h3><p>以root用户登录之后：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade  #不解释</span><br><span class="line">apt install mysql-server -y  #下载</span><br></pre></td></tr></table></figure>

<p><strong>此时你可以直接进入mysql</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span> apt install mysql<span class="operator">-</span>server <span class="operator">-</span>y #（将密码置为空）</span><br><span class="line">mysql<span class="operator">&gt;</span> quit;</span><br><span class="line">#  然后重启mysql，再次进入</span><br><span class="line">systemstl restart mysql</span><br><span class="line">mysql</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> (如果不用远程链接则为<span class="string">&#x27;localhost&#x27;</span>)IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> quit #修改完成</span><br></pre></td></tr></table></figure>

<ul>
<li>开启远程链接功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; apt install mysql-server -y #修改访问权限，默认只能本地访问。</span><br></pre></td></tr></table></figure>

<ul>
<li>修改MySQL配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">将[mysqld]下面的 bind-address ***以及mysqlx-bind-address ****注释</span><br><span class="line">同时取消注释</span><br><span class="line">port</span><br><span class="line">user</span><br><span class="line">socket</span><br><span class="line">server-id</span><br><span class="line">重启测试即可</span><br></pre></td></tr></table></figure>

<h2 id="2-开始正式学习mysql"><a href="#2-开始正式学习mysql" class="headerlink" title="2. 开始正式学习mysql"></a>2. 开始正式学习mysql</h2>]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structure and Algorithm</title>
    <url>/2023/11/12/Data-Structure-and-Algorithm/</url>
    <content><![CDATA[<h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h3><blockquote>
<p>​		哈夫曼算法：</p>
<ol>
<li>构造 n 棵二叉树森林，每一个都是带权值的根节点。</li>
<li>选择权值最小的两棵树作为左右子树，其根节点的权值为左右子树权值之和。</li>
<li>删除这两棵树，将新的树加入森林。</li>
<li>重复操作到只剩下一棵树为止。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  基于结构体数组的哈曼树</span></span><br><span class="line"><span class="comment">*  C++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> DataType; <span class="comment">//结点权值的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HTNode</span> <span class="comment">//单个结点的信息</span></span><br><span class="line">&#123;</span><br><span class="line">  DataType weight; <span class="comment">//权值</span></span><br><span class="line">  <span class="type">int</span> parent; <span class="comment">//父节点</span></span><br><span class="line">  <span class="type">int</span> lc, rc; <span class="comment">//左右孩子</span></span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> **HuffmanCode; <span class="comment">//字符指针数组中存储的元素类型</span></span><br><span class="line">              <span class="comment">//用于存储哈夫曼编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标为1到i-1的范围找到权值最小的两个值的下标，其中s1的权值小于s2的权值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree&amp; HT, <span class="type">int</span> n, <span class="type">int</span>&amp; s1, <span class="type">int</span>&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> min;</span><br><span class="line">  <span class="comment">//找第一个最小值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; HT[i].weight &lt; HT[min].weight)</span><br><span class="line">      min = i;</span><br><span class="line">  &#125;</span><br><span class="line">  s1 = min; <span class="comment">//第一个最小值给s1</span></span><br><span class="line">  <span class="comment">//找第二个最小值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">    &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; HT[i].weight &lt; HT[min].weight&amp;&amp;i != s1)</span><br><span class="line">      min = i;</span><br><span class="line">  &#125;</span><br><span class="line">  s2 = min; <span class="comment">//第二个最小值给s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建哈夫曼树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuff</span><span class="params">(HuffmanTree&amp; HT, DataType* w, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>; <span class="comment">//哈夫曼树总结点数</span></span><br><span class="line">    </span><br><span class="line">  HT = (HuffmanTree)<span class="built_in">calloc</span>(m + <span class="number">1</span>, <span class="built_in">sizeof</span>(HTNode)); <span class="comment">//开m+1个HTNode，因为下标为0的HTNode不存储数据</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    HT[i].weight = w[i - <span class="number">1</span>]; <span class="comment">//赋权值给n个叶子结点</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) <span class="comment">//构建哈夫曼树</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//选择权值最小的s1和s2，生成它们的父结点</span></span><br><span class="line">    <span class="type">int</span> s1, s2;</span><br><span class="line">    <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2); <span class="comment">//在下标为1到i-1的范围找到权值最小的两个值的下标，其中s1的权值小于s2的权值</span></span><br><span class="line">    HT[i].weight = HT[s1].weight + HT[s2].weight; <span class="comment">//i的权重是s1和s2的权重之和</span></span><br><span class="line">    HT[s1].parent = i; <span class="comment">//s1的父亲是i</span></span><br><span class="line">    HT[s2].parent = i; <span class="comment">//s2的父亲是i</span></span><br><span class="line">    HT[i].lc = s1; <span class="comment">//左孩子是s1</span></span><br><span class="line">    HT[i].rc = s2; <span class="comment">//右孩子是s2</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//打印哈夫曼树中各结点之间的关系</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;哈夫曼树为:&gt;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;下标   权值     父结点   左孩子   右孩子\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;0                                  \n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-4d   %-6.2lf   %-6d   %-6d   %-6d\n&quot;</span>, i, HT[i].weight, HT[i].parent, HT[i].lc, HT[i].rc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成哈夫曼编码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffCoding</span><span class="params">(HuffmanTree&amp; HT, HuffmanCode&amp; HC, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HC = (HuffmanCode)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>*)*(n + <span class="number">1</span>)); <span class="comment">//开n+1个空间，因为下标为0的空间不用</span></span><br><span class="line">  <span class="type">char</span>* code = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*n); <span class="comment">//辅助空间，编码最长为n(最长时，前n-1个用于存储数据，最后1个用于存放&#x27;\0&#x27;)</span></span><br><span class="line">  code[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//辅助空间最后一个位置为&#x27;\0&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> start = n - <span class="number">1</span>; <span class="comment">//每次生成数据的哈夫曼编码之前，先将start指针指向&#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">int</span> c = i; <span class="comment">//正在进行的第i个数据的编码</span></span><br><span class="line">    <span class="type">int</span> p = HT[c].parent; <span class="comment">//找到该数据的父结点</span></span><br><span class="line">    <span class="keyword">while</span> (p) <span class="comment">//直到父结点为0，即父结点为根结点时，停止</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (HT[p].lc == c) <span class="comment">//如果该结点是其父结点的左孩子，则编码为0，否则为1</span></span><br><span class="line">        code[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        code[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">      c = p; <span class="comment">//继续往上进行编码</span></span><br><span class="line">      p = HT[c].parent; <span class="comment">//c的父结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    HC[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*(n - start)); <span class="comment">//开辟用于存储编码的内存空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(HC[i], &amp;code[start]); <span class="comment">//将编码拷贝到字符指针数组中的相应位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(code); <span class="comment">//释放辅助空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入数据个数:&gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  DataType* w = (DataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DataType)*n);</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入数据:&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  HuffmanTree HT;</span><br><span class="line">  <span class="built_in">CreateHuff</span>(HT, w, n); <span class="comment">//构建哈夫曼树</span></span><br><span class="line"></span><br><span class="line">  HuffmanCode HC;</span><br><span class="line">  <span class="built_in">HuffCoding</span>(HT, HC, n); <span class="comment">//构建哈夫曼编码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//打印哈夫曼编码</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据%.2lf的编码为:%s\n&quot;</span>, HT[i].weight, HC[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(w);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树：求树的高度"><a href="#二叉树：求树的高度" class="headerlink" title="二叉树：求树的高度"></a>二叉树：求树的高度</h3><ol>
<li>递归</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetHeight</span><span class="params">(BinTree BT)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BT) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(GetHeight(BT-&gt;Left),GetHeight(BT-&gt;Right))+<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetHeight</span><span class="params">( BinTree BT )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    BinTree arr[<span class="number">100</span>];</span><br><span class="line">    BinTree tmpFront;</span><br><span class="line">    <span class="type">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h=<span class="number">0</span>;</span><br><span class="line">    arr[rear++]=BT;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nextCount=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(front!=rear)&#123;</span><br><span class="line">        h++;</span><br><span class="line">        count=nextCount;</span><br><span class="line">        nextCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">            tmpFront=arr[front++];</span><br><span class="line">            <span class="keyword">if</span>(tmpFront-&gt;Left)&#123;</span><br><span class="line">                arr[rear++]=tmpFront-&gt;Left;</span><br><span class="line">                nextCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpFront-&gt;Right)&#123;</span><br><span class="line">                arr[rear++]=tmpFront-&gt;Right;</span><br><span class="line">                nextCount++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树：顺序存储"><a href="#二叉树：顺序存储" class="headerlink" title="二叉树：顺序存储"></a>二叉树：顺序存储</h3><p>​	存储按照完全二叉树来（遇到空节点则 赋值 isEmpty 为 true）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">   ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">   <span class="type">bool</span> isEmpty;   <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   TreeNode t[MaxSize];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">      t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入:ABC##DE#G##F###</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">(BiTree *T)</span>  <span class="comment">//创建二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">  <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)		<span class="comment">//判断该字符ch是不是为&#x27;#&#x27;,意思是该节点是不是空的</span></span><br><span class="line">    *T=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));	<span class="comment">//为结点T申请空间</span></span><br><span class="line">    (*T)-&gt;data=ch;		<span class="comment">//将ch的值赋给(*T)-&gt;data</span></span><br><span class="line">    creat(&amp;(*T)-&gt;lchild);</span><br><span class="line">    creat(&amp;(*T)-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li><strong>二叉树：先序遍历</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">       </span><br><span class="line">      PreOrder(T-&gt;lchild);      <span class="comment">//递归遍历左子树</span></span><br><span class="line">      PreOrder(T-&gt;rchild);      <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">//遍历失败，根节点空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p><strong>二叉树：中序遍历</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ShowZhongXu</span><span class="params">(BitTree T)</span>      <span class="comment">//		先序遍历二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)						<span class="comment">//	递归中遇到NULL，返回上一层节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  ShowZhongXu(T-&gt;lchild);			<span class="comment">//	递归遍历左子树</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);</span><br><span class="line">  ShowZhongXu(T-&gt;rchild);			<span class="comment">//	递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树：后序遍历</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ShowZhongXu</span><span class="params">(BitTree T)</span>      <span class="comment">//		先序遍历二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)						<span class="comment">//	递归中遇到NULL，返回上一层节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;					<span class="comment">// 空根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  ShowZhongXu(T-&gt;lchild);			<span class="comment">//	递归遍历左子树</span></span><br><span class="line">  ShowZhongXu(T-&gt;rchild);			<span class="comment">//	递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>二叉树：层序遍历</strong></li>
</ul>
<ul>
<li>使用队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   LinkQueue Q;</span><br><span class="line">   InitQueue (Q);          <span class="comment">//初始化辅助队列</span></span><br><span class="line">    </span><br><span class="line">   BiTree p;</span><br><span class="line">   EnQueue(Q,T);           <span class="comment">//将根节点入队</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">while</span>(!isEmpty(Q))&#123;     <span class="comment">//队列不空则循环</span></span><br><span class="line">      DeQueue(Q,p);        <span class="comment">//队头结点出队</span></span><br><span class="line">      visit(p);            <span class="comment">//访问出队结点</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;lchild);   <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;rchild);   <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树交换左右孩子"><a href="#二叉树交换左右孩子" class="headerlink" title="二叉树交换左右孩子"></a>二叉树交换左右孩子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似于先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    BiTNode *m=T-&gt;lchild;<span class="comment">/*这三行类似于&quot;打擂台法&quot;*/</span></span><br><span class="line">    T-&gt;lchild=T-&gt;rchild;</span><br><span class="line">    T-&gt;rchild=m;			</span><br><span class="line">    swap(T-&gt;lchild);</span><br><span class="line">    swap(T-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求二叉树高度-深度"><a href="#求二叉树高度-深度" class="headerlink" title="求二叉树高度(深度)"></a>求二叉树高度(深度)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">( BiTree T )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> countl =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> countr =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        countl=Depth( T-&gt;lchild );</span><br><span class="line">        countr=Depth( T-&gt;rchild );</span><br><span class="line">        max=countl&gt;countr? countl:countr;</span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><blockquote>
<p>将空的指针域用以指向前驱后继节点。</p>
<p>遵循：</p>
<ul>
<li>ltag&#x3D;&#x3D;0，指向左孩子；ltag&#x3D;&#x3D;1，指向前驱结点</li>
<li>rtag&#x3D;&#x3D;0，指向右孩子；rtag&#x3D;&#x3D;1，指向后继结点</li>
</ul>
</blockquote>
<pre><code>    1. 二叉树的线索化
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderThreadTree</span><span class="params">(Node* node)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//如果当前结点为NULL 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//先处理左子树</span></span><br><span class="line">  inOrderThreadTree(node-&gt;left_node);</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;left_node == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置前驱结点</span></span><br><span class="line">    node-&gt;left_type = <span class="number">1</span>;</span><br><span class="line">    node-&gt;left_node = pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果结点的右子节点为NULL 处理前驱的右指针</span></span><br><span class="line">  <span class="keyword">if</span> (pre !=<span class="literal">NULL</span> &amp;&amp; pre-&gt;right_node == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置后继</span></span><br><span class="line">    pre-&gt;right_node = node;</span><br><span class="line">    pre-&gt;right_type = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//每处理一个节点 当前结点是下一个节点的前驱</span></span><br><span class="line">  pre = node;</span><br><span class="line">  <span class="comment">//最后处理右子树</span></span><br><span class="line">  inOrderThreadTree(node-&gt;right_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>中序遍历线索二叉树</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraverse</span><span class="params">(Node* root)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//从根节点开始先找到最左边</span></span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node* temp = root;</span><br><span class="line">  <span class="comment">//先找到最左边结点 然后根据线索化直接向右遍历</span></span><br><span class="line">  <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;left_type == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    temp = temp-&gt;left_node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    temp = temp-&gt;right_node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><strong>线索二叉树操作集合</strong></p>
<ol>
<li>结构体</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>主函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreorderTraversal</span><span class="params">( BinTree BT )</span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InorderTraversal</span><span class="params">( BinTree BT )</span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line">BinTree <span class="title function_">Insert</span><span class="params">( BinTree BST, ElementType X )</span>;</span><br><span class="line">BinTree <span class="title function_">Delete</span><span class="params">( BinTree BST, ElementType X )</span>;</span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( BinTree BST, ElementType X )</span>;</span><br><span class="line">Position <span class="title function_">FindMin</span><span class="params">( BinTree BST )</span>;</span><br><span class="line">Position <span class="title function_">FindMax</span><span class="params">( BinTree BST )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="type">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = Insert(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Preorder:&quot;</span>); PreorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    MinP = FindMin(BST);</span><br><span class="line">    MaxP = FindMax(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        Tmp = Find(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d is not found\n&quot;</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is found\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the smallest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the largest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = Delete(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inorder:&quot;</span>); InorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>操作集合</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line">BinTree <span class="title function_">Insert</span><span class="params">( BinTree BST, ElementType X )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>) &#123;          <span class="comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span></span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTree));</span><br><span class="line">        BST -&gt;Data = X;</span><br><span class="line">        BST -&gt;Left = BST -&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;         <span class="comment">/* 开始寻找要插入元素的位置 */</span></span><br><span class="line">        <span class="keyword">if</span>(X &lt; BST -&gt;Data ) &#123;</span><br><span class="line">            BST -&gt;Left = Insert(BST -&gt;Left, X);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST -&gt;Data ) &#123;</span><br><span class="line">            BST -&gt;Right = Insert(BST -&gt;Right, X);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* X已经存在，不用操作 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">BinTree <span class="title function_">Delete</span><span class="params">( BinTree BST, ElementType X )</span>&#123;</span><br><span class="line">    BinTree Tmp;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>)    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data)  </span><br><span class="line">            BST -&gt;Left = Delete(BST-&gt;Left, X);          <span class="comment">/* 左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data ) </span><br><span class="line">            BST -&gt;Right = Delete(BST-&gt;Right , X);       <span class="comment">/* 右子树递归删除*/</span></span><br><span class="line">        <span class="keyword">else</span> &#123;                                          <span class="comment">/* 找到需要删除的结点 */</span></span><br><span class="line">            <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123;               <span class="comment">/* 被删除的结点有左右子结点 */</span></span><br><span class="line">                Tmp=FindMin(BST-&gt;Right);                <span class="comment">/* 在右子树中找到最小结点填充删除结点 */</span></span><br><span class="line">                BST-&gt;Data = Tmp -&gt;Data;</span><br><span class="line">                BST-&gt;Right=Delete(BST-&gt;Right,BST-&gt;Data);<span class="comment">/* 递归删除要删除结点的右子树中最小元素 */</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;                                     <span class="comment">/* 被删除结点有一个或没有子结点*/</span></span><br><span class="line">                Tmp = BST;</span><br><span class="line">                <span class="keyword">if</span>(!BST-&gt;Left) BST = BST-&gt;Right;        <span class="comment">/*有右孩子或者没孩子*/</span> </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)    BST = BST-&gt;Left;<span class="comment">/*有左孩子，一定要加else，不然BST可能是NULL，会段错误*/</span> </span><br><span class="line">                <span class="built_in">free</span>(Tmp);                              <span class="comment">/*如无左右孩子直接删除*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( BinTree BST, ElementType X )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(BST-&gt;Data==X)    <span class="keyword">return</span> BST; </span><br><span class="line">    <span class="keyword">if</span>(X&gt;BST-&gt;Data)     <span class="keyword">return</span> Find(BST-&gt;Right,X);      </span><br><span class="line">    <span class="keyword">if</span>(X&lt;BST-&gt;Data)     <span class="keyword">return</span> Find(BST-&gt;Left,X);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*  以下几种写法均可，推荐第上面这一种 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(!BST)    return NULL;</span></span><br><span class="line"><span class="comment">    if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">    if(X&gt;BST-&gt;Data)     Find(BST-&gt;Right,X);     </span></span><br><span class="line"><span class="comment">    if(X&lt;BST-&gt;Data)     Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(BST)&#123;</span></span><br><span class="line"><span class="comment">        if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">        if(X&gt;BST-&gt;Data)     Find(BST-&gt;Right,X);     //如果不写return，则返回过来的值并没有继续返回给最开始的函数 </span></span><br><span class="line"><span class="comment">        if(X&lt;BST-&gt;Data)     Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    else return NULL;   </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(BST)&#123;</span></span><br><span class="line"><span class="comment">        if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">        if(X&gt;BST-&gt;Data)     return  Find(BST-&gt;Right,X); </span></span><br><span class="line"><span class="comment">        if(X&lt;BST-&gt;Data)     return  Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    return NULL;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(BST)&#123;</span></span><br><span class="line"><span class="comment">        if(BST-&gt;Data==X)    return BST; </span></span><br><span class="line"><span class="comment">        if(X&gt;BST-&gt;Data)     return Find(BST-&gt;Right,X);      </span></span><br><span class="line"><span class="comment">        if(X&lt;BST-&gt;Data)     return Find(BST-&gt;Left,X);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    else return NULL;</span></span><br><span class="line"><span class="comment">    */</span>                          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果return NULL前面不写else且Find前也不写else，则最后递归返回的也没return，最后只能是执行到了return NULL</span></span><br><span class="line"><span class="comment">返回了，而如果find 前加上了return则就把递归的结果利用起来了，最后加不加else也无所谓了，而如果直接最后else，</span></span><br><span class="line"><span class="comment">不加return find也是可以的，加上了else之后就不会被每一次返回时最后的return NULL给覆盖掉，所以也行。 */</span> </span><br><span class="line">Position <span class="title function_">FindMin</span><span class="params">( BinTree BST )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Left)&#123;</span><br><span class="line">            BST=BST-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> BST; </span><br><span class="line">&#125; </span><br><span class="line">Position <span class="title function_">FindMax</span><span class="params">( BinTree BST )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right)&#123;</span><br><span class="line">            BST=BST-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> BST; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>​	 	主要用于解决一些<strong>元素分组</strong>的问题。也可以用来判断图的连通性，它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p>
<ul>
<li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li>
<li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//最简单版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *当数据很多时，查找会很耗费时间</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x) father[x]=find(father[x]);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;           <span class="comment">//查找根节点的函数 </span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  升级版</span></span><br><span class="line"><span class="comment">    *  带路径压缩功能</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">  a=x;</span><br><span class="line">  <span class="keyword">while</span>(x!=father[x])x=father[x];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(a!=father[a])&#123;    <span class="comment">//路径压缩 </span></span><br><span class="line">    <span class="type">int</span> z=a;</span><br><span class="line">    a=father[a];</span><br><span class="line">    father[z]=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123; </span><br><span class="line">                <span class="comment">//合并两个集合</span></span><br><span class="line">    <span class="type">int</span> fx=find(a);</span><br><span class="line">    <span class="type">int</span> fy=find(b);</span><br><span class="line">    father[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">judgeConnect</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//判断连通性</span></span><br><span class="line">    <span class="type">int</span> i,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=vertex;i++)</span><br><span class="line">        <span class="keyword">if</span>(father[i]==i) k++;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOE图"><a href="#AOE图" class="headerlink" title="AOE图"></a>AOE图</h3><blockquote>
<p><em>concept:</em></p>
<p>1、<strong>最早发生</strong>时间：从前往后，前驱结点到当前结点所需时间，取<strong>最大值</strong>；</p>
<p>2、<strong>最迟发生</strong>时间：从后往前，后继结点的最迟时间减去边权的值，取<strong>最小值</strong>；</p>
<p><strong>结束节点的最早发生时间和最迟发生时间相同。</strong></p>
<p>3、关键路径：最早发生时间和最迟发生时间相同的结点叫做关键路径上的结点；</p>
<p>4、<strong>最早开始</strong>时间：等于当前边起始节点的最早发生时间；</p>
<p>5、<strong>最晚开始</strong>时间：等于当前便指向结点的最迟时间减去当前边的权值；</p>
<p>6、<strong>最早完工</strong>时间：等于当前边指向结点的最早发生时间；</p>
<p>7、<strong>最晚完工</strong>时间：等于当前边指向结点的最迟发生时间；</p>
</blockquote>
<h3 id="图的链式存储结构"><a href="#图的链式存储结构" class="headerlink" title="图的链式存储结构"></a>图的链式存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100                                 <span class="comment">//最大顶点数 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>                        <span class="comment">//表结点 </span></span><br><span class="line">    <span class="type">int</span> adjvex;                                    <span class="comment">//邻接点的位置 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span>      <span class="comment">//指向下一个表结点的指针 </span></span><br><span class="line">  &#125;ArcNode; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span> </span><br><span class="line">   <span class="type">char</span> data;                                    <span class="comment">//顶点信息 </span></span><br><span class="line">   ArcNode * firstarc;         <span class="comment">//指向第一个表结点的指针 </span></span><br><span class="line">&#125;VNode, AdjList[MVNum];                 <span class="comment">//AdjList表示邻接表类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    AdjList vertices;              <span class="comment">//头结点数组</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;     <span class="comment">//图的当前顶点数和边数 </span></span><br><span class="line">&#125;ALGraph; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatMGraph</span><span class="params">(ALGraph *G)</span>;<span class="comment">/* 创建图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(ALGraph G)</span>;<span class="comment">/*输出图 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    CreatMGraph(&amp;G);</span><br><span class="line">    printGraph(G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatMGraph</span><span class="params">(ALGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;G-&gt;vexnum,&amp;G-&gt;arcnum);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;G-&gt;vertices[i].data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">         G-&gt;vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;arcnum;k++) &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);    </span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;nextarc=G-&gt;vertices[i].firstarc;</span><br><span class="line"></span><br><span class="line">        G-&gt;vertices[i].firstarc=s;   </span><br><span class="line"></span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=i;</span><br><span class="line"></span><br><span class="line">        s-&gt;nextarc=G-&gt;vertices[j].firstarc;;</span><br><span class="line">        G-&gt;vertices[j].firstarc=s;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(ALGraph G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%c:&quot;</span>,G.vertices[i].data);</span><br><span class="line">       <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot; %c&quot;</span>,G.vertices[p-&gt;adjvex].data);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找（搜索）"><a href="#查找（搜索）" class="headerlink" title="查找（搜索）"></a>查找（搜索）</h2><h3 id="折半搜索"><a href="#折半搜索" class="headerlink" title="折半搜索"></a>折半搜索</h3><blockquote>
<p>因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> x, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];<span class="comment">//0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> re=BinSearch(arr,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;下标：%d\n&quot;</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//按折半查找法查找值为x的数组元素，若找到则返回x在数组中的下标位置，否则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = n<span class="number">-1</span>, mid;<span class="comment">//区间左端点low置为0，右端点high置为n-1</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)      <span class="comment">//若左端点小于等于右端点，则继续查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;<span class="comment">//取数据区间的重点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mid);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="built_in">array</span>[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>;      <span class="comment">//若x&gt;array[mid]，则修改区间的左端点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="built_in">array</span>[mid])</span><br><span class="line">            high = mid - <span class="number">1</span>;      <span class="comment">//若x&lt;array[mid]，则修改区间的右端点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;次数：%d\n&quot;</span>,num);</span><br><span class="line">            <span class="keyword">return</span> mid;        <span class="comment">//若找到，则返回下标值mid</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;            <span class="comment">//循环结束仍未找到，则返回值-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><blockquote>
<p>类似于折半搜索，只是mid的计算方法不一样</p>
<p>比较元素的下标：</p>
<p>Mid &#x3D; Begin + ( (End - Begin) &#x2F; (A[End] - A[Begin]) ) * (X - A[Begin])</p>
<blockquote>
<p>式子中，各部分的含义分别是：</p>
<p>Mid：计算得出的元素的位置；</p>
<p>End：搜索区域内最后一个元素所在的位置；</p>
<p>Begin：搜索区域内第一个元素所在的位置；</p>
<p>X：要查找的目标元素；</p>
<p>A[]：表示整个待搜索序列</p>
</blockquote>
</blockquote>
<p>C语言实现过程</p>
<p>​	<strong>递归算法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//实现插值查找算法，ele 表示要查找的目标元素，[begin,end] 指定查找区域</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">interpolation_search</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> ele)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果[begin,end] 不存在，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果搜索区域内只有一个元素，判断其是否为目标元素</span></span><br><span class="line">    <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ele == arr[begin]) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该元素非目标元素，则查找失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到&quot;中间元素&quot;所在的位置</span></span><br><span class="line">    mid = begin + ((end - begin) / (arr[end] - arr[begin]) * (ele - arr[begin]));</span><br><span class="line">    <span class="comment">//递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> (ele == arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较 ele 和 arr[mid] 的值，缩小 ele 可能存在的区域</span></span><br><span class="line">    <span class="keyword">if</span> (ele &lt; arr[mid]) &#123;</span><br><span class="line">        <span class="comment">//新的搜索区域为 [begin,mid-1]</span></span><br><span class="line">        <span class="keyword">return</span> interpolation_search(arr, begin, mid - <span class="number">1</span>, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//新的搜索区域为 [mid+1,end]</span></span><br><span class="line">        <span class="keyword">return</span> interpolation_search(arr, mid + <span class="number">1</span>, end, ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="comment">//输出元素 2 所在位置的下标</span></span><br><span class="line">    <span class="type">int</span> pos = interpolation_search(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, interpolation_search(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><blockquote>
<ol>
<li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li>
<li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li>
<li>左、右子树也分别是一棵二叉排序树。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> data;	<span class="comment">//结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *Bitree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归查找二叉排序树T中是否存在key</span></span><br><span class="line"><span class="comment">指针f指向T的双亲，其初始调用值为NULL</span></span><br><span class="line"><span class="comment">若查找成功，则指针p指向该数据元素结点，并返回TRUE</span></span><br><span class="line"><span class="comment">否则指针p指向查找路径上访问的最后一个结点并返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SearchBST</span><span class="params">(BiTree T, <span class="type">int</span> key, BiTree f, BiTree *p)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">    *p = f;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">    <span class="comment">//查找成功</span></span><br><span class="line">    *p = T;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">    <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);	<span class="comment">//在左子树继续查找</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);	<span class="comment">//在右子树继续查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当二叉排序树T中不存在关键字等于key的数据元素时</span></span><br><span class="line"><span class="comment">插入key并返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">  BiTree p, s;</span><br><span class="line">  <span class="keyword">if</span>(!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p))&#123;</span><br><span class="line">    <span class="comment">//查找不成功</span></span><br><span class="line">    s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    s-&gt;data = key;</span><br><span class="line">    s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">      *T = s;	<span class="comment">//插入s为新的根节点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p-&gt;data)&#123;</span><br><span class="line">      p-&gt;lchild = s;	<span class="comment">//插入s为左孩子</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      p-&gt;rchild = s;	<span class="comment">//插入s为右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;	<span class="comment">//树种已有关键字相同的结点，不再插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************构造二叉排序树************/</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span>&#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  InsertBST(&amp;T, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点，</span></span><br><span class="line"><span class="comment">并返回TRUE;否则返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE; </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">      <span class="comment">//找到关键字等于key的数据元素</span></span><br><span class="line">      <span class="keyword">return</span> Delete(T);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T -&gt; data)&#123;</span><br><span class="line">      <span class="keyword">return</span> DeleteBST(T -&gt; lchild, key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DeleteBST(T -&gt; rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="哈希表（散列表）"><a href="#哈希表（散列表）" class="headerlink" title="哈希表（散列表）"></a>哈希表（散列表）</h3><blockquote>
<p>​	散列表是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>
<p>​	这种对应关系称为散列函数，又称为哈希(Hash) 函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。那么关键字对应的记录存储位置我们称为散列地址。</p>
</blockquote>
<h4 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h4><ol>
<li>直接定址法</li>
</ol>
<p>​				直接取关键字的某个线性函数值为散列地址，散列函数为：<br>$$<br>H(key)&#x3D;key或H(key)&#x3D;a∗key+b<br>$$</p>
<ol start="2">
<li>数字分析法</li>
</ol>
<blockquote>
<p>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址。</p>
</blockquote>
<ol start="3">
<li>平方取中法</li>
</ol>
<blockquote>
<p>平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p>
<p>字面意思：平方之后取中间的数字作为散列地址</p>
</blockquote>
<ol start="4">
<li>除留余数法</li>
</ol>
<p>​				散列函数：</p>
<blockquote>
<p>h（key） &#x3D; key % 17</p>
<blockquote>
<ul>
<li>p取素数（避免余数相关性）</li>
</ul>
</blockquote>
</blockquote>
<ol start="5">
<li>随机数法</li>
</ol>
<p>$$<br>H(key)&#x3D;random(key)<br>$$</p>
<h4 id="处理散列冲突"><a href="#处理散列冲突" class="headerlink" title="处理散列冲突"></a>处理散列冲突</h4><p>​				开放地址法（闭散列表）和链地址法（开散列表法）</p>
<ol>
<li>线性探测法</li>
</ol>
<blockquote>
<p>从冲突的的下一个位置起，依次寻找空的散列地址</p>
<blockquote>
<ul>
<li>存在堆积现象</li>
</ul>
</blockquote>
</blockquote>
<p>​	公式：<br>$$<br>H<br>i<br>​<br> (key)&#x3D;(f(key)+d<br>i<br>​<br> )%m (d<br>i<br>​<br> &#x3D;1,2,3,…,m−1)<br>$$<br>​	此时： di &#x3D; 0,1,2,3,…k</p>
<ol start="2">
<li>二次（平方）探测法</li>
</ol>
<p>​		公式<br>$$<br>H<br>i<br>​<br> (key)&#x3D;(f(key)+d<br>i<br>​<br> )%m (d<br>i<br>​<br> &#x3D;1,2,3,…,m−1)<br>$$<br>​	此时：di &#x3D; 0,1,-1,2^2,-2^2,….k^2,-k^2</p>
<ol start="3">
<li>拉链法</li>
</ol>
<blockquote>
<p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p>
</blockquote>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//记录有序序列最后一个元素的下标</span></span><br><span class="line">    <span class="type">int</span> end = i;</span><br><span class="line">    <span class="comment">//待插入的元素</span></span><br><span class="line">    <span class="type">int</span> tem = arr[end + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//单趟排</span></span><br><span class="line">    <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//比插入的数大就向后移</span></span><br><span class="line">      <span class="keyword">if</span> (tem &lt; arr[end])</span><br><span class="line">      &#123;</span><br><span class="line">        arr[end + <span class="number">1</span>] = arr[end];</span><br><span class="line">        end--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//比插入的数小，跳出循环</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//tem放到比插入的数小的数的后面</span></span><br><span class="line">    arr[end  + <span class="number">1</span>] = tem;</span><br><span class="line">    <span class="comment">//代码执行到此位置有两种情况:</span></span><br><span class="line">    <span class="comment">//1.待插入元素找到应插入位置（break跳出循环到此）</span></span><br><span class="line">    <span class="comment">//2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：	</p>
<ul>
<li>最坏（逆序）：O(n^2)</li>
<li>最好（升序）：O(n)</li>
</ul>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> gap = n;</span><br><span class="line">  <span class="keyword">while</span> (gap&gt;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//每次对gap折半操作</span></span><br><span class="line">    gap = gap / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//单趟排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> end = i;</span><br><span class="line">      <span class="type">int</span> tem = arr[end + gap];</span><br><span class="line">      <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (tem &lt; arr[end])</span><br><span class="line">        &#123;</span><br><span class="line">          arr[end + gap] = arr[end];</span><br><span class="line">          end -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[end + gap] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度(平均)：O(N^1.3)<br>空间复杂度：O(1)</p>
</blockquote>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tem = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//保存参与单趟排序的第一个数和最后一个数的下标</span></span><br><span class="line">  <span class="type">int</span> begin = <span class="number">0</span>, end = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//保存最大值的下标</span></span><br><span class="line">    <span class="type">int</span> maxi = begin;</span><br><span class="line">    <span class="comment">//保存最小值的下标</span></span><br><span class="line">    <span class="type">int</span> mini = begin;</span><br><span class="line">    <span class="comment">//找出最大值和最小值的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[mini])</span><br><span class="line">      &#123;</span><br><span class="line">        mini = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[maxi])</span><br><span class="line">      &#123;</span><br><span class="line">        maxi = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小值放在序列开头</span></span><br><span class="line">    swap(&amp;arr[mini], &amp;arr[begin]);</span><br><span class="line">    <span class="comment">//防止最大的数在begin位置被换走</span></span><br><span class="line">    <span class="keyword">if</span> (begin == maxi)</span><br><span class="line">    &#123;</span><br><span class="line">      maxi = mini;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大值放在序列结尾</span></span><br><span class="line">    swap(&amp;arr[maxi], &amp;arr[end]);</span><br><span class="line">    ++begin;</span><br><span class="line">    --end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最坏情况：O(N^2)</li>
<li>最好情况：O(N^2)</li>
</ul>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> end = n;</span><br><span class="line">  <span class="keyword">while</span> (end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> tem = arr[i];</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">        arr[i - <span class="number">1</span>] = tem;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最坏情况：O(N^2)</li>
<li>最好情况：O(N)</li>
</ul>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>堆的分类：</p>
<ul>
<li>大根堆：每个节点的值大于或等于左右孩子节点的值</li>
<li>小根堆：每个节点的值小于或等于左右孩子节点的值</li>
</ul>
</blockquote>
<p>步骤：</p>
<ol>
<li>构造大根堆</li>
<li>顶端与末尾值交换</li>
<li>将剩下的n-1个数造次构造为大根堆，重复上述操作。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标为升序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapAdjust</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tmp = arr[start];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * start + <span class="number">1</span>; i &lt;= end; i = i * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; end&amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>])<span class="comment">//有右孩子并且左孩子小于右孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;<span class="comment">//i一定是左右孩子的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; tmp)</span><br><span class="line">    &#123;</span><br><span class="line">      arr[start] = arr[i];</span><br><span class="line">      start = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[start] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//第一次建立大根堆，从后往前依次调整</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=(len<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">    HeapAdjust(arr, i, len - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//每次将根和待排序的最后一次交换，然后在调整</span></span><br><span class="line">  <span class="type">int</span> tmp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    tmp = arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = arr[len - <span class="number">1</span>-i];</span><br><span class="line">    arr[len - <span class="number">1</span> - i] = tmp;</span><br><span class="line">    HeapAdjust(arr, <span class="number">0</span>, len - <span class="number">1</span>-i- <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">96</span>,<span class="number">66</span> &#125;;</span><br><span class="line">  HeapSort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;排序后为:&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>时间复杂度：时间复杂度为O(nlogn)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="快速排序（挖坑法）"><a href="#快速排序（挖坑法）" class="headerlink" title="快速排序（挖坑法）"></a>快速排序（挖坑法）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PartSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key = arr[left];</span><br><span class="line">    <span class="type">int</span> hole = left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[hole] = arr[right];</span><br><span class="line">        hole = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[hole] = arr[left];</span><br><span class="line">        hole = left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    arr[hole] = key;</span><br><span class="line">    <span class="keyword">return</span> hole;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="快速排序（库函数直接调用法）"><a href="#快速排序（库函数直接调用法）" class="headerlink" title="快速排序（库函数直接调用法）"></a>快速排序（库函数直接调用法）</h3><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span>* base<span class="comment">/*数组名字*/</span>,<span class="type">size_t</span> num<span class="comment">/*元素个数*/</span>,<span class="type">size_t</span> width<span class="comment">/*单个元素所占字节*/</span>,<span class="type">int</span>(__cdecl*compare)(<span class="type">const</span> <span class="type">void</span>*,<span class="type">const</span> <span class="type">void</span>*)<span class="comment">/*比较函数*/</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">int</span>*)a-*(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> n,i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="type">int</span> time[n];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;time[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  qsort(time,n,<span class="keyword">sizeof</span>(<span class="type">int</span>),cmp);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,time[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> sourceArr[],<span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> midIndex, <span class="type">int</span> endIndex)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = startIndex, j=midIndex+<span class="number">1</span>, k = startIndex;</span><br><span class="line">    <span class="keyword">while</span>(i!=midIndex+<span class="number">1</span> &amp;&amp; j!=endIndex+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i != midIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j != endIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部使用递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> sourceArr[], <span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex) &#123;</span><br><span class="line">        midIndex = startIndex + (endIndex-startIndex) / <span class="number">2</span>;<span class="comment">//避免溢出int</span></span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, b[<span class="number">8</span>];</span><br><span class="line">    MergeSort(a, b, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<blockquote>
<p> 时间复杂度：O(nlogn)。</p>
<p> 空间复杂度：O(N)，归并排序需要一个与原数组相同长度的数组做辅助来排序。</p>
</blockquote>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testBS</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    inta[] = &#123;<span class="number">2</span>, <span class="number">343</span>, <span class="number">342</span>, <span class="number">1</span>, <span class="number">123</span>, <span class="number">43</span>, <span class="number">4343</span>, <span class="number">433</span>, <span class="number">687</span>, <span class="number">654</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *a_p = a;</span><br><span class="line">    <span class="comment">//计算数组长度</span></span><br><span class="line">    intsize = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    bucketSort3(a_p, size);</span><br><span class="line">    <span class="comment">//打印排序后结果</span></span><br><span class="line">    inti;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    intt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucketSort3</span><span class="params">(<span class="type">int</span> *p, intn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取数组中的最大数</span></span><br><span class="line">    intmaxNum = findMaxNum(p, n);</span><br><span class="line">    <span class="comment">//获取最大数的位数，次数也是再分配的次数。</span></span><br><span class="line">    intloopTimes = getLoopTimes(maxNum);</span><br><span class="line">    inti;</span><br><span class="line">    <span class="comment">//对每一位进行桶分配</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= loopTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort2(p, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数字的位数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLoopTimes</span><span class="params">(intnum)</span></span><br><span class="line">&#123;</span><br><span class="line">    intcount = <span class="number">1</span>;</span><br><span class="line">    inttemp = num / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        temp = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returncount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询数组中的最大数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxNum</span><span class="params">(<span class="type">int</span> *p, intn)</span></span><br><span class="line">&#123;</span><br><span class="line">    inti;</span><br><span class="line">    intmax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*(p + i) &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = *(p + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将数字分配到各自的桶中，然后按照桶的顺序输出排序结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort2</span><span class="params">(<span class="type">int</span> *p, intn, intloop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建立一组桶此处的20是预设的根据实际数情况修改</span></span><br><span class="line">    intbuckets[<span class="number">10</span>][<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//求桶的index的除数</span></span><br><span class="line">    <span class="comment">//如798个位桶index=(798/1)%10=8</span></span><br><span class="line">    <span class="comment">//十位桶index=(798/10)%10=9</span></span><br><span class="line">    <span class="comment">//百位桶index=(798/100)%10=7</span></span><br><span class="line">    <span class="comment">//tempNum为上式中的1、10、100</span></span><br><span class="line">    inttempNum = (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, loop - <span class="number">1</span>);</span><br><span class="line">    inti, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        introw_index = (*(p + i) / tempNum) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[row_index][j] == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buckets[row_index][j] = *(p + i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将桶中的数，倒回到原有数组中</span></span><br><span class="line">    intk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i][j] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *(p + k) = buckets[i][j];</span><br><span class="line">                buckets[i][j] = <span class="literal">NULL</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/dataStructureSort.webp" alt=" comparison "></p>
<h2 id="应试"><a href="#应试" class="headerlink" title="应试"></a>应试</h2><h3 id="概述作业"><a href="#概述作业" class="headerlink" title="概述作业"></a>概述作业</h3><blockquote>
<p>数据在计算机内存中的表示是指（） 。数据的存储结构</p>
<p>数据结构形式地定义为（K，R），其中K是（）的有限集合，R是K上的关系上的有限集合。数据元素</p>
<p>数据结构形式地定义为（D,S），其中D是数据元素的有限集合，S是D上的（）的有限集合。关系</p>
<p>一个广义表的表尾总是一个（ ）。广义表</p>
</blockquote>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><blockquote>
<p>对于线性表的各种操作，考虑：</p>
<ol>
<li>length与MaxSize的关系</li>
<li>length是否为零</li>
<li>输入的参数是否符合规则（大于或小于零，是否为空）</li>
</ol>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote>
<p>对于栈的各种操作，考虑：</p>
<ol>
<li>栈空或栈满的情况</li>
<li>输入的参数是否符合规则（大于或小于零，是否为空）</li>
</ol>
</blockquote>
<ul>
<li>后缀表达式</li>
</ul>
<blockquote>
<p>从左往右开始扫描中缀表达式。<br>        遇到数字直接加入后缀表达式<br>        遇到运算符时：<br>            a.若为’(‘则入栈<br>            b.若为’)’，则依次把栈中的运算符加入后缀表达式，直到出现’(’，从栈中删除’)’。<br>            c.若为除括号外的其他运算符，当其他优先级高于除’)’外的栈顶运算符时，直接入栈。<br>        否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，<br>        直到一个比它优先级低的或遇到了一个左括号为止。</p>
</blockquote>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><blockquote>
<p>对于队列的各种操作，考虑：</p>
<ol>
<li>队列空和满的情况</li>
<li>输入的参数是否符合规则（大于或小于零，是否为空）</li>
</ol>
</blockquote>
<h3 id="图-1"><a href="#图-1" class="headerlink" title="图"></a>图</h3><blockquote>
<p>用邻接矩阵表示有N个结点E条边的图时，深度优先遍历算法的时间复杂度是：C.O(N2)</p>
</blockquote>
<h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><blockquote>
<p> 下列关于栈的叙述中，错误的是：</p>
<ol>
<li><strong>采用非递归方式重写递归程序时必须使用栈</strong></li>
<li>函数调用时，系统要用栈保存必要的信息</li>
<li><strong>只要确定了入栈次序，即可确定出栈次序</strong></li>
<li><strong>栈是一种受限的线性表，允许在其两端进行操作</strong></li>
</ol>
</blockquote>
<blockquote>
<p> 最不适合用作栈的链表是（）。</p>
<p>A.只有表头指针没有表尾指针的循环双链表</p>
<p>B.只有表尾指针没有表头指针的循环双链表</p>
<p>C.只有表尾指针没有表头指针的循环单链表</p>
<p>D.<strong>只有表头指针没有表尾指针的循环单链表</strong></p>
</blockquote>
<blockquote>
<p> 下列关于栈的叙述中，错误的是：</p>
<ol>
<li>采用非递归方式重写递归程序时必须使用栈</li>
<li>函数调用时，系统要用栈保存必要的信息</li>
<li>只要确定了入栈次序，即可确定出栈次序</li>
<li>栈是一种受限的线性表，允许在其两端进行操作</li>
</ol>
<p> A.仅 1</p>
<p> B.仅 1、2、3</p>
<p> **C.**仅 1、3、4</p>
<p> D.仅 2、3、4</p>
<p> 循环队列的引入是为了（ ）。克服假溢出</p>
</blockquote>
<h3 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h3><blockquote>
<p>树的后序遍历与其对应的二叉树的哪种遍历相同？中序</p>
<p>森林的中序遍历与对应二叉树的什么遍历序列相同？中序</p>
</blockquote>
<h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>有组记录的排序码为{ 46，79，56，38，40，84 }，则利用堆排序的方法建立的初始堆为：</p>
<p>84，79，56，38，40，46</p>
</blockquote>
<blockquote>
<p>下面四种排序算法中，稳定的算法是：归并排序</p>
</blockquote>
<blockquote>
<p>快速排序下列排序算法中，时间复杂度不受数据初始状态影响，恒为O(NlogN)的是：</p>
<p>堆排序</p>
</blockquote>
<blockquote>
<p>对N个记录进行快速排序，在最坏的情况下，其时间复杂度是：</p>
<p>O(N2)</p>
</blockquote>
<blockquote>
<p>下列关键码序列中，属于堆的是（ 　）。</p>
<p>（15，30，22，93，52，71）</p>
</blockquote>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Data-Structure-and-Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>GIT basic</title>
    <url>/2023/11/26/GIT-basic/</url>
    <content><![CDATA[<h1 id="Git-以及github，gitee的使用"><a href="#Git-以及github，gitee的使用" class="headerlink" title="Git 以及github，gitee的使用"></a>Git 以及github，gitee的使用</h1><h2 id="git简介："><a href="#git简介：" class="headerlink" title="git简介："></a>git简介：</h2><blockquote>
<p>Git (&#x2F;ɡɪt&#x2F;) is a distributed version control system that tracks changes in any set of computer files, usually used for coordinating work among programmers who are collaboratively developing source code during software development. Its goals include speed, data integrity, and support for distributed, non-linear workflows (thousands of parallel branches running on different computers).</p>
</blockquote>
<h2 id="What-is-Git"><a href="#What-is-Git" class="headerlink" title="What is Git?"></a><strong>What is Git?</strong></h2><p>Git is a popular version control system. It was created by Linus Torvalds in 2005, and has been maintained by Junio Hamano since then.</p>
<p>It is used for:</p>
<p>Tracking code changes<br>Tracking who made changes<br>Coding collaboration</p>
<h2 id="What-does-Git-do"><a href="#What-does-Git-do" class="headerlink" title="What does Git do?"></a><strong>What does Git do?</strong></h2><p>Manage projects with <strong>Repositories</strong><br><strong>Clone</strong> a project to work on a local copy<br><strong>Control and track</strong> changes with <strong>Staging and Committing</strong><br><strong>Branch and Merge</strong> to allow for work on different parts and versions of a project<br><strong>Pull</strong> the latest version of the project to a local copy<br><strong>Push</strong> local updates to the main project</p>
<h2 id="Working-with-Git"><a href="#Working-with-Git" class="headerlink" title="Working with Git"></a><strong>Working with Git</strong></h2><p>Initialize Git on a folder, making it a Repository<br>Git now creates a hidden folder to keep track of changes in that folder<br>When a file is changed, added or deleted, it is considered modified<br>You select the modified files you want to Stage<br>The Staged files are Committed, which prompts Git to store a permanent snapshot of the files<br>Git allows you to see the full history of every commit.<br>You can revert back to any previous commit.<br>Git does not store a separate copy of every file in every commit, but keeps track of changes made in each commit!<br>Change Platform:</p>
<p>Shift focus to GitHubGitHub<br>Shift focus to BitbucketBitbucket<br>Shift focus to GitLabGitLab</p>
<h2 id="Why-Git"><a href="#Why-Git" class="headerlink" title="Why Git?"></a><strong>Why Git?</strong></h2><p>Over 70% of developers use Git!<br>Developers can work together from anywhere in the world.<br>Developers can see the full history of the project.<br>Developers can revert to earlier versions of a project.</p>
<h2 id="What-is-GitHub"><a href="#What-is-GitHub" class="headerlink" title="What is GitHub?"></a><strong>What is GitHub?</strong></h2><p>Git is not the same as GitHub.<br>GitHub makes tools that use Git.<br>GitHub is the largest host of source code in the world, and has been owned by Microsoft since 2018.<br>In this tutorial, we will focus on using Git with GitHub.</p>
<p><strong>git 有图形化界面（gui）和命令行（bash），这里仅使用git命令行，即git（bash）。</strong></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><h4 id="check-git-version-and-info"><a href="#check-git-version-and-info" class="headerlink" title="check git version and info"></a>check git version and info</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git —version</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="configure-git"><a href="#configure-git" class="headerlink" title="configure git"></a>configure git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;xxxxx&quot;</span>    <span class="comment"># global means all the repos are in charge</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxxxxxxxx@gmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if you just want to use “regen” for just once , you can remove “—global”</span></span><br><span class="line"></span><br><span class="line">git config  user.name <span class="string">&quot;regen&quot;</span>    </span><br><span class="line">git config  user.email <span class="string">&quot;regenissb@gmail.com&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="initialize-you-repo"><a href="#initialize-you-repo" class="headerlink" title="initialize you repo"></a>initialize you repo</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#use mkdir and cd to create you working file . Then</span></span><br><span class="line"></span><br><span class="line">git init  </span><br><span class="line"></span><br><span class="line"><span class="comment"># This file is initialized as a git repository from now on . You can make files.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> hello.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="file-operation"><a href="#file-operation" class="headerlink" title="file operation"></a>file operation</h3><ol>
<li>check file status<br>Files in the repo has 2 status:<ul>
<li>Tracked - files that Git knows about and are added to the repository</li>
<li>Untracked - files that are in your working directory, but not added to the repository</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>​		or you can use </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status --short</span><br><span class="line"><span class="comment">#  Note: Short status flags are:</span></span><br><span class="line"><span class="comment">#    ?? - Untracked files</span></span><br><span class="line"><span class="comment">#    A - Files added to stage</span></span><br><span class="line"><span class="comment">#    M - Modified files</span></span><br><span class="line"><span class="comment">#    D - Deleted files</span></span><br></pre></td></tr></table></figure>







<ol start="2">
<li>add to stage environment</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># once you finish a part or a bug ,you need to add it to  stage environment. So that you files in the stage environment are ready to commit .</span></span><br><span class="line"></span><br><span class="line">git add hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># or you can use </span></span><br><span class="line">git add —all</span><br><span class="line">git add -A</span><br><span class="line"><span class="comment"># this two commends stages all the changes .  </span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>move from  stage to <strong>commit</strong> for our repo.</li>
</ol>
<ul>
<li>commit all the changes</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;First release of Hello World!&quot;</span></span><br><span class="line"><span class="comment"># The commit command performs a commit, and the -m &quot;message&quot; adds a message.</span></span><br><span class="line"><span class="comment"># When we commit, we should always include a message.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>commit all the changes without add them to stage</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m <span class="string">&quot;Updated index.html with a new line&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>view the history of commit log</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h2 id="GIT-branch"><a href="#GIT-branch" class="headerlink" title="GIT branch"></a><strong>GIT branch</strong></h2><p>​	Introduction :</p>
<blockquote>
<p>In Git, a <code>branch</code> is a new&#x2F;separate version of the main repository.</p>
<p>Branches allow you to work on different parts of a project without impacting the main branch.</p>
<p>When the work is complete, a branch can be merged with the main project.</p>
<p>You can even switch between branches and work on different projects without them interfering with each other.</p>
<p>Branching in Git is very lightweight and fast!</p>
</blockquote>
<h4 id="create-new-git-branch"><a href="#create-new-git-branch" class="headerlink" title="create new git branch"></a>create new git branch</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch newBranch</span><br><span class="line">  <span class="comment"># add a new branch</span></span><br></pre></td></tr></table></figure>

<h4 id="check-out-the-branches"><a href="#check-out-the-branches" class="headerlink" title="check out the branches"></a>check out the branches</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line"></span><br><span class="line">    newBtanch</span><br><span class="line">  * master</span><br><span class="line"><span class="comment"># The &#x27; * &#x27;means that you are working on master branch.</span></span><br></pre></td></tr></table></figure>

<h4 id="move-branch"><a href="#move-branch" class="headerlink" title="move branch"></a>move branch</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout newbranch     <span class="comment"># switch to new branch &#x27;newBranch&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="check-status-of-this-branch-add-to-stage-and-commit-same-code"><a href="#check-status-of-this-branch-add-to-stage-and-commit-same-code" class="headerlink" title="check status of this branch , add to stage and commit . (same code)"></a>check status of this branch , add to stage and commit . (same code)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add --all</span><br><span class="line">git commit -m <span class="string">&quot;new changes in branch newBranch&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="merge-branch"><a href="#merge-branch" class="headerlink" title="merge branch"></a>merge branch</h4><ol>
<li>In order to merge two branches, we need to change to the master branch:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>merge</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge newBranch</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>delete branches</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d newBranch</span><br></pre></td></tr></table></figure>

<ul>
<li>merge conflict</li>
</ul>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a><strong>其他操作</strong></h2><ul>
<li>GIT Associating a local repository to a remote repository</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:regen/test.git</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><h3 id="多个设备同一账号，在不同的场景使用github同步代码。"><a href="#多个设备同一账号，在不同的场景使用github同步代码。" class="headerlink" title="多个设备同一账号，在不同的场景使用github同步代码。"></a>多个设备同一账号，在不同的场景使用github同步代码。</h3><h4 id="终端"><a href="#终端" class="headerlink" title="终端:"></a>终端:</h4><h5 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置用户</span></span><br><span class="line">git config --global user.name <span class="string">&quot;xxxxx&quot;</span>    <span class="comment"># global means all the repos are in charge</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxxxxxxxx@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="github添加ssh公钥匙"><a href="#github添加ssh公钥匙" class="headerlink" title="github添加ssh公钥匙"></a>github添加ssh公钥匙</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxxxxxx@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>将生成的rsq_pub中的内容复制到github里的ssh栏</p>
<h5 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h5><ul>
<li>复制仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:regenm/Notes.git</span><br></pre></td></tr></table></figure>

<ul>
<li>修改前更新</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<ul>
<li>修改后上传</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;add an application of git&quot;</span></span><br><span class="line">git status</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<h3 id="不同账号使用同一仓库"><a href="#不同账号使用同一仓库" class="headerlink" title="不同账号使用同一仓库"></a>不同账号使用同一仓库</h3><h4 id="场景一：参加开源项目-使用Fork"><a href="#场景一：参加开源项目-使用Fork" class="headerlink" title="场景一：参加开源项目( 使用Fork )"></a>场景一：参加开源项目( 使用Fork )</h4><p>​	当你想参与不属于你的开源项目时，通常使用Fork。你没有直接对原始仓库的写权限，但可以通过Fork和Pull Request来贡献代码。</p>
<h5 id="使用流程："><a href="#使用流程：" class="headerlink" title="使用流程："></a>使用流程：</h5><ol>
<li><strong>Fork仓库</strong>：将原始仓库复制到你自己的GitHub账户中。</li>
<li><strong>克隆仓库</strong>：将Fork后的仓库克隆到本地进行开发。</li>
<li><strong>开发和提交</strong>：在本地开发，提交代码到你Fork的仓库。</li>
<li><strong>推送分支</strong>：将代码推送到你Fork的GitHub仓库。</li>
<li><strong>Pull Request</strong>：创建Pull Request，请求将你的修改合并到原始仓库。</li>
</ol>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li><strong>隔离开发</strong>：你的改动不会直接影响原始仓库，确保了独立开发的安全性。</li>
<li><strong>贡献流程</strong>：通过Pull Request进行代码评审，确保代码质量和一致性。</li>
</ul>
<h4 id="场景二：团队开发项目-使用SSH密钥"><a href="#场景二：团队开发项目-使用SSH密钥" class="headerlink" title="场景二：团队开发项目 ( 使用SSH密钥 )"></a>场景二：团队开发项目 ( 使用SSH密钥 )</h4><p>​	<strong>私有项目</strong>：当你与团队成员协作开发私有项目时，使用SSH密钥来管理对远程仓库的访问权限。</p>
<p>​	<strong>团队协作</strong>：在团队内部，每个成员都有对仓库的读写权限，可以直接推送代码到远程仓库。</p>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><ol>
<li><strong>生成SSH密钥</strong>：每个团队成员生成SSH密钥。</li>
<li><strong>添加SSH密钥</strong>：将生成的公钥添加到自己的GitHub账户中。</li>
<li><strong>邀请协作者</strong>：仓库管理员邀请团队成员成为协作者，并分配适当的权限。</li>
<li><strong>克隆仓库</strong>：团队成员使用SSH克隆仓库到本地进行开发。</li>
<li><strong>开发和提交</strong>：在本地开发，提交代码。</li>
<li><strong>推送分支</strong>：将代码直接推送到远程仓库。</li>
</ol>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li><strong>直接协作</strong>：团队成员可以直接推送和拉取代码，适合高效的团队协作。</li>
<li><strong>安全性</strong>：SSH密钥提供了安全的身份验证机制。</li>
</ul>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Projects</title>
    <url>/2023/11/28/Linux-Projects/</url>
    <content><![CDATA[<p>​	以下项目都是我在已经完成之后补录的笔记，包括但不限于遇到的报错，问题。便于以后复现。实际上不能说是项目，仅仅是复现并且享受大佬的成果而已。开源不易，感谢大佬们开源！</p>
<h1 id="ZeroTier-内网穿透"><a href="#ZeroTier-内网穿透" class="headerlink" title="ZeroTier 内网穿透"></a>ZeroTier 内网穿透</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>​	官网：<a href="https://www.zerotier.com/">ZeroTier</a></p>
<blockquote>
<p><strong>ZeroTier Client :</strong></p>
<p>The ZeroTier client is used to connect to virtual networks previously created in the ZeroTier Central web-based <a href="https://en.wikipedia.org/wiki/User_interface">UI</a>. Endpoint connections are peer-to-peer and <a href="https://en.wikipedia.org/wiki/End-to-end_encryption">end-to-end encrypted</a>. <a href="https://en.wikipedia.org/wiki/STUN">STUN</a> and <a href="https://en.wikipedia.org/wiki/Hole_punching_(networking)">hole punching</a> are used to establish direct connections between peers behind <a href="https://en.wikipedia.org/wiki/Network_Address_Translation">NAT</a>. Direct connection route discovery is made with the help of a global network of <em>root servers</em> via a mechanism similar to <a href="https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment">ICE</a> in <a href="https://en.wikipedia.org/wiki/WebRTC">WebRTC</a>.</p>
</blockquote>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><p>​		实际上十分简单，对于Windows，iPad，Android，macOS都有相应软件。</p>
<p><img src="/images/ZeroTIerDownload.png"></p>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ol>
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://install.zerotier.com | sudo bash</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>操作：加入，离开，查看已经连接的网络</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-cli <span class="built_in">join</span> &lt;NETWORK ID&gt;</span><br><span class="line"><span class="comment">#加入</span></span><br><span class="line">zerotier-cli leave &lt;NETWORK ID&gt;</span><br><span class="line"><span class="comment">#离开</span></span><br><span class="line">zerotier-cli listnetworks</span><br><span class="line"><span class="comment">#连接列表</span></span><br></pre></td></tr></table></figure>

<h2 id="3-管理"><a href="#3-管理" class="headerlink" title="3.管理"></a>3.管理</h2><p>​	直接登录官网即可进行对已组网络的管理，例如授权用户，修改网络内部IP地址以及备注信息等等</p>
<p><img src="/images/ZeroTierAdmin.jpg" alt="Admin Page"></p>
<h2 id="4-Last"><a href="#4-Last" class="headerlink" title="4.Last"></a>4.Last</h2><p>​	世上还是好人多啊，ZeroTier的出现真的让内网穿透方便了很多，免费用户的配置也很不错！</p>
<h1 id="FTP-服务器搭建"><a href="#FTP-服务器搭建" class="headerlink" title="FTP 服务器搭建"></a>FTP 服务器搭建</h1><h1 id="MQTT服务器搭建（mosquitto）"><a href="#MQTT服务器搭建（mosquitto）" class="headerlink" title="MQTT服务器搭建（mosquitto）"></a>MQTT服务器搭建（mosquitto）</h1><h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0.简介"></a>0.简介</h2><ol>
<li>简介</li>
</ol>
<blockquote>
<p>MQTT也称为”消息代理”（Broker）。</p>
<p>MQTT是一个基于客户端-服务器的消息发布&#x2F;订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
</blockquote>
<ol start="2">
<li>原理</li>
</ol>
<blockquote>
<p>MQTT协议原理<br>MQTT协议实现方式<br>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p>
<p>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）</p>
<p>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</p>
</blockquote>
<h2 id="1-mosquitto-服务端"><a href="#1-mosquitto-服务端" class="headerlink" title="1. mosquitto 服务端"></a>1. mosquitto 服务端</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install mosquitto</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/mosquitto</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件</li>
</ul>
<p>​				在 <strong>&#x2F;etc&#x2F;mosquitto&#x2F;conf.d</strong>目录下有一个叫 README 的文件，上面写了信息：</p>
<blockquote>
<h1 id="Any-files-placed-in-this-directory-that-have-a-conf-ending-will-be-loaded-as-config-files-by-the-broker-Use-this-to-make-your-local-config"><a href="#Any-files-placed-in-this-directory-that-have-a-conf-ending-will-be-loaded-as-config-files-by-the-broker-Use-this-to-make-your-local-config" class="headerlink" title="Any files placed in this directory that have a .conf ending will be loaded as config files by the broker. Use this to make your local config."></a>Any files placed in this directory that have a .conf ending will be loaded as config files by the broker. Use this to make your local config.</h1></blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/mosquitto/conf.d</span><br><span class="line"></span><br><span class="line">vim config.conf</span><br><span class="line"><span class="comment"># 添加下面配置</span></span><br><span class="line"><span class="comment"># 不允许匿名访问</span></span><br><span class="line">allow_anonymous <span class="literal">false</span></span><br><span class="line"><span class="comment"># 配置端口</span></span><br><span class="line">listener 1883</span><br><span class="line"><span class="comment"># 设置密码文件保存目录</span></span><br><span class="line">password_file /etc/mosquitto/pwfile.example</span><br></pre></td></tr></table></figure>

<ul>
<li>运行配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mosquitto -c /etc/mosquitto/conf.d/config.conf -v</span><br></pre></td></tr></table></figure>

<ul>
<li>添加用户</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mosquitto_passwd -c /etc/mosquitto/pwfile.example username</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关闭防火墙！！！</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ufw <span class="built_in">disable</span></span><br><span class="line"><span class="comment"># 或者添加规则</span></span><br><span class="line">ufw allow 1883</span><br></pre></td></tr></table></figure>

<h2 id="2-mosquitto-clients-客户端"><a href="#2-mosquitto-clients-客户端" class="headerlink" title="2. mosquitto-clients 客户端"></a>2. mosquitto-clients 客户端</h2><ul>
<li>用户登录订阅，发布</li>
</ul>
<p>​	其实一般都是接近被控设备的系统，比如各种Mcu（esp32，esp8266）等等。这部分将在寒假进行补充（在另外一篇博客）。<a href="https://regenm.gitee.io/">esp8266或者esp32等</a></p>
<p>对于Linux客户，可以是模拟器（ ISH ，Termux）</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install mosquitto-clients</span><br></pre></td></tr></table></figure>

<ul>
<li>订阅</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mosquitto_sub -h <span class="string">&quot;IP address&quot;</span> -p 1883 -u username -P regen -t <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>发布</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mosquitto_pub -h <span class="string">&quot;IP address&quot;</span> -p 1883 -u username -P regen -t <span class="string">&quot;test&quot;</span> -m <span class="string">&quot;hello mqtt! hello ! mosquitto!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-mosquitto使用"><a href="#3-mosquitto使用" class="headerlink" title="3. mosquitto使用"></a>3. mosquitto使用</h2><ul>
<li><strong>脚本制作</strong></li>
</ul>
<p>​				为了方便 mosquitto 的使用，可以写几个脚本用于发布和订阅</p>
<ol>
<li>发布</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim regenMosquittoScriptSendRemote.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mosquitto_pub -h <span class="string">&quot;IP address&quot;</span> -p 1883 -u username -P regen -t <span class="string">&quot;test&quot;</span> -m <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	赋权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 regenMosquittoScriptSendRemote.sh</span><br></pre></td></tr></table></figure>

<p>​	运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./regenMosquittoScriptSendRemote.sh hello!</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>订阅，同理</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim regenMosquittoScriptSubRemote.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mosquitto_sub -h <span class="string">&quot;IP address&quot;</span> -p 1883 -u username -P regen -t <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	赋权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 regenMosquittoScriptSubRemote.sh</span><br></pre></td></tr></table></figure>

<p>​	运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./regenMosquittoScriptSendRemote.sh topic</span><br></pre></td></tr></table></figure>

<ul>
<li>连接esp32或8266</li>
</ul>
<h1 id="VPN隧道搭建"><a href="#VPN隧道搭建" class="headerlink" title="VPN隧道搭建"></a>VPN隧道搭建</h1><h2 id="1-协议选择-V2RAY的VMess协议"><a href="#1-协议选择-V2RAY的VMess协议" class="headerlink" title="1.协议选择 V2RAY的VMess协议"></a>1.协议选择 V2RAY的VMess协议</h2><h2 id="2-一键安装脚本-：v2ray-sh"><a href="#2-一键安装脚本-：v2ray-sh" class="headerlink" title="2.一键安装脚本 ：v2ray.sh"></a>2.一键安装脚本 ：v2ray.sh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su root</span><br><span class="line"></span><br><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure>

<h2 id="3-查看信息"><a href="#3-查看信息" class="headerlink" title="3.查看信息"></a>3.查看信息</h2><p>信息目录：<code> /etc/v2ray/config.json</code></p>
<h1 id="自建服务器（搭配ZeroTier食用）"><a href="#自建服务器（搭配ZeroTier食用）" class="headerlink" title="自建服务器（搭配ZeroTier食用）"></a>自建服务器（搭配ZeroTier食用）</h1><h2 id="1-begin"><a href="#1-begin" class="headerlink" title="1. begin"></a>1. begin</h2><p>​	虽然和hxy合伙买的白菜价国外服务器性能也还够用，但是也仅仅是够用，之前发现的内网穿透神器Zerotier刚好可以拿来当我的梦中情机的最后一块拼图。使用ZeroTier就可以让我方便的在SH连接到JX的家中局域网内的服务器了！</p>
<h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><h3 id="1-硬件介绍"><a href="#1-硬件介绍" class="headerlink" title="1.硬件介绍"></a>1.硬件介绍</h3><p>​			硬件部分的清单：</p>
<blockquote>
<p>CPU : E3 1230 v2 (4核8线，3.3ghz)</p>
<p>显卡 ： gt610 	（亮机即可，且低功耗）</p>
<p>内存：8g</p>
<p>外存：240（固态）+500（机械）</p>
</blockquote>
<h3 id="2-软件介绍"><a href="#2-软件介绍" class="headerlink" title="2.软件介绍"></a>2.软件介绍</h3><p>​		由于我正在使用的pc中恰好有四个下载好的镜像文件，分别是 macOS.Ventura_13.4 , deepin ，ubuntu22.04，kali2023，最终使用的是kali,原因在于kali已经安装好绝大部分软件和其需运行的环境，例如：httpd，JDK，javarun，makefile等等。</p>
<h2 id="3-组装（跳过）"><a href="#3-组装（跳过）" class="headerlink" title="3.组装（跳过）"></a>3.组装（跳过）</h2><h2 id="4-配置ZeroTier-如上篇ZeroTier内网穿透"><a href="#4-配置ZeroTier-如上篇ZeroTier内网穿透" class="headerlink" title="4.配置ZeroTier(如上篇ZeroTier内网穿透)"></a>4.配置ZeroTier(如上篇ZeroTier内网穿透)</h2><h2 id="5-结束"><a href="#5-结束" class="headerlink" title="5.结束"></a>5.结束</h2><p>最终效果，通过ipad的终端ssh外网连接kali</p>
<p><img src="/images/ipadConnectKali.jpg" alt="ipadConnectKali"></p>
<h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><h2 id="1-make简要介绍"><a href="#1-make简要介绍" class="headerlink" title="1.make简要介绍"></a>1.make简要介绍</h2><blockquote>
<p>​	In <a href="https://en.wikipedia.org/wiki/Software_development">software development</a>, <strong>Make</strong> is a <a href="https://en.wikipedia.org/wiki/Build_automation">build automation</a> tool that <a href="https://en.wikipedia.org/wiki/Software_build">builds</a> <a href="https://en.wikipedia.org/wiki/Executable_program">executable programs</a> and <a href="https://en.wikipedia.org/wiki/Library_(software)">libraries</a> from <a href="https://en.wikipedia.org/wiki/Source_code">source code</a> by reading <a href="https://en.wikipedia.org/wiki/File_(computing)">files</a> called <em>makefiles</em> which specify how to derive the target program. Though <a href="https://en.wikipedia.org/wiki/Integrated_development_environment">integrated development environments</a> and <a href="https://en.wikipedia.org/wiki/Programming_language">language</a>-specific <a href="https://en.wikipedia.org/wiki/Compiler_(computing)">compiler</a> features can also be used to manage a build process, Make remains widely used, especially in <a href="https://en.wikipedia.org/wiki/Unix">Unix</a> and <a href="https://en.wikipedia.org/wiki/Unix-like">Unix-like</a> <a href="https://en.wikipedia.org/wiki/Operating_system">operating systems</a>.</p>
</blockquote>
<blockquote>
<p>​	Make is not limited to building programs. It can also be used to manage any project where some files need to be updated automatically from other files whenever the other files change.</p>
</blockquote>
<h2 id="2-makefile简要介绍"><a href="#2-makefile简要介绍" class="headerlink" title="2.makefile简要介绍"></a>2.makefile简要介绍</h2><p>​	makefile文件用于告诉make命令如何执行编译和链接。</p>
<p>​	当一个文件具有很多个.c文件和.h文件时，如果将makefile写好了，就只需要一行代码<code>make</code>即可完成编译链接或者<code>make clean</code>删除所有目标文件，同时还能具备以下特性：</p>
<blockquote>
<p>​      1.如果这个工程没有编译过，那么所有C文件都会编译并被链接。</p>
<p>​      2.如果这个工程的某几个C文件被修改，那么只编译被修改的C文件，并链接目标程序。</p>
<p>​      3.如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p>
</blockquote>
<h2 id="3-makefile的规则"><a href="#3-makefile的规则" class="headerlink" title="3.makefile的规则"></a>3.makefile的规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line"></span><br><span class="line">         command</span><br><span class="line"></span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line">         ...</span><br><span class="line">        -------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li>target : 目标文件（可以使object文件，可执行文件，还可以是<strong>标签</strong>）</li>
<li>prerequisites ：生成target所需要的文件或是目标。</li>
<li>command也就是make需要执行的命令。（Shell命令）</li>
</ul>
<h2 id="4-makefile的使用"><a href="#4-makefile的使用" class="headerlink" title="4.makefile的使用"></a>4.makefile的使用</h2><p>​	makefile的规则看似十分简单，但是写好一个makefile却是不简单的。下面举例说明&#96;&#96;&#96;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#假设已经存在3个c文件，4个.h文件，分别是:</span></span><br><span class="line">cFile1.c cFile2.c cFile3.c</span><br><span class="line">hFile1.h hFile2.h hFile3.h hFile4.h</span><br></pre></td></tr></table></figure>

<p>​		如果我们最终想要生成可执行文件main，那么makefile可以这样写，以下是我使用在线makefile生成器生成的。</p>
<p>​		同时介绍一下gcc的参数：</p>
<blockquote>
<ul>
<li><p>-g可执行程序包含调试信息<br>-g为了调试用的<br>加个-g 是为了gdb 用，不然gdb用不到</p>
</li>
<li><p>-o指定输出文件名<br>-o output_filename，确定输出文件的名称为output_filename，同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出</p>
</li>
<li><p>-c 只编译不链接<br>产生.o文件，就是obj文件，不产生执行文件</p>
</li>
<li><p>-D 其意义是添加宏定义</p>
</li>
<li><p>-w的意思是关闭编译时的警告，也就是编译后不显示任何warning，因为有时在编译之后编译器会显示一些例如数据转换之类的警告，这些警告是我们平时可以忽略的。</p>
</li>
<li><p>-W选项类似-Wall，会显示警告，但是只显示编译器认为会出现错误的警告。</p>
</li>
<li><p>-Wall选项意思是编译后显示所有警告</p>
</li>
</ul>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to execute this &quot;Makefile&quot; just type &quot;make&quot;</span></span><br><span class="line"><span class="comment">#  A. Delis (ad@di.uoa.gr)</span></span><br><span class="line"><span class="comment"># web: https://solver.assistedcoding.eu/makefilegen</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">OBJS  = cFile1.o cFile2.o cFile3.o</span><br><span class="line">SOURCE  = cFile1.c cFile2.c cFile3.c</span><br><span class="line">HEADER  = hFile1.h hFile2.h hFile3.h hFile4.h</span><br><span class="line">OUT  = main.out</span><br><span class="line">CC   = gcc</span><br><span class="line">FLAGS   = -g -c -Wall				 </span><br><span class="line">LFLAGS   = </span><br><span class="line"><span class="comment"># -g option enables debugging mode </span></span><br><span class="line"><span class="comment"># -c flag generates object code for separate files</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OBJS)</span></span></span><br><span class="line">  <span class="variable">$(CC)</span> -g <span class="variable">$(OBJS)</span> -o <span class="variable">$(OUT)</span> <span class="variable">$(LFLAGS)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># create/compile the individual files &gt;&gt;separately&lt;&lt;</span></span><br><span class="line"><span class="section">cFile1.o: cFile1.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(FLAGS)</span> cFile1.c -lcunit</span><br><span class="line"></span><br><span class="line"><span class="section">cFile2.o: cFile2.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(FLAGS)</span> cFile2.c -lcunit</span><br><span class="line"></span><br><span class="line"><span class="section">cFile3.o: cFile3.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(FLAGS)</span> cFile3.c -lcunit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean house</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">  rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(OUT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run the program</span></span><br><span class="line"><span class="section">run: <span class="variable">$(OUT)</span></span></span><br><span class="line">  ./<span class="variable">$(OUT)</span></span><br></pre></td></tr></table></figure>



<h1 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h1><h2 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1. 简要介绍"></a>1. 简要介绍</h2><blockquote>
<p>From Wikipedia, the free encyclopedia</p>
<p>In <a href="https://en.wikipedia.org/wiki/Software_development">software development</a>, <strong>CMake</strong> is <a href="https://en.wikipedia.org/wiki/Cross-platform">cross-platform</a> <a href="https://en.wikipedia.org/wiki/Free_and_open-source_software">free and open-source software</a> for <a href="https://en.wikipedia.org/wiki/Build_automation">build automation</a>, <a href="https://en.wikipedia.org/wiki/Software_testing">testing</a>, <a href="https://en.wikipedia.org/wiki/Package_(package_management_system)">packaging</a> and <a href="https://en.wikipedia.org/wiki/Installation_(computer_programs)">installation</a> of software by using a <a href="https://en.wikipedia.org/wiki/Compiler">compiler</a>-independent method.[<a href="https://en.wikipedia.org/wiki/CMake#cite_note-3">3]</a> CMake is not a build system itself; it generates another system’s build files.[<a href="https://en.wikipedia.org/wiki/CMake#cite_note-:1-4">4]</a> It supports directory hierarchies and applications that depend on multiple libraries. It can invoke native build environments such as <a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a>, <a href="https://en.wikipedia.org/wiki/Qt_Creator">Qt Creator</a>, <a href="https://en.wikipedia.org/wiki/Ninja_(build_system)">Ninja</a>, <a href="https://en.wikipedia.org/wiki/Android_Studio">Android Studio</a>, Apple’s <a href="https://en.wikipedia.org/wiki/Xcode">Xcode</a>, and <a href="https://en.wikipedia.org/wiki/Microsoft_Visual_Studio">Microsoft Visual Studio</a>.[<a href="https://en.wikipedia.org/wiki/CMake#cite_note-:1-4">4]</a> It has minimal dependencies, requiring only a <a href="https://en.wikipedia.org/wiki/C%2B%2B">C++</a> compiler on its own build system.[<a href="https://en.wikipedia.org/wiki/CMake#cite_note-:1-4">4]</a></p>
<p>CMake is distributed as <a href="https://en.wikipedia.org/wiki/Free_and_open-source_software">free and open-source software</a> under a permissive <a href="https://en.wikipedia.org/wiki/BSD_licenses">BSD-3-Clause</a> license.[<a href="https://en.wikipedia.org/wiki/CMake#cite_note-5"></a></p>
</blockquote>
<p>​	我的理解就是cmake是一款能够夸平台的生成makefile的工具，这样就不需要写复杂的makefile了。</p>
<h2 id="2-cmake使用"><a href="#2-cmake使用" class="headerlink" title="2.	cmake使用"></a>2.	cmake使用</h2><h3 id="1-使用流程"><a href="#1-使用流程" class="headerlink" title="1.使用流程"></a>1.使用流程</h3><pre><code>1. 在项目根目录下创建一个名为` CMakeLists.txt`的文件
</code></pre>
<ol start="2">
<li>编写该文件（当文件比较少的时候）</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)  <span class="comment"># 版本要求</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name</span></span><br><span class="line"><span class="keyword">project</span>(firstProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable（包括所有的用到的源文件）</span></span><br><span class="line"><span class="keyword">add_executable</span>(firstOut a.cpp b.cpp)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用cmake命令生成makefile</li>
</ol>
<ul>
<li>cmake命令的使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage</span><br><span class="line"></span><br><span class="line">  cmake [options] &lt;path-to-source&gt;</span><br><span class="line">  cmake [options] &lt;path-to-existing-build&gt;</span><br><span class="line">  cmake [options] -S &lt;path-to-source&gt; -B &lt;path-to-build&gt;</span><br><span class="line"></span><br><span class="line">Specify a <span class="built_in">source</span> directory to (re-)generate a build system <span class="keyword">for</span> it <span class="keyword">in</span> the</span><br><span class="line">current working directory.  Specify an existing build directory to</span><br><span class="line">re-generate its build system.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用make得到输出</li>
</ol>
<h3 id="2-单个源文件的项目"><a href="#2-单个源文件的项目" class="headerlink" title="2.单个源文件的项目"></a>2.单个源文件的项目</h3><ol>
<li>编写main.cpp</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写CMakeLists.txt</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name</span></span><br><span class="line"><span class="keyword">project</span>(firstProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(firstOut main.cpp)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建输出文件夹并且进行输出</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line">cmake -S . -B ./build/</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用make进行编译链接即可得到可执行文件<code>firstOut</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<h3 id="3-CMakeLists-txt-的写法"><a href="#3-CMakeLists-txt-的写法" class="headerlink" title="3. CMakeLists.txt 的写法"></a>3. CMakeLists.txt 的写法</h3><h4 id="1-使用set"><a href="#1-使用set" class="headerlink" title="1.使用set"></a>1.使用set</h4><ul>
<li>定义变量 <strong>set</strong> ，类型为字符串</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(outName[forstOut])</span><br></pre></td></tr></table></figure>

<ul>
<li>使用宏</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)         <span class="comment"># 指定c++标准的宏</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH   /home/regen/CMake/regen_1/build)<span class="comment"># 指定可执行文件的输出目录</span></span><br></pre></td></tr></table></figure>

<ul>
<li>取值</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;outName&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-文件搜索（便于源文件很多的情况）获取源文件名字"><a href="#2-文件搜索（便于源文件很多的情况）获取源文件名字" class="headerlink" title="2.文件搜索（便于源文件很多的情况）获取源文件名字"></a>2.文件搜索（便于源文件很多的情况）获取源文件名字</h4><p>​	建议将源文件放在独立的目录下，便于获取源文件名字。</p>
<ol>
<li>使用<code>aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</code></li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt; dir &gt; &lt; variable &gt;)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> SRC)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用file（用于应对很多源文件在不同目录的情况）</li>
</ol>
<ul>
<li>后缀搜索目录下所有源文件</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>头文件与源文件分开放的处理方法</li>
</ol>
<ul>
<li>使用宏</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headpath)</span><br></pre></td></tr></table></figure>





<h2 id="3-静态库和动态库"><a href="#3-静态库和动态库" class="headerlink" title="3.静态库和动态库"></a>3.静态库和动态库</h2><p>​	pause.打算在下次用到的时候补充</p>
<p>​                                </p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《丧钟为谁而鸣》</title>
    <url>/2023/12/02/%E3%80%8A%E4%B8%A7%E9%92%9F%E4%B8%BA%E8%B0%81%E8%80%8C%E9%B8%A3%E3%80%8B/</url>
    <content><![CDATA[<p><img src="/images/bookszwsrm.jpg" alt="丧钟为谁而鸣"></p>
<ul>
<li><p>这本书是Winston推荐的，其实我原本是想问问他给推荐几本简单易读的英文原著。回来一看，是一部长篇qwq，感觉读原著的话会有些吃力（英语水平有限: sigh :），于是就先读了翻译后的版本。看完以后久久不能释怀。</p>
</li>
<li><p>昨天深夜读完这本书，看看时间，恰好 2 : 00，合上眼，情节一幕幕复现在眼前，再过一个小时，皮拉尔就应该发现巴勃罗将罗伯托的起爆器和雷管偷走了。不知道如果巴勃罗没有偷走它们，又或者没有将它们扔下悬崖，罗伯托和巴塞尔默会不会能够活下去。巴塞尔默是那么热心肠，那么认真的令人尊敬的老人啊！不过死亡也许对他来说也是一种解脱吧。</p>
</li>
<li><p>在爱情上，我和罗伯托都是这样的人，在爱情上认为自己不会爱上别人，孑然一身，只是做着自己的事。然而他找到了小兔子玛利亚。在这样恐怖的栈帧中，能与她将往后余生的长相厮守浓缩为三天就已经十分幸运了不是吗？何必奢求永远。</p>
</li>
</ul>
<blockquote>
<p>“  你在要求不可能的事，你在要求绝不可能的事。所以，如果你真像你说的那样深爱这姑娘，那最好的，就是好好爱她，用尽全力，用浓烈填补这段关系中必将缺乏的长度与跨度。你听到了？过去，人们用一生的时间来做这件事。而现在，当你找到它，你得到两个夜晚，你会惊诧，这所有的幸运究竟从何而来。”</p>
<p>摘录来自<br>丧钟为谁而鸣(海明威代表作，普利策奖遗珠，海明威献给夫人玛莎·盖尔霍恩的定情之作)<br>厄尼斯特·海明威</p>
</blockquote>
<ul>
<li><p>人类似乎也遵循热力学第二定律，像化学反应一样，总是向着熵增的方向进行。战争带来了太多悲剧，太多遗憾。在看战争片和有关战争的书籍时，每每到有人逝去的情节时，眼角总是会不自觉的湿润。虽然我知道开始的各种暗示都意味着罗伯托会死，但是当他们炸桥成功任务完成时，我竟心怀一丝希望。就算罗伯托没死，战争确是无情的。历史上，有数不清的像罗伯托一样的人，将人类的和平与自由作为自己的信仰，至死不渝。这便是人性的光芒。</p>
</li>
<li><p>接下来就是读原著了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Projects</title>
    <url>/2023/12/07/Java-Projects/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《寂寞的游戏》</title>
    <url>/2023/12/24/%E3%80%8A%E5%AF%82%E5%AF%9E%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%8B/</url>
    <content><![CDATA[<h1 id="《寂寞的游戏》"><a href="#《寂寞的游戏》" class="headerlink" title="《寂寞的游戏》"></a>《寂寞的游戏》</h1><p><img src="/images/%E5%AF%82%E5%AF%9E%E7%9A%84%E6%B8%B8%E6%88%8F.jpg" alt="寂寞的游戏">	</p>
<p>​	<strong>其实</strong>，这本书我在2020年就看过一遍了，因为十分合拍的原因，还拍下了当时读书时的画面。当时就感受到了袁哲生先生的文字下的细腻，将一个敏感的青年通过笔墨绘于纸上。</p>
<p>​	<strong>那时</strong>，我刚刚升入高中，不曾想到进了高一的奥赛班，以为以我的适应能力能够立马就与同学打成一片，然而这个班的同学早已互相认识，只留少数几个像我一样对于新环境完全陌生的新人，不仅是交际上的原因，学业上也频频受挫。初中时的锐气与自信受到巨大的打击，于是便抓住文字这根救命稻草，以求在陌生而冷淡的环境汲取一丝慰藉。</p>
<p>​	<strong>文字</strong>，从未给过我失望，透过《寂寞的游戏》，我看到了一个像我一样的青年，借由他的经历，让我那时的无力感得到稍许减弱。</p>
<blockquote>
<p>“	我想，人天生就喜欢躲藏，</p>
<p>渴望消失，这是一点都不奇怪的事。	”</p>
<p>“	我就这样躲躲藏藏了许多年，直到有一天，捉迷藏的乐趣像一颗流星，眨眼就消失的无影无踪。	”</p>
</blockquote>
<p>​	这些细腻且真实的文字打动着我，让那时的我感动：我不是一个人，袁哲生先生也和我一样。</p>
<p><img src="/images/%E5%AF%82%E5%AF%9E%E7%9A%84%E6%B8%B8%E6%88%8F2.jpg" alt="2020 第一次读这本书就被吸引"></p>
<p>​	<strong>那时</strong>，图片中的有着斑马图案像条形码的马克杯还没碎。那是妈妈在外地别人家打工时，住在那里的姐姐托妈妈送给我的，杯子里还有一张写着QQ号码和昵称 Nancy 的纸条。依稀记得为了这个纸条找发小帮忙注册了一个QQ号。然而她没有同意我的申请添加，而后QQ号也给弄丢了。</p>
<p>​	<strong>再次</strong>，拿起这本书的原因是在市区的书架上看到，蓝色的书封，和我在那会同时看的《夜晚的潜水艇》有几分相似，在手指触碰到书的瞬间，那时的回忆涌现出来，那个茶杯，那本有淡淡香味的书，把我拉到过去，回过神来，同行的朋友早已不见。那晚，沉浸在过去回忆中的我，打开手机，下来了电子书看，那时我是这么热爱看书，而今双手却不离键盘手机。过去的我如果看到我这个模样，估计会因为不理解而叹息吧。重读过程，不仅是过去的回忆，读书时的令人享受的感觉也再次回到我的大脑。大概是内啡肽吧。不知不觉就读完了这本。</p>
<blockquote>
<p>“好好活下去，不一定要在意别人的话，人生有时候要走自己的路。”</p>
<p>“我知道父亲拙于言词，在面对生命难以省略的伤痛时，更无力打破沉默。”</p>
</blockquote>
<p>​	<strong>最近</strong>，作息有点阴间，书中这句话突然点醒了我。</p>
<blockquote>
<p>“平常上班的日子，他不乏迟到的纪录，不过，他从未在星期天晚起过，因为这是他最重视的、为自己而活的日子。”</p>
</blockquote>
<p>​	以前我还爱用“	理想主义的少年不会被现实主义打败。”这句话来激励我自己，然而，这句话的力量在我觉得它幼稚的那一刻荡然无存，就好像否定了理想主义的存在一样。<strong>总之</strong>，这本书让我重新感受到了文字的温度与力量，我感激袁哲生先生的文字，我想，您之所以选择走向天堂，是因为想要把这些文字带给天国的人们吧。</p>
<blockquote>
<p> <strong>这一位看自己灵魂风水的人，最终选择留下了的叹息，也成为了读者对一位如此能抓住人心的作者的叹息。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>《再穷也要去旅游》</title>
    <url>/2023/09/21/%E3%80%8A%E5%86%8D%E7%A9%B7%E4%B9%9F%E8%A6%81%E5%8E%BB%E6%97%85%E6%B8%B8%E3%80%8B/</url>
    <content><![CDATA[<h1 id="《再穷也要去旅游》"><a href="#《再穷也要去旅游》" class="headerlink" title="《再穷也要去旅游》"></a>《再穷也要去旅游》</h1><p>​	我今天才开始接触这本书，初见时就是惊鸿一瞥，可能是比较贴切当代像我一样穷大学生的现状吧 &lt;3。</p>
<p>​	唉，我好像老是嘴上说着要去哪里哪里走一走，但是到头来总是会出现各种各样的阻挠。就像今年夏天，驾照啦，作业啦之类的。但是仔细想想，好像这只是给自己家里蹲找的借口而已。于是不了终了，开学时只得借大隐隐于市聊以自慰。</p>
<p>​	不行啊！这个寒假可不能在颓废了！你不是会骑摩托了吗？！这个寒假就加满油去野营吧！看看能否找到冬季银河的踪迹。（回家之前）</p>
<p>​	nmmd，这么冷，不是下雨就是下雪，这个世界又多了一个伤心的人。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>《奇风岁月》</title>
    <url>/2024/01/26/%E3%80%8A%E5%A5%87%E9%A3%8E%E5%B2%81%E6%9C%88%E3%80%8B/</url>
    <content><![CDATA[<p>​	这应该是我青少年时期最喜欢的一本书了，那时推荐给了很多人看。高中时很喜欢一个up主，他一边介绍高质量游戏，一边给我们推荐他觉得好看的有意思的书。这本书就是他推荐的。</p>
<p>​	也是在整理东西的时候发现的过去写的文字。</p>
<p><img src="/images/read/qiFengSuiYue_1.jpg" alt="看完一年后高三时怀念奇风镇"></p>
<p><img src="/images/read/qiFengSuiYue_2.jpg" alt="第一次看《奇风岁月》"></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>《霍乱时期的爱情》</title>
    <url>/2024/01/26/%E3%80%8A%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85%E3%80%8B/</url>
    <content><![CDATA[<p>​	在老家整理东西的时候发现了许多在高中时代写的文字，怀念的感觉油然而生。这本书是我在高二的时候看过的。那时看完之后心情久久不得平静，就撕下一页稿纸，随手写了这点东西。</p>
<p> <img src="/images/read/huoLuanShiQiDeAiQing.jpg"></p>
<p>​	想到那时的自己还是书虫，每日不读书就浑身难受。再看看现在，好像已经有几个月没有拿起一本书像过去的我一样一有时间就打开阅读了。</p>
<p>​	最近就把过去看过的书再温习一遍吧！</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>时间胶囊</title>
    <url>/2024/01/26/%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A/</url>
    <content><![CDATA[<p>​	<img src="/images/timeCapsule/1.jpg"></p>
<p>​	高中晚自习的时候，下暴雨时有感。</p>
<p>​	<img src="/images/timeCapsule/2.jpg"></p>
<p>​	高中午休时胡思乱想有感。</p>
<p>​	<img src="/images/timeCapsule/3.jpg"></p>
<p>​	高中数学课有感。</p>
<p>​	<img src="/images/timeCapsule/4.jpg"></p>
<p>​	高中被室友呼噜声吵失眠有感。</p>
<p>​	<img src="/images/timeCapsule/5.jpg"></p>
<p>​	看完凯鲁亚克的《在路上》后有感。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>随手记</title>
    <url>/2023/10/09/%E9%9A%8F%E6%89%8B%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="困饿累睡不着"><a href="#困饿累睡不着" class="headerlink" title="困饿累睡不着"></a>困饿累睡不着</h1><p><img src="/images/myPoems_1.jpg" alt="myPoems_1.jpg"></p>
<p>​	上课的时候随便乱写的&lt;3,没想到我还是这么中二</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32</title>
    <url>/2024/01/29/STM32/</url>
    <content><![CDATA[<h1 id="嵌入式基本概念"><a href="#嵌入式基本概念" class="headerlink" title="嵌入式基本概念"></a>嵌入式基本概念</h1><ul>
<li><p>嵌入式系统<br>  嵌入式系统是一种专门设计用于执行特定任务或控制特定设备的计算机系统。它通常包括硬件和软件两个部分，被嵌入到目标设备中，以实现特定的功能。</p>
</li>
<li><p>RTOS（Real-Time OS）</p>
<p>  一种专门设计用于嵌入式系统的操作系统。RTOS的主要特点是能够保证任务在预定的时间内得到及时处理，具有良好的实时性。</p>
</li>
</ul>
<h1 id="1-STM32和51"><a href="#1-STM32和51" class="headerlink" title="1. STM32和51"></a>1. STM32和51</h1><h2 id="1-51的优缺点"><a href="#1-51的优缺点" class="headerlink" title="1. 51的优缺点"></a>1. 51的优缺点</h2><h3 id="1-51-的优点"><a href="#1-51-的优点" class="headerlink" title="1. 51 的优点"></a>1. 51 的优点</h3><ul>
<li>硬件层面</li>
</ul>
<blockquote>
<ol>
<li>结构简单，8位</li>
<li>硬件到软件有一套按位操作系统。（进行位的操作：传送、置位、清零、测试，逻辑运算）</li>
<li>包含乘除法指令</li>
</ol>
</blockquote>
<ul>
<li>软件层面</li>
</ul>
<blockquote>
<ol>
<li>可以使用C进行编程</li>
</ol>
</blockquote>
<h3 id="2-51的缺点"><a href="#2-51的缺点" class="headerlink" title="2. 51的缺点"></a>2. 51的缺点</h3><ul>
<li>硬件层面</li>
</ul>
<blockquote>
<ol>
<li>功能少，运行速度慢</li>
<li>I&#x2F;O高电平无输出能力</li>
<li>保护能力差</li>
</ol>
</blockquote>
<h2 id="2-stm32的简介"><a href="#2-stm32的简介" class="headerlink" title="2.stm32的简介"></a>2.stm32的简介</h2><blockquote>
<p>​	由ST厂商推出的STM32系列单片机，行业的朋友都知道，这是一款性价比超高的系列单片机，应该没有之一，功能及其强大。其基于专为要求高性能、低成本、低功耗的嵌入式应用专门设计的ARM Cortex-M内核，同时具有一流的外设：1μs的双12位ADC，4兆位&#x2F;秒的UART，18兆位&#x2F;秒的SPI等等，在功耗和集成度方面也有不俗的表现，当然和MSP430的功耗比起来是稍微逊色的一些，但这并不影响工程师们对它的热捧程度，由于其简单的结构和易用的工具再配合其强大的功能在行业中赫赫有名。</p>
</blockquote>
<ul>
<li>强大功能体现</li>
</ul>
<blockquote>
<ol>
<li><p>内核<br>STM32 系列采用了多种 ARM Cortex-M 内核，包括 Cortex-M0、Cortex-M3、Cortex-M4 等，具有不同的性能和功能特点，可根据应用场景的需求进行选择。</p>
</li>
<li><p>时钟<br>STM32 系列支持多种时钟源，包括内部 RC 振荡器、内部晶体振荡器、外部晶体振荡器等，可根据应用场景的需求进行选择。同时还支持多种时钟分频和时钟输出等功能。</p>
</li>
<li><p>存储器<br>STM32 系列支持多种存储器类型，包括 Flash 存储器、RAM 存储器、EEPROM 存储器等，可以根据应用场景的需求进行选择。同时还支持多种存储器保护和存储器映射等功能。</p>
</li>
<li><p>支持多种通讯</p>
<p>STM32 系列还支持多种通信协议，如 SPI、I2C、CAN、USART 等。这使得 STM32 系列非常适合各种应用，特别是需要与其他设备或模块进行通信的应用。</p>
</li>
</ol>
</blockquote>
<h2 id="3-STM32F103C8T6-最小系统制作"><a href="#3-STM32F103C8T6-最小系统制作" class="headerlink" title="3.STM32F103C8T6 最小系统制作"></a>3.STM32F103C8T6 最小系统制作</h2><h3 id="1-供电电路"><a href="#1-供电电路" class="headerlink" title="1.供电电路"></a>1.供电电路</h3><h4 id="1-芯片特性"><a href="#1-芯片特性" class="headerlink" title="1.芯片特性"></a>1.芯片特性</h4><ul>
<li>操作定压Vdd&#x3D;2.0~3.6v</li>
<li>Vdd关闭后，RTC和备用寄存器可以从Vbat供电</li>
</ul>
<h3 id="2-电源转换电路"><a href="#2-电源转换电路" class="headerlink" title="2.电源转换电路"></a>2.电源转换电路</h3><ul>
<li>USB供电（5v）转3.3v供电</li>
</ul>
<p>​	采用AMS1117芯片</p>
<ul>
<li>AMS1117<ul>
<li>特点：</li>
</ul>
</li>
</ul>
<blockquote>
<p>Three Terminal Adjustable or Fixed Voltages* </p>
<p>• High Efficiency Linear Regulators  1.5V, 1.8V, 2.5V, 2.85V, 3.3V and 5.0V </p>
<p>• Post Regulators for Switching Supplies  • Output Current of 1A </p>
<p>• 5V to 3.3V Linear Regulator  </p>
<p>• Operates Down to 1V Dropout </p>
<p>• Line Regulation: 0.2% Max. </p>
<p>• Active SCSI Terminators  </p>
<p>• Load Regulation: 0.4% Max. </p>
<p>• SOT-223, TO-252 and SO-8 package</p>
</blockquote>
<h3 id="3-SWD下载电路"><a href="#3-SWD下载电路" class="headerlink" title="3.SWD下载电路"></a>3.SWD下载电路</h3><ul>
<li>PA13和PA14为STM32F103C8T6芯片的SWD下载调试引脚</li>
</ul>
<h3 id="4-时钟电路"><a href="#4-时钟电路" class="headerlink" title="4.时钟电路"></a>4.时钟电路</h3><ul>
<li>时钟源</li>
</ul>
<blockquote>
<p>三个不同的时钟源可以用来驱动系统时钟(SYSCLK)： </p>
<p>● HSI晶振时钟(高速内部时钟信号)  </p>
<p>● HSE晶振时钟(高速外部时钟信号)  </p>
<p>● PLL时钟 </p>
<p>STM32有两个二级时钟源： </p>
<p>● 40kHz的低速内部RC，它可以驱动独立看门狗，还可选择地通过程序选择驱动RTC。RTC 用于从停机&#x2F;待机模式下自动唤醒系统。 </p>
<p>● 32.768kHz的低速外部晶振，可选择它用来驱动RTC(RTCCLK)。</p>
</blockquote>
<ul>
<li>时钟电路（晶振电路）</li>
</ul>
<h3 id="5-复位电路"><a href="#5-复位电路" class="headerlink" title="5.复位电路"></a>5.复位电路</h3><ul>
<li><p>复位条件：</p>
<ul>
<li>NRST引脚上出现低电平(外部复位)  </li>
<li>窗口看门狗计数终止(WWDG复位)  </li>
<li>独立看门狗计数终止(IWDG复位)  </li>
<li>软件复位(SW复位)  </li>
<li>低功耗管理复位</li>
</ul>
</li>
<li><p>复位电路</p>
</li>
</ul>
<h3 id="6-外围测试电路"><a href="#6-外围测试电路" class="headerlink" title="6.外围测试电路"></a>6.外围测试电路</h3><ul>
<li>LED测试电路</li>
</ul>
<blockquote>
<ol>
<li>电源指示灯</li>
<li>烧录指示灯</li>
<li>blink程序测试用灯</li>
</ol>
</blockquote>
<ul>
<li>引脚引出</li>
</ul>
<h1 id="STM32的GPIO（待补充）"><a href="#STM32的GPIO（待补充）" class="headerlink" title="STM32的GPIO（待补充）"></a>STM32的GPIO（待补充）</h1><p>​	STM32的I&#x2F;O 端口有8种模式（4种输入模式和4种输出模式）。</p>
<blockquote>
<ul>
<li><p>GPIO工作模式—–输入</p>
<p>  1.浮空输入模式</p>
<p>  2.上拉输入模式</p>
<p>  3.下拉输入模式</p>
<p>  4.模拟输入模式</p>
</li>
<li><p>GPIO工作模式—–输出</p>
<p>  1.开漏输出模式</p>
<p>  2.推挽输出模式</p>
<p>  3.复用开漏输出</p>
<p>  4.复用推挽输出</p>
</li>
</ul>
</blockquote>
<h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><h3 id="1-输入浮空"><a href="#1-输入浮空" class="headerlink" title="1. 输入浮空"></a>1. 输入浮空</h3><ul>
<li>特性</li>
</ul>
<ol>
<li>I&#x2F;O端口的电平信号直接进入输入数据寄存器。</li>
<li>引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的·</li>
</ol>
<ul>
<li>使用案例</li>
</ul>
<h3 id="2-输入上拉"><a href="#2-输入上拉" class="headerlink" title="2. 输入上拉"></a>2. 输入上拉</h3><ul>
<li>特性</li>
</ul>
<ol>
<li>IO<strong>内部</strong>接上拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为高电平 </li>
<li>STM32 <strong>内部</strong>上拉输出的电流很弱的，需要大电流还是得外部上拉。</li>
</ol>
<ul>
<li>使用案例</li>
</ul>
<h3 id="3-输入下拉"><a href="#3-输入下拉" class="headerlink" title="3. 输入下拉"></a>3. 输入下拉</h3><ul>
<li>特性</li>
</ul>
<ol>
<li>IO内部接下拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为低电平</li>
</ol>
<ul>
<li>使用案例</li>
</ul>
<h3 id="4-模拟输入"><a href="#4-模拟输入" class="headerlink" title="4. 模拟输入"></a>4. 模拟输入</h3><ul>
<li>特点</li>
</ul>
<ol>
<li>信号不经过施密特触发器，直接直接进入ADC模块，并且输入数据寄存器为空 ，CPU不能在输入数据寄存器上读到引脚状态</li>
<li>没有连接TTL触发器，这样保留最原始的电压值，不是转换过后的0和1信号</li>
<li>数据直接送到片上外设，一般是ADC模数转换器（Analog-to-Digital Converter）</li>
</ol>
<ul>
<li>使用案例</li>
</ul>
<p>用于连接模拟传感器或信号源，如温度传感器或光线传感器，可以通过ADC模块读取模拟电压值。</p>
<h2 id="输出模式（一知半解，待补充）"><a href="#输出模式（一知半解，待补充）" class="headerlink" title="输出模式（一知半解，待补充）"></a>输出模式（一知半解，待补充）</h2><h3 id="1-开漏输出"><a href="#1-开漏输出" class="headerlink" title="1. 开漏输出"></a>1. 开漏输出</h3><ul>
<li>特征</li>
</ul>
<ol>
<li>引脚可以输出低电平（逻辑0），但不能输出高电平，而是通过外部上拉电阻实现。</li>
</ol>
<ul>
<li>使用案例</li>
</ul>
<p>​	适用于实现多个引脚共享一个信号线的情况，如I2C总线或SPI总线。开漏输出模式允许多个设备通过外部上拉电阻共享同一条信号线，并且可以实现更高的灵活性和可靠性。</p>
<h3 id="2-推挽输出"><a href="#2-推挽输出" class="headerlink" title="2. 推挽输出"></a>2. 推挽输出</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul>
<li>特征</li>
</ul>
<p>​	这意味着引脚可以输出高电平（逻辑1）或低电平（逻辑0），且能够提供或接受相对较高的电流。</p>
<ul>
<li>使用案例</li>
</ul>
<p>​	适用于驱动外部负载，如LED、继电器、蜂鸣器等。推挽输出模式在输出高电平时提供的电流较大，可以有效地驱动各种类型的负载。</p>
<h3 id="3-复用功能推挽输出"><a href="#3-复用功能推挽输出" class="headerlink" title="3. 复用功能推挽输出"></a>3. 复用功能推挽输出</h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><ul>
<li>特征</li>
</ul>
<p>在复用推挽输出模式下，GPIO引脚被配置为复用推挽输出，同时具有其他功能，如串行通信、定时器等。</p>
<ul>
<li>使用案例</li>
</ul>
<p>​	适用于需要在GPIO引脚上实现数字输出以及其他功能的应用场景。例如，将引脚配置为UART串行通信的TX引脚，同时可用于输出数字信号。</p>
<h3 id="4-复用功能开漏输出"><a href="#4-复用功能开漏输出" class="headerlink" title="4. 复用功能开漏输出"></a>4. 复用功能开漏输出</h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><ul>
<li><p>特征</p>
</li>
<li><p>使用案例</p>
</li>
</ul>
<h1 id="STM32-HAL库和标准库的比较"><a href="#STM32-HAL库和标准库的比较" class="headerlink" title="STM32 HAL库和标准库的比较"></a>STM32 HAL库和标准库的比较</h1><ul>
<li>抽象层级：<br>标准库：标准外设库提供了对STM32外设的低层次的直接访问，开发者需要直接操作外设的寄存器来配置和控制外设。<br>HAL库：HAL库提供了对STM32外设的高层次的抽象，通过一组统一的API接口，开发者可以更方便地配置和控制外设，而不必直接操作底层寄存器。</li>
<li>可移植性：<br>标准库：标准外设库的代码通常直接与特定型号的STM32微控制器相关联，因此在不同型号的微控制器之间的移植性较差。<br>HAL库：HAL库设计为具有一定的可移植性，可以在不同型号的STM32微控制器之间进行较为简单的移植。</li>
<li>易用性：<br>标准库：标准外设库需要开发者具有一定的硬件知识和对STM32微控制器的了解，操作相对复杂，学习曲线较陡。<br>HAL库：HAL库提供了一套统一的API接口，使得操作外设更加简单直观，适合初学者或者对硬件了解较少的开发者使用。</li>
<li>功能支持：<br>标准库：标准外设库通常提供了丰富的外设驱动程序，但功能相对较为基础，不支持一些高级特性。<br>HAL库：HAL库不仅提供了基础的外设驱动程序，还支持一些高级特性，如DMA、中断优先级管理、时钟配置等，能够满足更复杂的应用需求。</li>
</ul>
<p>总的来说，标准库更加接近硬件，直接操作寄存器，适合对硬件较为了解的开发者；而HAL库提供了更高层次的抽象，操作更加简便，适合快速开发应用程序。选择使用哪种库取决于开发者的具体需求和技术水平。</p>
<h1 id="标准库的功能"><a href="#标准库的功能" class="headerlink" title="标准库的功能"></a>标准库的功能</h1><ul>
<li>外设驱动支持：<br>  STM32标准库提供了丰富的外设驱动程序，包括GPIO、定时器、串口、SPI、I2C、ADC等，开发者可以直接调用这些函数来配置和控制外设，实现各种功能。</li>
<li>中断支持：<br>  标准库支持外部中断和定时器中断，在外设产生中断时能够及时响应，并执行相应的中断服务程序。开发者可以通过注册中断处理函数来实现自定义的中断处理逻辑。</li>
<li>时钟控制：<br>  STM32标准库提供了时钟配置功能，包括系统时钟和外设时钟的配置。开发者可以根据实际需求设置时钟源、时钟分频等参数，以满足系统的性能和功耗要求。</li>
<li>低功耗模式：<br>  标准库支持STM32微控制器的低功耗模式，包括停机模式、睡眠模式、待机模式等，开发者可以根据需要选择合适的低功耗模式来降低系统的功耗。</li>
<li>系统初始化和配置：<br>  标准库提供了系统初始化和配置函数，包括时钟初始化、外设初始化等，开发者可以在程序的启动阶段调用这些函数来配置系统的基本参数。</li>
<li>调试支持：<br>  标准库提供了一些调试功能，如串口打印输出、断言功能等，帮助开发者在调试和验证程序时更加方便。<br>  定时器和计数器： 标准库提供了定时器和计数器的功能支持，包括定时器的初始化、启动、停止等操作，以及定时器中断的配置和处理。</li>
<li>PWM输出：<br>  标准库支持PWM输出功能，开发者可以通过配置定时器和GPIO来生成PWM信号，用于控制电机、LED等外部设备。</li>
</ul>
<h1 id="案例程序"><a href="#案例程序" class="headerlink" title="案例程序"></a>案例程序</h1><h2 id="STM32的中断"><a href="#STM32的中断" class="headerlink" title="STM32的中断"></a>STM32的中断</h2><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><h4 id="中断向量："><a href="#中断向量：" class="headerlink" title="中断向量："></a><strong>中断向量</strong>：</h4><p>中断向量是指用于唤醒处理器并跳转到相应<strong>中断服务程序（ISR）的特定地址</strong>。在中断发生时，处理器会根据中断类型查找相应的中断向量，并跳转到相应的中断服务程序开始执行中断处理。<strong>中断向量通常是固定的</strong>，由处理器或芯片设计者确定，因为它们对应于具体的中断类型。例如，某个中断类型可能对应到内存中的特定地址，而另一个中断类型可能对应到另一个地址。</p>
<h4 id="中断向量表："><a href="#中断向量表：" class="headerlink" title="中断向量表："></a><strong>中断向量表</strong>：</h4><p>中断向量表是一张表格，存储着所有中断类型对应的中断向量。每个中断向量都包含了中断发生时处理器应该跳转到的地址。在许多嵌入式系统中，中断向量表通常存储在固定的内存位置，处理器在发生中断时会根据中断类型找到相应的中断向量，并跳转到相应的中断服务程序。中断向量表的大小通常由中断类型的数量决定。</p>
<h4 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a><strong>NVIC</strong></h4><p>NVIC是ARM Cortex-M系列微控制器中的一个重要组件，用于管理和控制中断</p>
<h4 id="AFIO"><a href="#AFIO" class="headerlink" title="AFIO"></a><strong>AFIO</strong></h4><p>AFIO代表Alternate Function Input Output（备用功能输入输出），是STM32系列微控制器中的一个模块。AFIO模块允许用户配置GPIO引脚的备用功能，包括串行通信、定时器、中断控制等。</p>
<h3 id="硬件特性"><a href="#硬件特性" class="headerlink" title="硬件特性"></a>硬件特性</h3><ol>
<li>68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设</li>
<li>使用<strong>NVIC</strong><code>NVIC代表Nested Vectored Interrupt Controller（嵌套向量中断控制器）。NVIC是ARM Cortex-M系列微控制器中的一个重要组件，用于管理和控制中断。</code>统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级</li>
<li>优先级分组<ol>
<li>抢占优先级：越高可以中断嵌套</li>
<li>响应优先级：越高可以优先排队</li>
</ol>
</li>
</ol>
<h3 id="外部中断（-E-X-T-I-）"><a href="#外部中断（-E-X-T-I-）" class="headerlink" title="外部中断（ E X T I ）"></a>外部中断（ E X T I ）</h3><h4 id="硬件特性："><a href="#硬件特性：" class="headerlink" title="硬件特性："></a>硬件特性：</h4><ol>
<li>触发方式：上升沿&#x2F;下降沿&#x2F;双边沿&#x2F;软件触发</li>
<li>支持所有GPIO口，但相同的Pin不能同时触发中断</li>
<li>通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</li>
</ol>
<h4 id="结构体初始化配置过程"><a href="#结构体初始化配置过程" class="headerlink" title="结构体初始化配置过程"></a>结构体初始化配置过程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);		<span class="comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*GPIO初始化*/</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);						<span class="comment">//将PB14引脚初始化为上拉输入</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*AFIO选择中断引脚*/</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);<span class="comment">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*EXTI初始化*/</span></span><br><span class="line">  EXTI_InitTypeDef EXTI_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">  EXTI_InitStructure.EXTI_Line = EXTI_Line14;					<span class="comment">//选择配置外部中断的14号线</span></span><br><span class="line">  EXTI_InitStructure.EXTI_LineCmd = ENABLE;					<span class="comment">//指定外部中断线使能</span></span><br><span class="line">  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;			<span class="comment">//指定外部中断线为中断模式</span></span><br><span class="line">  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;		<span class="comment">//指定外部中断线为下降沿触发</span></span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStructure);								<span class="comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);				<span class="comment">//配置NVIC为分组2</span></span><br><span class="line">                                <span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line">                                <span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line">                                <span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line">                                <span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*NVIC配置*/</span></span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;		<span class="comment">//选择配置NVIC的EXTI15_10线</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;	<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;			<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br></pre></td></tr></table></figure>





<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><h2 id="OLED屏幕不显示（未解决）"><a href="#OLED屏幕不显示（未解决）" class="headerlink" title="OLED屏幕不显示（未解决）"></a>OLED屏幕不显示<del>（未解决）</del></h2><p>​	使用 STM32以IIC的协议进行通信来在0.96寸OLED屏幕显示失败。但是使用arduino uno时显示正常。</p>
<p>​	经过检验，发现使用的芯片为<code>STM32f103c6t6</code> 默认<code>i2c</code>输出引脚为<code>PB6(SCL) PB7(SDA)</code>而<code>STM32f103c8t6</code>有两组<code>I2C</code>引脚，分别是<code>&#123; PB6(SCL) PB7(SDA) &#125; 和&#123; PB8(SCL) PB9(SDA)&#125;</code></p>
<p>​	多看看技术手册！！！</p>
<h3 id="不同芯片功能对比"><a href="#不同芯片功能对比" class="headerlink" title="不同芯片功能对比"></a>不同芯片功能对比</h3><blockquote>
<ol>
<li><p>C6T6没有串口3（及USART3）；</p>
</li>
<li><p>C6T6没有通用定时器TIM4；</p>
</li>
<li><p>C6T6没有串行外设接口SPI2；</p>
</li>
<li><p>C6T6没有I2C2</p>
</li>
<li><p>C6T6的flash为32K， C8T6为64K；</p>
</li>
<li><p>C6T6的RAM为10K，C8T6为20K。</p>
<p>总结就是C8T6比C6T6多了一个串口、一个定时器、一个串行外设接口、一个I2C、内存大一点！</p>
</li>
</ol>
</blockquote>
<ul>
<li>IIC协议的上拉电阻已考虑</li>
<li>电压大小已考虑</li>
<li>芯片引脚特性</li>
</ul>
]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>常见通信协议以及通信方式</title>
    <url>/2024/01/29/%E5%B8%B8%E8%A7%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="常用的通信方式"><a href="#常用的通信方式" class="headerlink" title="常用的通信方式"></a>常用的通信方式</h1><h2 id="1-串行和并行通信"><a href="#1-串行和并行通信" class="headerlink" title="1. 串行和并行通信"></a>1. 串行和并行通信</h2><ul>
<li>串行通信优缺点</li>
</ul>
<blockquote>
<p>优点：</p>
<p>​	1. 占用资源少（只需一根线）</p>
<p>缺点：</p>
<p>​	1. 传输速率慢</p>
</blockquote>
<ul>
<li>并行通信优缺点</li>
</ul>
<blockquote>
<p>优点：</p>
<p>​	1. 传输速率快</p>
<p>缺点：</p>
<p>​	1. 占用资源多（多根线同时使用）</p>
</blockquote>
<h2 id="2-同步和异步通信"><a href="#2-同步和异步通信" class="headerlink" title="2. 同步和异步通信"></a>2. 同步和异步通信</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul>
<li>同步通信</li>
</ul>
<blockquote>
<p><strong>同步通信：</strong> 发送端在发送串行数据的同时，提供一个时钟信号，并按照一定的约定（例如：在时钟信号的上升沿的时候，将数据发送出去）发送数据，接收端根据发送端提供的时钟信号，以及大家的约定，接收数据。如：I2C、SPI等有时钟信号的协议，都属于这种通信方式。</p>
</blockquote>
<ul>
<li>异步通信</li>
</ul>
<blockquote>
<p><strong>异步通信：</strong> <strong>接收方并不知道数据什么时候会到达，收发双方可以有各自自己的时钟</strong>。发送方发送的时间间隔可以不均，接收方是在数据的起始位和停止位的帮助下实现信息同步的。这种传输通常是很小的分组，比如：一个字符为一组，数据组配备起始位和结束位。所以这种传输方式的效率是比较低的，因为额外加入了很多的辅助位作为负载，常用在低速的传输中。</p>
</blockquote>
<h3 id="2-比较"><a href="#2-比较" class="headerlink" title="2. 比较"></a>2. 比较</h3><ul>
<li><p>同步通信要求接收端时钟频率和发送端时钟频率一致，发送端发送连续的比特流；异步通信时不要求接收端时钟和发送端时钟同步，发送端发送完一个字节后，可经过任意长的时间间隔再发送下一个字节。</p>
</li>
<li><p>同步通信效率高；异步通信效率较低。</p>
</li>
<li><p>同步通信较复杂，双方时钟的允许误差较小；异步通信简单，双方时钟可允许一定误差。</p>
</li>
<li><p>同步通信可用于点对多点；异步通信只适用于点对点。</p>
</li>
</ul>
<h2 id="3-单工、半双工、全双工通信"><a href="#3-单工、半双工、全双工通信" class="headerlink" title="3. 单工、半双工、全双工通信"></a>3. 单工、半双工、全双工通信</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><ul>
<li>单工数据传输只支持数据在一个方向上传输</li>
<li>半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信</li>
<li>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</li>
</ul>
<h2 id="4-通信速率"><a href="#4-通信速率" class="headerlink" title="4. 通信速率"></a>4. 通信速率</h2><ul>
<li>比特率</li>
</ul>
<blockquote>
<p>比特率(bit rate)又称传信率、信息传输速率(简称信息速率，information rate)。其定义是：通信线路(或系统)单位时间(每秒)内传输的信息量，即每秒能传输的二进制位数，通常用Rb表示，其单位是比特&#x2F;秒(bit&#x2F;s或b&#x2F;s，英文缩略语为bps)。</p>
</blockquote>
<ul>
<li>波特率</li>
</ul>
<blockquote>
<p>波特率(Baud rate)又称传码率、码元传输速率(简称码元速率)、信号传输速率(简称信号速率，signaling rate)或调制速率。其定义是：通信线路(或系统)单位时间(每秒)内传输的码元(脉冲)个数；或者表示信号调制过程中，单位时间内调制信号波形的变换次数，通常用RB表示，单位是波特(Bd或Baud，前者规范)。如果每秒传输1个码元就称为1Bd；如果1码元的时间长短为200ms，则每秒可传输5个码元，那么码元速率(波特率)就是5Bd。</p>
</blockquote>
<ul>
<li>码元</li>
</ul>
<blockquote>
<p>码元(code cell)是携带信息的数字单位，是指在数字信道中传送数字信号的一个波形符号，也即“时间轴上的一个信号编码单元”。码元可能是二进制的，也可能是多进制的。 </p>
</blockquote>
<h2 id="5-常见通信方式"><a href="#5-常见通信方式" class="headerlink" title="5. 常见通信方式"></a>5. 常见通信方式</h2><p>​	USART ( Universal Synchronous Asynchronous Receiver and Transmitter )</p>
<p>​	UART ( Universal Asynchronous Receiver and Transmitter )</p>
<h4 id="1-TTL"><a href="#1-TTL" class="headerlink" title="1. TTL"></a>1. TTL</h4><blockquote>
<p>TTL（transistor transistor logic）即晶体管-晶体管逻辑电平。TTL电平信号规定，+5V等价于逻辑“1”，0 V等价于逻辑“0”(采用二进制来表示数据时)。</p>
</blockquote>
<h4 id="2-RS232"><a href="#2-RS232" class="headerlink" title="2. RS232"></a>2. RS232</h4><ul>
<li>协议简介</li>
</ul>
<blockquote>
<p>RS-232总线规定了25条线，包含了两个信号通道，即第一通道（称为主通道）和第二通道（称为副通道）。利用RS- 232总线可以实现全双工通信，通常使用的是主通道，而副通道使用较少。在一般应用中，使用3条～9条信号线就可以实现全双工通信，采用三条信号线（接收线RXD、发送线TXD和信号地GND）能实现简单的全双工通信过程。因此RS232标准有两种接口——DB9和DB25，其中常用的是DB9接口。</p>
</blockquote>
<ul>
<li>特征</li>
</ul>
<blockquote>
<ul>
<li>接口信号电平高，容易损坏接口电路的芯片。RS232接口上任何信号线的电压都处于负逻辑关系中。即：逻辑“1”为-3 ~ -15V;逻辑为“0”：+3 ~ +15V，噪声裕量为2V。也就是说，接收器需要将高于+3V的信号识别为逻辑“0”，将低于-3V的信号识别为逻辑“1”，将5V的TTL电平识别为逻辑正极，将0识别为逻辑负极。</li>
<li>与TTL电平不兼容，需要一个电平转换电路来连接到TTL电路。</li>
<li>传输速率低。在异步传输中，比特率为20Kbps;因此，在51CPLD开发板中，集成程序波特率只能是19200，这也是原因。</li>
<li>接口采用信号线和信号回波串，形成共同的接地传输形式。这种标准的接地传输容易受到共模干扰，因此抗噪性较弱。</li>
<li>传输距离有限。最大传输距离为50英尺。它只能达到大约15米。</li>
</ul>
</blockquote>
<h4 id="3-RS485"><a href="#3-RS485" class="headerlink" title="3. RS485"></a>3. RS485</h4><ul>
<li>简介</li>
</ul>
<blockquote>
<p>RS485 通信采用差分信号传输，通常情况下只需要两根信号线就可以进行正常的通信。<br>在差分信号中，逻辑0和逻辑1是用两根信号线（A+和B-）的电压差来表示。</p>
<p>逻辑 1：两根信号线（A+和B-）的电压差在 +2V～+6V 之间。<br>逻辑 0：两根信号线（A+和B-）的电压差在 -2V～-6V 之间。</p>
</blockquote>
<ul>
<li>特征</li>
</ul>
<blockquote>
<p>RS-485的电气特性：逻辑“1”由两条线路+2V<del>+6V之间的电压差表示，逻辑“0”由两条线路之间的电压差-6V</del>-2V表示。接口信号电平低于RS-232，不易损坏接口电路芯片。该电平与TTL电平兼容，便于与TTL电路连接。<br>最高数据传输速率为：10Mbps<br>RS-485接口采用平衡驱动器和差分接收机的组合，具有抗共振固模干扰能力，即抗噪声性能好。<br>RS-485接口的最大传输距离为4000英尺，实际上可达3000米。<br>RS-232接口仅允许一个收发器连接到总线，即单站功能。相比之下，RS-485接口仅允许在总线上连接多达128个收发器，即多站能力。用户 使用单个RS-485接口可以快速建立设备网络。</p>
</blockquote>
<h3 id="3-I2C"><a href="#3-I2C" class="headerlink" title="3.  I2C"></a>3.  I2C</h3><ul>
<li>简介</li>
</ul>
<blockquote>
<p>I2C（同步<strong>半双工</strong>）通讯协议(Inter－Integrated Circuit)是由 Phiilps（飞利浦） 公司开发的，由于它引脚少，硬件实现简单，可扩展性强，不需要 USART、 CAN 等通讯协议的外部收发设备，现在被广泛地使用在系统内多个集成电路(IC)间的通讯。</p>
</blockquote>
<ul>
<li>特点</li>
</ul>
<blockquote>
<p>(1) 它是一个<strong>支持多设备</strong>的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。</p>
<p>(2) 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</p>
<p>(3) <strong>总线通过上拉电阻</strong>接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p>
<p>(4) 多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p>
<p>(5) 具有三种传输模式：标准模式传输速率为 100kbit&#x2F;s ，快速模式400kbit&#x2F;s ，高速模式下可达 1Mbit&#x2F;s，但目前大多 I2C 设备尚不支持高速模式。</p>
<p>(6) 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制 。</p>
</blockquote>
<h4 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h4><ol>
<li><p>使用两个总线：</p>
<ol>
<li>SDA（数据线）</li>
<li>SCL（时钟线）</li>
</ol>
</li>
<li><p>主设备与从设备</p>
<ol>
<li>主设备（控制时钟线<code>SCL</code>）</li>
<li>从设备（地址检测）</li>
</ol>
</li>
<li><p>高阻态</p>
</li>
</ol>
<p>​	为了设备通过总线通信时不干扰主从设设备之外的设备，同时为了主从设备不被其他设备干扰，使用外部上拉电阻。</p>
<ol start="4">
<li><p>IIIC 设备地址：出厂已经设计好</p>
</li>
<li><p>协议</p>
<ol>
<li><strong>开始信号</strong>：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。</li>
<li><strong>结束信号</strong>：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。</li>
<li><strong>应答信号</strong>：接收数据的 IC 在接收到 8bit 数据后，向发送数据的 IC 发出特定的低电平脉冲，表示已收到数据。CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU 接收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为受控单元出现故障。</li>
</ol>
</li>
</ol>
<h3 id="4-SPI"><a href="#4-SPI" class="headerlink" title="4. SPI"></a>4. SPI</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote>
<p>SPI （同步全双工）协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设备接口，是一种高速全双工的通信总线。它被广泛地使用在 ADC、 LCD 等设备与 MCU 间，要求通讯速率较高的场合。</p>
</blockquote>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><blockquote>
<ol>
<li><strong>SPI</strong>是一个同步的数据总线，也就是说它是用<strong>单独的数据线</strong>和<strong>一个单独的时钟信号</strong>来保证<strong>发送端和接收端的完美同步</strong>。</li>
<li>产生时钟的一侧称为<strong>主机</strong>，另一侧称为<strong>从机</strong>。总是<strong>只有一个主机</strong>（一般来说可以是<strong>微控制器&#x2F;MCU</strong>），但是可以有多个<strong>从机</strong>（后面详细介绍）</li>
<li>逻辑线<ul>
<li><strong>MISO</strong>：<code>Master input slave output</code> 主机输入，从机输出（数据来自从机）；</li>
<li><strong>MOSI</strong>：<code>Master output slave input</code> 主机输出，从机输入（数据来自主机）；</li>
<li><strong>SCLK</strong> ：<code>Serial Clock</code> 串行时钟信号，由主机产生发送给从机；</li>
<li><strong>SS</strong>：<code>Slave Select</code> 片选信号，由主机发送，以控制与哪个从机通信，通常是低电平有效信号。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="信息传输流程"><a href="#信息传输流程" class="headerlink" title="信息传输流程"></a>信息传输流程</h4><blockquote>
<ol>
<li>机先将<code>NSS</code>信号拉低&#x3D;&gt; 开始接收数据</li>
<li><strong>接收端</strong>检测到时钟的边沿信号时，它将立即读取<strong>数据线</strong>上的信号，这样就得到了一位数据</li>
<li><strong>主机</strong>发送到<strong>从机</strong>时：主机产生相应的时钟信号，然后数据<strong>一位一位</strong>地将从<code>MOSI</code>信号线上进行发送到从机；</li>
<li><strong>主机</strong>接收<strong>从机</strong>数据：如果从机需要将数据发送回主机，则主机将继续生成预定数量的时钟信号，并且从机会将数据通过<code>MISO</code>信号线发送；</li>
</ol>
</blockquote>
<h3 id="5-CAN"><a href="#5-CAN" class="headerlink" title="5. CAN"></a>5. CAN</h3><ul>
<li>简介</li>
</ul>
<blockquote>
<p>CAN 是控制器局域网络(Controller Area Network)的简称， 它是由研发和生产汽车电子产品著称的德国 BOSCH 公司开发的，并最终成为国际标准（ISO11519） ， 是国际上应用最广泛的现场总线之一。</p>
<p>CAN 总线协议已经成为汽车计算机控制系统和嵌入式工业控制局域网的标准总线，并且拥有以 CAN 为底层协议专为大型货车和重工机械车辆设计的 J1939 协议。近年来， 它具有的高可靠性和良好的错误检测能力受到重视，被广泛应用于汽车计算机控制系统和环境温度恶劣、电磁辐射强及振动大的工业环境。</p>
</blockquote>
<h3 id="6-USB2-0"><a href="#6-USB2-0" class="headerlink" title="6. USB2.0"></a>6. USB2.0</h3><ul>
<li>简介</li>
</ul>
<blockquote>
<ul>
<li>USB 是一种支持热插拔的高速串行传输总线，使用差分信号来传输数据，最高速度<br>可达 480Mb&#x2F;S。USB 支持“总线供电”和“自供电”两种供电模式。在总线供电模式下，USB2.0设备最多可以获得500mA的电流。</li>
<li>2.USB2.0 被设计成为向下兼容的模式，当有全速 （USB 1.1）或者低速（USB 1.0）设备连接到高速（USB 2.0）主机时，主机可以通过分离传输来支持它们。</li>
<li>3.一条 USB 总线上，可达到的最高传输速度等级由该总线上最慢的“设备”决定，该设备包括主机、HUB以及USB功能设备。</li>
<li>4.USB 体系包括“主机”、“设备”以及“物理连接”三个部分。主机是一个提供USB接口及接口管理能力的硬件、软件及固件的复合体，可以是PC，也可以是OTG设备。一个USB 系统中仅有一个USB主机；</li>
<li>5.设备包括 USB功能设备和 USB HUB，最多支持 127个设备；物理连接即指的是USB 的传输线。在USB 2.0系统中，要求使用屏蔽的双绞线。USB 体系采用分层的星型拓扑来连接所有USB设备。</li>
<li>6.以 HOST-ROOT HUB为起点，最多支持 7 层（Tier），也就是说任何一个USB 系统中最多可以允许 5个 USB HUB 级联。一个复合设备（Compound Device）将同时占据两层或更多的层。</li>
<li>7.一个 USB HOST 最多可以同时支持 128 个地址，地址 0 作为默认地址，只在设备枚举期间临时使用，而不能被分配给任何一个设备，因此一个 USB HOST 最多可以同时支持 127 个地址，如果一个设备只占用一个地址，那么可最多支持 127个 USB设备（含USB HUB）。<br>USB连接器支持热拔插；高速&#x2F;全速USB线缆要求使用内含双绞线的屏蔽线，而且必须打上符合USB使用标记；低速USB推荐但非要求使用双绞线和屏蔽线；</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>51</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟电子技术基础</title>
    <url>/2024/02/01/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="模拟电子技术基础"><a href="#模拟电子技术基础" class="headerlink" title="模拟电子技术基础"></a>模拟电子技术基础</h1><h2 id="1-半导体器件"><a href="#1-半导体器件" class="headerlink" title="1.半导体器件"></a>1.半导体器件</h2><ul>
<li><strong>本征半导体</strong>：纯净，具有晶体结构的半导体</li>
<li><strong>N型半导体</strong>：negative，掺入5价元素，多一个电子。</li>
<li><strong>P型半导体</strong>：positive，掺入3价元素，少一个电子。</li>
<li><strong>PN结</strong>：将P型半导体和N型半导体制作在同一硅片上，交界处形成PN结。</li>
<li><strong>空间电荷区</strong>：PN结交接处区域的复合。也称为耗尽层。</li>
</ul>
<h3 id="1-PN结"><a href="#1-PN结" class="headerlink" title="1.PN结"></a>1.PN结</h3><h4 id="1-PN结的伏安特性"><a href="#1-PN结的伏安特性" class="headerlink" title="1.PN结的伏安特性"></a>1.PN结的伏安特性</h4><ul>
<li>反向击穿</li>
</ul>
<blockquote>
<ol>
<li><strong>齐纳击穿</strong>：在高掺杂，耗尽层宽度窄的情况下，较低的反向电压即可击穿</li>
<li><strong>雪崩击穿</strong>：在低掺杂，耗尽层宽度宽的情况下，较高的反向电压可击穿</li>
</ol>
</blockquote>
<h4 id="2-PN结的电容效应"><a href="#2-PN结的电容效应" class="headerlink" title="2.PN结的电容效应"></a>2.PN结的电容效应</h4><ul>
<li>势垒电容</li>
</ul>
<p>​	当PN结的反向电压变化时，空间电荷区的宽度随之变化，耗尽层电荷变化，导致等效电容变化。</p>
<h3 id="2-二极管"><a href="#2-二极管" class="headerlink" title="2.二极管"></a>2.二极管</h3><h4 id="1-伏安特性"><a href="#1-伏安特性" class="headerlink" title="1.伏安特性"></a>1.伏安特性</h4><ul>
<li>同PN结的对比</li>
</ul>
<blockquote>
<ol>
<li>单向导电性</li>
<li>二极管存在半导体体电阻和引线电阻（同电压下正向电压更小）</li>
<li>表面漏电流（反向电流更大）。漏电流（当施加反向电压时，电流仍然流过器件）</li>
</ol>
</blockquote>
<h4 id="2-不同材料二极管的对比"><a href="#2-不同材料二极管的对比" class="headerlink" title="2.不同材料二极管的对比"></a>2.不同材料二极管的对比</h4><table>
<thead>
<tr>
<th>材料</th>
<th>开启电压</th>
<th>导通电压</th>
<th>反向饱和电流</th>
</tr>
</thead>
<tbody><tr>
<td>硅</td>
<td>0.5</td>
<td>0.6-0.8</td>
<td>&lt;0&#x2F;1</td>
</tr>
<tr>
<td>锗</td>
<td>0.1</td>
<td>0.1-0.3</td>
<td>几十</td>
</tr>
</tbody></table>
<h4 id="3-温度的影响"><a href="#3-温度的影响" class="headerlink" title="3.温度的影响"></a>3.温度的影响</h4><ul>
<li>温度越高：正向曲线左移，方向曲线下移</li>
</ul>
<h4 id="4-二极管的参数"><a href="#4-二极管的参数" class="headerlink" title="4.二极管的参数"></a>4.二极管的参数</h4><ul>
<li>If：最大整流电流</li>
<li>UR：最高反向工作电压</li>
<li>IR：反向电流</li>
<li>fM最高反向工作电流</li>
</ul>
<h3 id="3-稳压二极管"><a href="#3-稳压二极管" class="headerlink" title="3.稳压二极管"></a>3.稳压二极管</h3><ul>
<li>反向击穿时在一定功耗损耗范围内端电压几乎不变</li>
</ul>
<h4 id="1-伏安特性-1"><a href="#1-伏安特性-1" class="headerlink" title="1.伏安特性"></a>1.伏安特性</h4><ul>
<li>正向：类似于二极管</li>
<li>反向：电压不变，大到一定程度击穿</li>
</ul>
<h4 id="1-主要参数"><a href="#1-主要参数" class="headerlink" title="1.主要参数"></a>1.主要参数</h4><ul>
<li><p>稳定电压Uz</p>
</li>
<li><p>稳定电流Iz：小于时稳压效果变坏</p>
</li>
<li><p>额定功耗Pzm：最大稳定电流（Izm）与Uz的乘积</p>
</li>
<li><p>在额定功耗内，电流越大稳压效果越好</p>
</li>
</ul>
<p>需串联限流电阻防止烧坏</p>
<h3 id="4-发光二极管（Light-Emit-Diode）"><a href="#4-发光二极管（Light-Emit-Diode）" class="headerlink" title="4.发光二极管（Light Emit Diode）"></a>4.发光二极管（Light Emit Diode）</h3><table>
<thead>
<tr>
<th>颜色</th>
<th>开启电压</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td>1.6-1.8v</td>
</tr>
<tr>
<td>绿色</td>
<td>2v</td>
</tr>
</tbody></table>
<h3 id="5-光电二极管（Optoelectronic-Diode）"><a href="#5-光电二极管（Optoelectronic-Diode）" class="headerlink" title="5.光电二极管（Optoelectronic Diode）"></a>5.光电二极管（Optoelectronic Diode）</h3><p><img src="/images/analogElectronics/%E5%85%89%E7%94%B5%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%AC%A6%E5%8F%B7.png" alt="符号"></p>
<ul>
<li>暗电流：反向电压下的产生的反向电流。</li>
<li>光电流：反压下受到光照而产生的电流。（照度越大光电流越大）</li>
</ul>
<h3 id="6-变容二极管（Varicap-Diode）"><a href="#6-变容二极管（Varicap-Diode）" class="headerlink" title="6.变容二极管（Varicap Diode）"></a>6.变容二极管（Varicap Diode）</h3><ul>
<li>变容二极管在反向偏置状态下工作，因此没有直流电流流过器件</li>
<li>反向偏置量控制耗尽区的厚度，因此控制变容二极管的结电容</li>
</ul>
<h3 id="7-隧道二极管（Tunnel-Diode）"><a href="#7-隧道二极管（Tunnel-Diode）" class="headerlink" title="7.隧道二极管（Tunnel Diode）"></a>7.隧道二极管（Tunnel Diode）</h3><ul>
<li>隧道二极管常用于<a href="https://zh.wikipedia.org/w/index.php?title=%E9%A0%BB%E7%8E%87%E8%BD%89%E6%8F%9B%E5%99%A8&action=edit&redlink=1">频率转换器</a>和侦测器上</li>
<li>负微分电阻的特性，其也可应用于<a href="https://zh.wikipedia.org/wiki/%E6%8C%AF%E7%9B%AA%E5%99%A8">振荡器</a>、<a href="https://zh.wikipedia.org/wiki/%E6%94%BE%E5%A4%A7%E5%99%A8">放大器</a>以及<a href="https://zh.wikipedia.org/w/index.php?title=%E9%96%8B%E9%97%9C%E9%9B%BB%E8%B7%AF&action=edit&redlink=1">开关电路</a>的迟滞。</li>
</ul>
<h3 id="8-肖特基二极管（Schottky-diode）"><a href="#8-肖特基二极管（Schottky-diode）" class="headerlink" title="8.肖特基二极管（Schottky diode）"></a>8.肖特基二极管（Schottky diode）</h3><ul>
<li>导通电压降较低、允许高速切换的二极管</li>
<li>肖特基二极管的电压降只有 0.15-0.45 伏特，因此可以提升系统的效率。</li>
<li>缺点是其反向偏置较低及反向漏电流偏大</li>
</ul>
<h2 id="2-晶体三极管"><a href="#2-晶体三极管" class="headerlink" title="2.晶体三极管"></a>2.晶体三极管</h2><p>​	晶体三极管又称为双极性晶体管 （BJT）</p>
<h3 id="1-电流放大作用"><a href="#1-电流放大作用" class="headerlink" title="1.电流放大作用"></a>1.电流放大作用</h3><ul>
<li><p>晶体管是放大电路的核心器件。</p>
</li>
<li><p>输入回路：基极-发射极回路。</p>
</li>
<li><p>输出回路：集电极-发射极回路。</p>
</li>
<li><p>共射放大电路： 发射极为输入回路和输出回路公共端</p>
</li>
<li><p>放大状态的外部条件： 发射结正向偏置，集电结反向偏置。</p>
</li>
</ul>
<h3 id="2-共射特性曲线"><a href="#2-共射特性曲线" class="headerlink" title="2.共射特性曲线"></a>2.共射特性曲线</h3><h4 id="1-输入特性曲线"><a href="#1-输入特性曲线" class="headerlink" title="1.输入特性曲线"></a>1.输入特性曲线</h4><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><blockquote>
<p><strong>阻容耦合</strong>是指在电路中，电阻和电容之间存在相互影响的现象。通常情况下，我们认为电阻和电容是独立的元件，但在某些情况下，它们会相互影响，产生一些非预期的效应。</p>
<p>这种耦合效应可能会出现在许多不同类型的电路中，包括模拟电路和数字电路。在模拟电路中，电阻和电容的耦合可能会导致信号的失真或延迟。在数字电路中，阻容耦合可能会影响信号的稳定性和时序特性，导致逻辑错误或不稳定的操作。</p>
<p>因此，在设计和分析电路时，工程师需要考虑阻容耦合效应，以确保电路的性能和可靠性。这可能涉及到采取一些补偿措施或使用特殊的设计技术来减轻耦合效应带来的影响。</p>
<p>在电路中，电阻和电容是两种常见的元件。通常，我们认为它们是独立的，但在一些情况下，它们会相互影响，这就是阻容耦合。</p>
<p>想象一下，如果你有一根水管，水可以在其中自由流动。现在，如果你在水管的一段放置了一块海绵，海绵会吸收水并储存在其中。这时，水管的流动速度会受到海绵吸水的影响，海绵的湿度也会受到水管中水流的影响。在这个例子中，水管就像电路中的电阻，而海绵就像电路中的电容。阻容耦合就是描述电阻和电容之间这种相互影响的现象。</p>
<p>在实际电路中，阻容耦合可能会导致一些问题，比如信号传输变慢、电路的响应时间变化等。因此，在设计和分析电路时，需要考虑这种耦合效应，以确保电路的正常工作。</p>
</blockquote>
<blockquote>
<p><strong>静态工作点</strong>是指电子设备在没有输入信号时的工作状态。在放大器、晶体管等电子设备中，静态工作点通常表示设备的输出电压、电流以及输出特性的基准状态。</p>
<p>在放大器中，静态工作点通常由放大器的直流偏置电压和直流偏置电流来描述。这个状态对应于放大器没有输入信号时的输出电压和电流水平。静态工作点的选择对于设备的性能和稳定性至关重要。如果静态工作点设置不当，可能会导致设备在工作时出现失真、偏置漂移或不稳定的现象。</p>
<p>因此，在设计电路时，工程师会特别关注静态工作点，并根据设计需求和规格选择合适的偏置电压和电流，以确保设备在正常工作范围内运行。</p>
</blockquote>
<blockquote>
<p>直流偏置电压和直流偏置电流是用于控制电子设备（比如放大器、晶体管等）在静态工作点上的电压和电流值。</p>
<ol>
<li><strong>直流偏置电压（DC Bias Voltage）</strong>：<ul>
<li>在放大器或晶体管等电子设备中，直流偏置电压是用来设置设备工作在适当工作范围内的电压。它通常是在电路中通过电阻分压、电源电压等方式设置的一个恒定的电压值。</li>
<li>直流偏置电压决定了设备的工作点，即静态工作点，它对应于设备在没有输入信号时的输出状态。通过调整直流偏置电压，可以确保设备在合适的电压范围内工作，以避免过饱和或过截止等失真现象。</li>
</ul>
</li>
<li><strong>直流偏置电流（DC Bias Current）</strong>：<ul>
<li>直流偏置电流是指流经电子设备（如晶体管）的恒定电流。它通常是通过电路中设置的偏置电阻来控制的。</li>
<li>直流偏置电流也是设备静态工作点的重要参数之一。它决定了设备的工作状态，如放大器的基准电流值。正确选择直流偏置电流可以确保设备在合适的工作状态下工作，从而提高放大器的线性度和稳定性。</li>
</ul>
</li>
</ol>
<p>这两个参数一起用于确定电子设备的静态工作点，确保设备在正常工作范围内的输出特性。</p>
</blockquote>
<blockquote>
<p><strong>电压型叠加定理</strong>是电路理论中的基本原理之一，它指出在一个线性电路中，当有多个电压源作用于电路时，每个电压源单独作用时的电压可以分别计算，并且最后可以将它们的效应叠加在一起以获得电路中某一点的总电压。这个定理通常适用于直流电路和交流电路中的线性电路，对于非线性电路不适用。</p>
<h3 id="定理表述："><a href="#定理表述：" class="headerlink" title="定理表述："></a>定理表述：</h3><p>在一个电路中，假设有多个电压源<br>$$<br>V<br>total<br>​<br> &#x3D;V<br>1<br>​<br> +V<br>2<br>​<br> +V<br>3<br>​<br> +⋯+V<br>n<br>​<br>$$<br>它们分别作用于电路中的某一点，那么这一点的总电压等于各个电压源单独作用时的电压之和。</p>
<p>数学表达式如下：</p>
<p>�total&#x3D;�1+�2+�3+⋯+��<em>V</em>total&#x3D;<em>V</em>1+<em>V</em>2+<em>V</em>3+⋯+<em>V**n</em></p>
<p>其中，�total<em>V</em>total 表示电路中某一点的总电压，�1,�2,�3,…,��<em>V</em>1,<em>V</em>2,<em>V</em>3,…,<em>V**n</em> 分别表示各个电压源单独作用时的电压值。</p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ol>
<li><strong>电路分析简化</strong>：通过叠加定理，可以将复杂的电路分解为简单的部分，分别分析各个部分，最后再将它们的效应叠加在一起，从而简化电路分析的过程。</li>
<li><strong>交流电路分析</strong>：在交流电路中，可以将直流分量和交流分量分别分析，然后再将它们的效应叠加在一起。</li>
<li><strong>电路设计</strong>：在设计电路时，可以通过叠加定理来计算各个电压源的影响，从而更好地设计电路的结构和参数。</li>
</ol>
<p>总的来说，电压型叠加定理是电路分析中非常重要的原理，它为工程师提供了一种简便而有效的方法来理解和分析复杂电路系统。</p>
</blockquote>
]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>模电</tag>
        <tag>电子元件</tag>
        <tag>模拟电路</tag>
      </tags>
  </entry>
  <entry>
    <title>电子电路基础</title>
    <url>/2024/02/06/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><ul>
<li><p>VCC：C&#x3D;circuit，表示电路的意思，即接入电路的电压。</p>
</li>
<li><p>VDD：D&#x3D;device，表示器件的意思，即器件内部的工作电压。</p>
</li>
<li><p>VSS：S&#x3D;series，表示公共连接的意思，通常指电路公共接地端电压。</p>
</li>
</ul>
<h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1>]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>模电</tag>
        <tag>电子元件</tag>
        <tag>模拟电路</tag>
        <tag>电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Notes</title>
    <url>/2023/11/28/Linux-system-Notes/</url>
    <content><![CDATA[<p>A note about linux basic operation.</p>
<h1 id="系统操作"><a href="#系统操作" class="headerlink" title="*系统操作"></a>*系统操作</h1><h2 id="1-显示后台指令"><a href="#1-显示后台指令" class="headerlink" title="1.显示后台指令"></a>1.显示后台指令</h2><p>​	1.提供所有进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h2 id="提供父进程信息"><a href="#提供父进程信息" class="headerlink" title="提供父进程信息"></a>提供父进程信息</h2></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps lax</span><br></pre></td></tr></table></figure>

<h2 id="2-终止某项进程"><a href="#2-终止某项进程" class="headerlink" title="2. 终止某项进程"></a>2. 终止某项进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill pid</span><br></pre></td></tr></table></figure>

<ul>
<li>kill的意思实际上不是“杀死” ， kill 只是像程序发送一个信号</li>
</ul>
<ol start="3">
<li><h2 id="查看硬件信息"><a href="#查看硬件信息" class="headerlink" title="查看硬件信息"></a>查看硬件信息</h2></li>
</ol>
<ul>
<li>查看内存占用和 swap 分区占用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="查看CPU使用情况"><a href="#查看CPU使用情况" class="headerlink" title="查看CPU使用情况"></a>查看CPU使用情况</h2></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="*文件操作"></a>*文件操作</h1><h2 id="vim-编辑器"><a href="#vim-编辑器" class="headerlink" title="vim 编辑器"></a>vim 编辑器</h2><p><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif" alt="img"></p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter     ：代表向下翻『一行』；</li>
<li>&#x2F;字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f      ：立刻显示出档名以及目前显示的行数；</li>
<li>q       ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li><strong>&#x2F;字串   ：向下搜寻『字串』的功能；</strong></li>
<li><strong>?字串   ：向上搜寻『字串』的功能；</strong></li>
<li><strong>n     ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</strong></li>
<li><strong>N     ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</strong></li>
<li>q     ：离开 less 这个程序；</li>
</ul>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>​	读取前几行文本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head -n 20 text.txt</span><br></pre></td></tr></table></figure>

<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>​	与head相反</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n 20 text.txt</span><br></pre></td></tr></table></figure>

<h2 id="使用gzip进行压缩和解压缩"><a href="#使用gzip进行压缩和解压缩" class="headerlink" title="使用gzip进行压缩和解压缩"></a>使用gzip进行压缩和解压缩</h2><p>​	压缩：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip linuxFiles.tar</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	解压缩： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gunzip linuxFiles.tar.gz</span><br><span class="line">gzip -d linuxFiles.tar.gz</span><br></pre></td></tr></table></figure>

<p>2.文件打包tar</p>
<p>​	1.打包文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cvf linuxFiles.tar home/</span><br></pre></td></tr></table></figure>

<p>​	2.解开打包后的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf linuxFiles.tar</span><br></pre></td></tr></table></figure>

<pre><code>3. tar -w 选项，每次将选择单个文件抽出或加入
</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvwf linuxFiles.tar //</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>tar -z 自动调用gzip进行解压缩</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -czvf linuxFiles.tar.gz home/</span><br><span class="line">等价于</span><br><span class="line">tar -cvf linuxFiles.tar home/</span><br><span class="line">gzip linuxFiles.tar</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf linuxFiles.tar.gz home/</span><br><span class="line">等价于</span><br><span class="line">gzip -d linuxFiles.tar.gz</span><br><span class="line">tar -xvf linuxFiles.tar</span><br></pre></td></tr></table></figure>

<h1 id="用户权限"><a href="#用户权限" class="headerlink" title="*用户权限"></a>*用户权限</h1><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/file-llls22.jpg" alt="img"></p>
<h1 id="开放端口"><a href="#开放端口" class="headerlink" title="*开放端口"></a>*开放端口</h1><h2 id="1-查看端口"><a href="#1-查看端口" class="headerlink" title="1. 查看端口"></a>1. 查看端口</h2><h3 id="1-查看某个端口（使用管道-过滤）"><a href="#1-查看某个端口（使用管道-过滤）" class="headerlink" title="1.查看某个端口（使用管道+过滤）"></a>1.查看某个端口（使用管道+过滤）</h3><h4 id="1-一般情况下"><a href="#1-一般情况下" class="headerlink" title="1. 一般情况下"></a>1. 一般情况下</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 8080  <span class="comment"># -a(all)n(numeric)p(programs)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-netstat的其他参数"><a href="#2-netstat的其他参数" class="headerlink" title="2. netstat的其他参数"></a>2. netstat的其他参数</h4><blockquote>
<p>-a (all) 显示所有选项，默认不显示LISTEN相关。<br>-t (tcp) 仅显示tcp相关选项。<br>-u (udp) 仅显示udp相关选项。<br>-n 拒绝显示别名，能显示数字的全部转化成数字。<br>-l 仅列出有在 Listen (监听) 的服务状态。<br>-p 显示建立相关链接的程序名<br>-r 显示路由信息，路由表<br>-e 显示扩展信息，例如 uid 等<br>-s 按各个协议进行统计<br>-c 每隔一个固定时间，执行该 netstat 命令<br>LISTEN 和 LISTENING 的状态只有用 -a 或者 -l 才能看到</p>
</blockquote>
<h2 id="2-开放端口-通用"><a href="#2-开放端口-通用" class="headerlink" title="2.开放端口(通用)"></a>2.开放端口(通用)</h2><h3 id="1-防火墙的设置"><a href="#1-防火墙的设置" class="headerlink" title="1.防火墙的设置"></a>1.防火墙的设置</h3><p><strong>防火墙这一块后续还需要学习一下，很多情况下我都是直接关。。。</strong></p>
<h4 id="1-查看防火墙状态"><a href="#1-查看防火墙状态" class="headerlink" title="1. 查看防火墙状态"></a>1. 查看防火墙状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>

<p>或者（ufw）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure>



<h4 id="2-开启防火墙"><a href="#2-开启防火墙" class="headerlink" title="2.开启防火墙"></a>2.开启防火墙</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld</span><br></pre></td></tr></table></figure>

<p>或者（ufw）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure>



<h4 id="3-关闭防火墙"><a href="#3-关闭防火墙" class="headerlink" title="3. 关闭防火墙"></a>3. 关闭防火墙</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<p>或者（ufw）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw <span class="built_in">disable</span></span><br></pre></td></tr></table></figure>



<h3 id="2-端口操作"><a href="#2-端口操作" class="headerlink" title="2.端口操作"></a>2.端口操作</h3><h4 id="1-开放端口"><a href="#1-开放端口" class="headerlink" title="1.开放端口"></a>1.开放端口</h4><ul>
<li>例如开放ssh端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=22/tcp --permanent</span><br></pre></td></tr></table></figure>

<ul>
<li>使之生效</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<ul>
<li>检查是否生效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --query-port=22/tcp</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 端口</span><br></pre></td></tr></table></figure>

<h4 id="2-关闭端口"><a href="#2-关闭端口" class="headerlink" title="2.关闭端口"></a>2.关闭端口</h4><ul>
<li>限制ssh端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-port=22/tcp --permanent</span><br></pre></td></tr></table></figure>

<p>或者（ufw）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw denty 端口</span><br></pre></td></tr></table></figure>

<h1 id="任务调度"><a href="#任务调度" class="headerlink" title="*任务调度"></a>*任务调度</h1><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><blockquote>
<ul>
<li><strong>任务调度</strong>：系统在某个时间定时执行特定的命令或程序</li>
<li>任务调度的分类：<ul>
<li><strong>系统任务调度</strong>：系统某些工作需要周而复始、重复地执行，如病毒扫描、日志清理</li>
<li><strong>用户任务调度</strong>：个别用户可能需要定时执行的工作，如备份数据库、用户数据备份</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><ul>
<li>基本介绍</li>
</ul>
<blockquote>
<ol>
<li>系统任务调度配置文件目录：<code>/etc/crontab</code></li>
<li>用户的crontab文件放置于<code>/var/spool/cron</code></li>
</ol>
</blockquote>
<ul>
<li>指令介绍</li>
</ul>
<ol>
<li>参数选项</li>
</ol>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-e</td>
<td>e是edit的意识，即编辑&#x2F;设置&#x2F;修改当前用户的定时任务</td>
</tr>
<tr>
<td align="center">-l</td>
<td>l是list的意思，即列出&#x2F;查看&#x2F;打印&#x2F;输出当前用户的全部定时任务</td>
</tr>
<tr>
<td align="center">-r</td>
<td>r是remove的意思，即移除&#x2F;删除当前用户的全部定时任务</td>
</tr>
</tbody></table>
<ol start="2">
<li>语法介绍</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>开头<code>*  *  *  *  * </code>参数的解释</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>案例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>1 2 * * *</td>
<td>每天的2:01执行一次</td>
</tr>
<tr>
<td>*&#x2F;n</td>
<td>*&#x2F;5 * * * *</td>
<td>每隔5分钟执行一次</td>
</tr>
<tr>
<td>,(和)</td>
<td>1 2 3,4 * *</td>
<td>每月的3,4日2:01执行一次</td>
</tr>
<tr>
<td>-（范围）</td>
<td>1 2 3-6 * *</td>
<td>每月的3-6日2:01执行一次</td>
</tr>
</tbody></table>
<ul>
<li>使用方法</li>
</ul>
<ol>
<li>进入编辑模式</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写任务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Edit this file to introduce tasks to be run by cron.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Each task to run has to be defined through a single line</span></span><br><span class="line"><span class="comment"># indicating with different fields when the task will be run</span></span><br><span class="line"><span class="comment"># and what command to run for the task</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># To define the time you can provide concrete values for</span></span><br><span class="line"><span class="comment"># minute (m), hour (h), day of month (dom), month (mon),</span></span><br><span class="line"><span class="comment"># and day of week (dow) or use &#x27;*&#x27; in these fields (for &#x27;any&#x27;).</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Notice that tasks will be started based on the cron&#x27;s system</span></span><br><span class="line"><span class="comment"># daemon&#x27;s notion of time and timezones.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Output of the crontab jobs (including errors) is sent through</span></span><br><span class="line"><span class="comment"># email to the user the crontab file belongs to (unless redirected).</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># For example, you can run a backup of all your user accounts</span></span><br><span class="line"><span class="comment"># at 5 a.m every week with:</span></span><br><span class="line"><span class="comment"># 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># For more information see the manual pages of crontab(5) and cron(8)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># m h  dom mon dow   command</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编辑后保存退出即可</li>
</ul>
<h1 id="磁盘，分区，挂载操作"><a href="#磁盘，分区，挂载操作" class="headerlink" title="* 磁盘，分区，挂载操作"></a>* 磁盘，分区，挂载操作</h1><h2 id="linux硬盘文件系统介绍"><a href="#linux硬盘文件系统介绍" class="headerlink" title="linux硬盘文件系统介绍:"></a>linux硬盘文件系统介绍:</h2><h3 id="ext4"><a href="#ext4" class="headerlink" title="ext4:"></a>ext4:</h3><ul>
<li><p>与ext3相比，ext4文件系统可支持最高1EB的分区与最大16TB的文件</p>
</li>
<li><p>拓展了子目录的数量，理论上可以无限个</p>
</li>
<li><p>与ext3相比，引入了块组的概念，提高了存取的效率</p>
</li>
<li><p>预留空间、延迟获取空间，减少了文件的分散</p>
</li>
<li><p>更详细的inodes，提高了系统的性能</p>
</li>
<li><p>可以实现快速的文件系统检查</p>
</li>
<li><p>提供日志校验和，提高了可靠性</p>
</li>
</ul>
<h2 id="查看设备挂载情况"><a href="#查看设备挂载情况" class="headerlink" title="查看设备挂载情况"></a>查看设备挂载情况</h2><ol>
<li>所有设备</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk</span><br><span class="line">lsblk -f</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看硬盘使用情况</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>



<h2 id="新硬盘的分区以及挂载流程"><a href="#新硬盘的分区以及挂载流程" class="headerlink" title="新硬盘的分区以及挂载流程"></a>新硬盘的分区以及挂载流程</h2><ol>
<li>查看是否已经存在设备</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk</span><br><span class="line">lsblk -f</span><br></pre></td></tr></table></figure>

<p>或者查看<code>/dev/</code>下是否存在设备</p>
<ol start="2">
<li>使用fdisk进行分区设置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure>

<p>​	3.分区格式化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs  -t  ext4     /dev/sdb1</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>挂载硬盘到文件夹</li>
</ol>
<p>使用<code>mount</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sdb1 /newDisk</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>取消挂载</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unmount /dev/sdb1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>system</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT服务器搭建（mosquitto）</title>
    <url>/2024/02/09/MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88mosquitto%EF%BC%89/</url>
    <content><![CDATA[<h1 id="MQTT服务器搭建（mosquitto）"><a href="#MQTT服务器搭建（mosquitto）" class="headerlink" title="MQTT服务器搭建（mosquitto）"></a>MQTT服务器搭建（mosquitto）</h1><h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0.简介"></a>0.简介</h2><ol>
<li>简介</li>
</ol>
<blockquote>
<p>MQTT也称为”消息代理”（Broker）。</p>
<p>MQTT是一个基于客户端-服务器的消息发布&#x2F;订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
</blockquote>
<ol start="2">
<li>原理</li>
</ol>
<blockquote>
<p>MQTT协议原理<br>MQTT协议实现方式<br>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p>
<p>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）</p>
<p>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</p>
</blockquote>
<h2 id="1-mosquitto-服务端"><a href="#1-mosquitto-服务端" class="headerlink" title="1. mosquitto 服务端"></a>1. mosquitto 服务端</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install mosquitto</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/mosquitto</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件</li>
</ul>
<p>​				在 <strong>&#x2F;etc&#x2F;mosquitto&#x2F;conf.d</strong>目录下有一个叫 README 的文件，上面写了信息：</p>
<blockquote>
<h1 id="Any-files-placed-in-this-directory-that-have-a-conf-ending-will-be-loaded-as-config-files-by-the-broker-Use-this-to-make-your-local-config"><a href="#Any-files-placed-in-this-directory-that-have-a-conf-ending-will-be-loaded-as-config-files-by-the-broker-Use-this-to-make-your-local-config" class="headerlink" title="Any files placed in this directory that have a .conf ending will be loaded as config files by the broker. Use this to make your local config."></a>Any files placed in this directory that have a .conf ending will be loaded as config files by the broker. Use this to make your local config.</h1></blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/mosquitto/conf.d</span><br><span class="line"></span><br><span class="line">vim config.conf</span><br><span class="line"><span class="comment"># 添加下面配置</span></span><br><span class="line"><span class="comment"># 不允许匿名访问</span></span><br><span class="line">allow_anonymous <span class="literal">false</span></span><br><span class="line"><span class="comment"># 配置端口</span></span><br><span class="line">listener 1883</span><br><span class="line"><span class="comment"># 设置密码文件保存目录</span></span><br><span class="line">password_file /etc/mosquitto/pwfile.example</span><br></pre></td></tr></table></figure>

<ul>
<li>运行配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mosquitto -c /etc/mosquitto/conf.d/config.conf -v</span><br></pre></td></tr></table></figure>

<ul>
<li>添加用户</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mosquitto_passwd -c /etc/mosquitto/pwfile.example username</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关闭防火墙！！！</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ufw <span class="built_in">disable</span></span><br><span class="line"><span class="comment"># 或者添加规则</span></span><br><span class="line">ufw allow 1883</span><br></pre></td></tr></table></figure>

<h2 id="2-mosquitto-clients-客户端"><a href="#2-mosquitto-clients-客户端" class="headerlink" title="2. mosquitto-clients 客户端"></a>2. mosquitto-clients 客户端</h2><ul>
<li>用户登录订阅，发布</li>
</ul>
<p>​	其实一般都是接近被控设备的系统，比如各种Mcu（esp32，esp8266）等等。这部分将在寒假进行补充（在另外一篇博客）。<a href="https://regenm.gitee.io/">esp8266或者esp32等</a></p>
<p>对于Linux客户，可以是模拟器（ ISH ，Termux）</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install mosquitto-clients</span><br></pre></td></tr></table></figure>

<ul>
<li>订阅</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mosquitto_sub -h <span class="string">&quot;IP address&quot;</span> -p 1883 -u username -P regen -t <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>发布</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mosquitto_pub -h <span class="string">&quot;IP address&quot;</span> -p 1883 -u username -P regen -t <span class="string">&quot;test&quot;</span> -m <span class="string">&quot;hello mqtt! hello ! mosquitto!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-mosquitto使用"><a href="#3-mosquitto使用" class="headerlink" title="3. mosquitto使用"></a>3. mosquitto使用</h2><ul>
<li><strong>脚本制作</strong></li>
</ul>
<p>​				为了方便 mosquitto 的使用，可以写几个脚本用于发布和订阅</p>
<ol>
<li>发布</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim regenMosquittoScriptSendRemote.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mosquitto_pub -h <span class="string">&quot;IP address&quot;</span> -p 1883 -u username -P regen -t <span class="string">&quot;test&quot;</span> -m <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	赋权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 regenMosquittoScriptSendRemote.sh</span><br></pre></td></tr></table></figure>

<p>​	运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./regenMosquittoScriptSendRemote.sh hello!</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>订阅，同理</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim regenMosquittoScriptSubRemote.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mosquitto_sub -h <span class="string">&quot;IP address&quot;</span> -p 1883 -u username -P regen -t <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	赋权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 regenMosquittoScriptSubRemote.sh</span><br></pre></td></tr></table></figure>

<p>​	运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./regenMosquittoScriptSendRemote.sh topic</span><br></pre></td></tr></table></figure>

<ul>
<li>连接esp32或8266</li>
</ul>
<p>看看这个esp8266连接mqtt服务器的项目吗？(<a href="https://regenm.gitee.io/2024/02/09/esp8266%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9F%BA%E4%BA%8Emosquitto%E7%9A%84mqtt-server%EF%BC%89/">esp8266连接服务器（基于mosquitto的mqtt server） | Regen (gitee.io)</a></p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>mqtt</tag>
        <tag>IoT</tag>
        <tag>mosquitto</tag>
      </tags>
  </entry>
  <entry>
    <title>esp8266连接服务器（基于mosquitto的mqtt server）</title>
    <url>/2024/02/09/esp8266%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9F%BA%E4%BA%8Emosquitto%E7%9A%84mqtt-server%EF%BC%89/</url>
    <content><![CDATA[<ul>
<li><p>Time：2024-02-09 00:39:50</p>
</li>
<li><p>还挺兴奋的，这个项目算是我自己搭建云服务器的最后一步。</p>
</li>
</ul>
<h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><p>​	起因是想要自己搭建云服务器，同时还想要利用手上已经有的esp8266开发板实现对该服务器的远程控制（开关机）。</p>
<p>​	本来打算整一个备用电源给服务器供电，奈何这台服务器是普通PC，即使配置已经很低（与现代PC比较为拉胯，但是比大多数出售的服务器例如某云2核4g更加）但功耗的保守估计已经超过70w。</p>
<p>​	于是便打算使用远程开关降低平均功耗。同时进行物联网方面知识的扫盲与学习。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h2><p>​	首先，在已经搭建好的mqtt服务器上创建了用户<code>user</code>和密码<code>passwd</code>，同时处于安全性考虑禁止匿名访问。<a href="https://regenm.gitee.io/2024/02/09/MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88mosquitto%EF%BC%89/">配置mqtt服务器的过程</a>)</p>
<p>​	创建好测试主题（topic）<code>test</code>后进行测试。多平台测试收发message没问题。</p>
<h2 id="2-中期打BOSS"><a href="#2-中期打BOSS" class="headerlink" title="2.中期打BOSS"></a>2.中期打BOSS</h2><p>​	接下来就是攻克esp8266这边的问题了。</p>
<ul>
<li>问题一：esp8266开发环境</li>
</ul>
<p>​	由于这块esp8266开发板是我在高中时期玩的，那时候的电脑早已坏掉，这台电脑的arduinoIDE 还未配置esp8266的环境。</p>
<p>​	本来打算使用platformIO但是太慢了，在下载框架以及支持的时候解决了ide的问题。。。</p>
<blockquote>
<p>需要配置：</p>
<ul>
<li>添加支持esp8266开发板</li>
</ul>
<p>方法一：ide设置里的 Additional boards manager URLs添加<code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code></p>
<p>方法二：手动添加：下载esp8266_package_installer直接离线下载</p>
<ul>
<li>增加库：<ul>
<li><code>&lt;PubSubClient.h&gt;</code></li>
<li><code>ESP8266WiFi.h</code></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>问题二：esp8266连接不成功</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MQTT Server Connect Failed. Client State:-2</span><br><span class="line">MQTT Server Connect Failed. Client State:-2</span><br><span class="line">MQTT Server Connect Failed. Client State:-2</span><br><span class="line">MQTT Server Connect Failed. Client State:-2</span><br><span class="line">MQTT Server Connect Failed. Client State:-2</span><br><span class="line">MQTT Server Connect Failed. Client State:-2</span><br></pre></td></tr></table></figure>

<p>​		其实主要是平台的问题，8266，以及PubSubClient.h库中的案例程序和大多数网上教程都是使用的别人的mqtt服务器，他们往往不需要提供账号密码等等。例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Basic MQTT example</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> This sketch demonstrates the basic capabilities of the library.</span></span><br><span class="line"><span class="comment"> It connects to an MQTT server then:</span></span><br><span class="line"><span class="comment">  - publishes &quot;hello world&quot; to the topic &quot;outTopic&quot;</span></span><br><span class="line"><span class="comment">  - subscribes to the topic &quot;inTopic&quot;, printing out any messages</span></span><br><span class="line"><span class="comment">    it receives. NB - it assumes the received payloads are strings not binary</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> It will reconnect to the server if the connection is lost using a blocking</span></span><br><span class="line"><span class="comment"> reconnect function. See the &#x27;mqtt_reconnect_nonblocking&#x27; example for how to</span></span><br><span class="line"><span class="comment"> achieve the same result without blocking the main loop.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ethernet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;PubSubClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update these with values suitable for your network.</span></span><br><span class="line">byte mac[]    = &#123;  <span class="number">0xDE</span>, <span class="number">0xED</span>, <span class="number">0xBA</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xED</span> &#125;;</span><br><span class="line"><span class="function">IPAddress <span class="title">ip</span><span class="params">(<span class="number">172</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">IPAddress <span class="title">server</span><span class="params">(<span class="number">172</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">char</span>* topic, byte* payload, <span class="type">unsigned</span> <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Message arrived [&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(topic);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;] &quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>((<span class="type">char</span>)payload[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EthernetClient ethClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">client</span><span class="params">(ethClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Loop until we&#x27;re reconnected</span></span><br><span class="line">  <span class="keyword">while</span> (!client.<span class="built_in">connected</span>()) &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;Attempting MQTT connection...&quot;</span>);</span><br><span class="line">    <span class="comment">// Attempt to connect</span></span><br><span class="line">      <span class="comment">/*----------------------------区别（报错位置）---------------------------*/</span></span><br><span class="line">    <span class="keyword">if</span> (client.<span class="built_in">connect</span>(<span class="string">&quot;arduinoClient&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">/*----------------------------区别（报错位置）---------------------------*/</span></span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">      <span class="comment">// Once connected, publish an announcement...</span></span><br><span class="line">      client.<span class="built_in">publish</span>(<span class="string">&quot;outTopic&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">      <span class="comment">// ... and resubscribe</span></span><br><span class="line">      client.<span class="built_in">subscribe</span>(<span class="string">&quot;inTopic&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;failed, rc=&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(client.<span class="built_in">state</span>());</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot; try again in 5 seconds&quot;</span>);</span><br><span class="line">      <span class="comment">// Wait 5 seconds before retrying</span></span><br><span class="line">      <span class="built_in">delay</span>(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">57600</span>);</span><br><span class="line"></span><br><span class="line">  client.<span class="built_in">setServer</span>(server, <span class="number">1883</span>);</span><br><span class="line">  client.<span class="built_in">setCallback</span>(callback);</span><br><span class="line"></span><br><span class="line">  Ethernet.<span class="built_in">begin</span>(mac, ip);</span><br><span class="line">  <span class="comment">// Allow the hardware to sort itself out</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!client.<span class="built_in">connected</span>()) &#123;</span><br><span class="line">    <span class="built_in">reconnect</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  client.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	以及太极创客的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project          : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name     : publish_ranye_url</span></span><br><span class="line"><span class="comment">团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment">作者/Author              : CYNO朔</span></span><br><span class="line"><span class="comment">日期/Date（YYYYMMDD）     : 20200813</span></span><br><span class="line"><span class="comment">程序目的/Purpose          : </span></span><br><span class="line"><span class="comment">本程序旨在演示如何使用PubSubClient库使用ESP8266向MQTT服务器发布信息。</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。</span></span><br><span class="line"><span class="comment">该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：</span></span><br><span class="line"><span class="comment">http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;PubSubClient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ticker.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置wifi接入信息(请根据您的WiFi信息进行修改)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;lkw&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;01234567890&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* mqttServer = <span class="string">&quot;192.168.43.61&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如以上MQTT服务器无法正常连接，请前往以下页面寻找解决方案</span></span><br><span class="line"><span class="comment">// http://www.taichi-maker.com/public-mqtt-broker/</span></span><br><span class="line"></span><br><span class="line">Ticker ticker;</span><br><span class="line">WiFiClient wifiClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">mqttClient</span><span class="params">(wifiClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;    <span class="comment">// Ticker计数用变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置ESP8266工作模式为无线终端模式</span></span><br><span class="line">  WiFi.<span class="built_in">mode</span>(WIFI_STA);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 连接WiFi</span></span><br><span class="line">  <span class="built_in">connectWifi</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置MQTT服务器和端口号</span></span><br><span class="line">  mqttClient.<span class="built_in">setServer</span>(mqttServer, <span class="number">1883</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接MQTT服务器</span></span><br><span class="line">  <span class="built_in">connectMQTTServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ticker定时对象</span></span><br><span class="line">  ticker.<span class="built_in">attach</span>(<span class="number">1</span>, tickerCount);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (mqttClient.<span class="built_in">connected</span>()) &#123; <span class="comment">// 如果开发板成功连接服务器</span></span><br><span class="line">    <span class="comment">// 每隔3秒钟发布一次信息</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">      <span class="built_in">pubMQTTmsg</span>();</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 保持心跳</span></span><br><span class="line">    mqttClient.<span class="built_in">loop</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// 如果开发板未能成功连接服务器</span></span><br><span class="line">    <span class="built_in">connectMQTTServer</span>();    <span class="comment">// 则尝试连接服务器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tickerCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------------------------区别（报错位置）---------------------------*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectMQTTServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 根据ESP8266的MAC地址生成客户端ID（避免与其它ESP8266的客户端ID重名）</span></span><br><span class="line">  String clientId = <span class="string">&quot;esp8266-&quot;</span> + WiFi.<span class="built_in">macAddress</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接MQTT服务器</span></span><br><span class="line">  <span class="keyword">if</span> (mqttClient.<span class="built_in">connect</span>(clientId.<span class="built_in">c_str</span>())) &#123; </span><br><span class="line"><span class="comment">/*----------------------------区别（报错位置）---------------------------*/</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;MQTT Server Connected.&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Server Address: &quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(mqttServer);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;ClientId:&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(clientId);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;MQTT Server Connect Failed. Client State:&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(mqttClient.<span class="built_in">state</span>());</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">3000</span>);</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pubMQTTmsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> value; <span class="comment">// 客户端发布信息用数字</span></span><br><span class="line"></span><br><span class="line">  String topicString = <span class="string">&quot;lkwMQTTtopic&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> publishTopic[topicString.<span class="built_in">length</span>() + <span class="number">1</span>];  </span><br><span class="line">  <span class="built_in">strcpy</span>(publishTopic, topicString.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立发布信息。信息内容以Hello World为起始，后面添加发布次数。</span></span><br><span class="line">  String messageString = <span class="string">&quot;Hello World &quot;</span> + <span class="built_in">String</span>(value++); </span><br><span class="line">  <span class="type">char</span> publishMsg[messageString.<span class="built_in">length</span>() + <span class="number">1</span>];   </span><br><span class="line">  <span class="built_in">strcpy</span>(publishMsg, messageString.<span class="built_in">c_str</span>());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实现ESP8266向主题发布信息</span></span><br><span class="line">  <span class="keyword">if</span>(mqttClient.<span class="built_in">publish</span>(publishTopic, publishMsg))&#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Publish Topic:&quot;</span>);Serial.<span class="built_in">println</span>(publishTopic);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Publish message:&quot;</span>);Serial.<span class="built_in">println</span>(publishMsg);    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Message Publish Failed.&quot;</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ESP8266连接wifi</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectWifi</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  WiFi.<span class="built_in">begin</span>(ssid, password);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//等待WiFi连接,成功连接后输出成功信息</span></span><br><span class="line">  <span class="keyword">while</span> (WiFi.<span class="built_in">status</span>() != WL_CONNECTED) &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;WiFi Connected!&quot;</span>);  </span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方法：查看<code>PubSubClient</code>的源代码</p>
<p>幸亏结构挺简单，很容易就找到了想要的代码即<code>PubSubClient的connect方法</code></p>
<ul>
<li>在<code>PubSubClient.h</code></li>
</ul>
<p><img src="/images/esp8266_mqtt/PubSubClientH.png" alt="PubSubClientH"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* id)</span></span>;</span><br><span class="line">  <span class="function">boolean <span class="title">connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* id, <span class="type">const</span> <span class="type">char</span>* user, <span class="type">const</span> <span class="type">char</span>* pass)</span></span>;</span><br><span class="line">  <span class="function">boolean <span class="title">connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* id, <span class="type">const</span> <span class="type">char</span>* willTopic, <span class="type">uint8_t</span> willQos, boolean willRetain, <span class="type">const</span> <span class="type">char</span>* willMessage)</span></span>;</span><br><span class="line">  <span class="function">boolean <span class="title">connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* id, <span class="type">const</span> <span class="type">char</span>* user, <span class="type">const</span> <span class="type">char</span>* pass, <span class="type">const</span> <span class="type">char</span>* willTopic, <span class="type">uint8_t</span> willQos, boolean willRetain, <span class="type">const</span> <span class="type">char</span>* willMessage)</span></span>;</span><br><span class="line">  <span class="function">boolean <span class="title">connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* id, <span class="type">const</span> <span class="type">char</span>* user, <span class="type">const</span> <span class="type">char</span>* pass, <span class="type">const</span> <span class="type">char</span>* willTopic, <span class="type">uint8_t</span> willQos, boolean willRetain, <span class="type">const</span> <span class="type">char</span>* willMessage, boolean cleanSession)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在<code>PubSubClient.cpp</code></p>
<p><img src="/images/esp8266_mqtt/PubSubClientCPP.png" alt="PubSubClientCPP"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">boolean <span class="title">PubSubClient::connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">connect</span>(id,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">boolean <span class="title">PubSubClient::connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *id, <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *pass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">connect</span>(id,user,pass,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">boolean <span class="title">PubSubClient::connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *id, <span class="type">const</span> <span class="type">char</span>* willTopic, <span class="type">uint8_t</span> willQos, boolean willRetain, <span class="type">const</span> <span class="type">char</span>* willMessage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">connect</span>(id,<span class="literal">NULL</span>,<span class="literal">NULL</span>,willTopic,willQos,willRetain,willMessage,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">boolean <span class="title">PubSubClient::connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *id, <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *pass, <span class="type">const</span> <span class="type">char</span>* willTopic, <span class="type">uint8_t</span> willQos, boolean willRetain, <span class="type">const</span> <span class="type">char</span>* willMessage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">connect</span>(id,user,pass,willTopic,willQos,willRetain,willMessage,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">boolean <span class="title">PubSubClient::connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *id, <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *pass, <span class="type">const</span> <span class="type">char</span>* willTopic, <span class="type">uint8_t</span> willQos, boolean willRetain, <span class="type">const</span> <span class="type">char</span>* willMessage, boolean cleanSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">connected</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(_client-&gt;<span class="built_in">connected</span>()) &#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/******************省略*****************/</span></span><br></pre></td></tr></table></figure>

<p>​	于是就得出 connect 重载函数本体只有一个，即最后一个，我可以修改输入的参数实现自己想要的功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">PubSubClient::connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *id, <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *pass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">connect</span>(id,user,pass,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-结尾"><a href="#3-结尾" class="headerlink" title="3.结尾"></a>3.结尾</h2><p>先附上自己的代码，修改了连接模板代码 部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;PubSubClient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ticker.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置wifi接入信息(请根据您的WiFi信息进行修改)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;MERCURY_F80E&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;********&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* mqttServer = <span class="string">&quot;regenm.gitee.io&quot;</span>;</span><br><span class="line"></span><br><span class="line">Ticker ticker;</span><br><span class="line">WiFiClient wifiClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">mqttClient</span><span class="params">(wifiClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;  <span class="comment">// Ticker计数用变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置ESP8266工作模式为无线终端模式</span></span><br><span class="line">  WiFi.<span class="built_in">mode</span>(WIFI_STA);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接WiFi</span></span><br><span class="line">  <span class="built_in">connectWifi</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置MQTT服务器和端口号</span></span><br><span class="line">  mqttClient.<span class="built_in">setServer</span>(mqttServer, <span class="number">1883</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接MQTT服务器</span></span><br><span class="line">  <span class="built_in">connectMQTTServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ticker定时对象</span></span><br><span class="line">  ticker.<span class="built_in">attach</span>(<span class="number">1</span>, tickerCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mqttClient.<span class="built_in">connected</span>()) &#123;  <span class="comment">// 如果开发板成功连接服务器</span></span><br><span class="line">    <span class="comment">// 每隔3秒钟发布一次信息</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">pubMQTTmsg</span>();</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保持心跳</span></span><br><span class="line">    mqttClient.<span class="built_in">loop</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 如果开发板未能成功连接服务器</span></span><br><span class="line">    <span class="built_in">connectMQTTServer</span>();  <span class="comment">// 则尝试连接服务器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tickerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectMQTTServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据ESP8266的MAC地址生成客户端ID（避免与其它ESP8266的客户端ID重名）</span></span><br><span class="line">  String clientId = <span class="string">&quot;regen&quot;</span>;</span><br><span class="line">  String userRegen = <span class="string">&quot;user&quot;</span>;</span><br><span class="line">  String passwdRegen = <span class="string">&quot;passwd&quot;</span>;</span><br><span class="line">  <span class="comment">// 连接MQTT服务器 </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* --------------------connect(id,user,pass,0,0,0,0,1)-------------------- */</span></span><br><span class="line">  <span class="keyword">if</span> (mqttClient.<span class="built_in">connect</span>(clientId.<span class="built_in">c_str</span>(),userRegen.<span class="built_in">c_str</span>() ,passwdRegen.<span class="built_in">c_str</span>() )) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;MQTT Server Connected.&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Server Address: &quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(mqttServer);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;ClientId:&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(clientId);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;MQTT Server Connect Failed. Client State:&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(mqttClient.<span class="built_in">state</span>());</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pubMQTTmsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> value;  <span class="comment">// 客户端发布信息用数字</span></span><br><span class="line"></span><br><span class="line">  String topicString = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> publishTopic[topicString.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(publishTopic, topicString.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立发布信息。信息内容以Hello World为起始，后面添加发布次数。</span></span><br><span class="line">  String messageString = <span class="string">&quot;Hello World &quot;</span> + <span class="built_in">String</span>(value++);</span><br><span class="line">  <span class="type">char</span> publishMsg[messageString.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(publishMsg, messageString.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现ESP8266向主题发布信息</span></span><br><span class="line">  <span class="keyword">if</span> (mqttClient.<span class="built_in">publish</span>(publishTopic, publishMsg)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Publish Topic:&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(publishTopic);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Publish message:&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(publishMsg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Message Publish Failed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ESP8266连接wifi</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectWifi</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  WiFi.<span class="built_in">begin</span>(ssid, password);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待WiFi连接,成功连接后输出成功信息</span></span><br><span class="line">  <span class="keyword">while</span> (WiFi.<span class="built_in">status</span>() != WL_CONNECTED) &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;WiFi Connected!&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	经过测试后成功，附上截图：</p>
<p><img src="/images/esp8266_mqtt/success1.png" alt="success"></p>
<p><img src="/images/esp8266_mqtt/success2.jpg" alt="success"></p>
<p><img src="/images/esp8266_mqtt/success3.png" alt="success"></p>
]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>linux</tag>
        <tag>mqtt</tag>
        <tag>IoT</tag>
        <tag>mosquitto</tag>
        <tag>esp8266</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器技术</title>
    <url>/2024/02/09/docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>constructing</p>
<p>toBeContinued</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>​				docker是一个用Go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所有的依赖都打包到docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，<strong>程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系</strong>。</p>
<p>​				因此我们可以看到docker可以屏蔽环境差异，也就是说，只要你的程序打包到了docker中，那么无论运行在什么环境下程序的行为都是一致的，程序员再也无法施展表演才华了，<strong>不会再有“在我的环境上可以运行”</strong>，真正实现“build once, run everywhere”。</p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>​	docker 中的几个概念：</p>
<blockquote>
<ol>
<li>dockerfile</li>
<li>image</li>
<li>container</li>
</ol>
</blockquote>
<h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p>​	<code>Dockerfile</code> 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。感觉就像<code>makefile</code>一样。</p>
<h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>​	Docker镜像（Docker Image）就是一个只读的模板。比如，一个镜像可以包含一个完整的<a href="https://so.csdn.net/so/search?q=Ubuntu&spm=1001.2101.3001.7020">Ubuntu</a>操作系统环境。镜像可以用来创建Docker容器。</p>
<h2 id="container"><a href="#container" class="headerlink" title="container"></a>container</h2><p>​	容器是镜像的运行时实例，容器是独立运行的一个或一组应用，以及它们的运行态环境。</p>
<p>​	</p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>《流星之绊》</title>
    <url>/2024/02/17/%E3%80%8A%E6%B5%81%E6%98%9F%E4%B9%8B%E7%BB%8A%E3%80%8B/</url>
    <content><![CDATA[<h1 id="《流星之绊》"><a href="#《流星之绊》" class="headerlink" title="《流星之绊》"></a>《流星之绊》</h1><p>​	一直想看看短篇小说，想要重新体验一下过去一次性读完一本短篇的感觉（吃快餐…嘘！）。于是就立马想到了东野圭吾和村上春树。</p>
<p>​	偶然发现原来我还有很多没看过的东野圭吾的作品。其中就有这本《流星之绊》，只消半个夜晚就看毕了，关上ipad，躺在床上，他们三兄妹以及他们的故事在脑海里不断重现。</p>
<blockquote>
<p>“我们三人就像流星，毫无目标地飞逝，不知将在何处燃烧殆尽。”</p>
</blockquote>
<p>​	看完后感觉剧情挺一般的，好像这本书少了点东野圭吾的味道了。如果是换做以前的我，大概会觉得这本书挺温暖的，至少就结局来说。也许我真的已经长大了，已经不在相信书里的奇迹了或者说已经不太习惯大团圆结局了。</p>
<p>​	看的时候就觉得这个剧情很适合拍成电视剧供像我一样百无聊赖的人群观看，第二天一查，没想到真的有日剧，而且好像日剧的受众还更广一点。</p>
<p>​	流星之绊啊，我一开始其实是理解为像流星一样转瞬即逝的羁绊，后来才知道是一起约定看流星的羁绊。虽然流星易逝，但是观看流星的他们之间的羁绊却被永远铭记。</p>
<blockquote>
<p>“</p>
<p>然而最美的流星永远是第一次映入眼帘的那颗<br>“第一次”给人的永恒美是人们对“纯真”最后的忠诚<br>流星雨<br>那年也因狮子座流星雨二更而起<br>无数渴望的眼睛在凝视中等待世纪之美的来临<br>可不懂风情的夜空却久久星光依旧<br>剩下一群疯狂的少年奔跑在老师撕心裂肺的呐喊声中<br>未能如期而至的流星雨<br>却留下了无法再来的回忆</p>
<p>“</p>
</blockquote>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>《树上的男爵》</title>
    <url>/2024/02/18/%E3%80%8A%E6%A0%91%E4%B8%8A%E7%9A%84%E7%94%B7%E7%88%B5%E3%80%8B/</url>
    <content><![CDATA[<p>​	</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>PHOTO</title>
    <url>/2024/02/27/PHOTO/</url>
    <content><![CDATA[<h1 id="说走就走（南昌）"><a href="#说走就走（南昌）" class="headerlink" title="说走就走（南昌）"></a>说走就走（南昌）</h1><p>​	去完南昌回来之后几天。想了想，果然还是想记下来当时间胶囊。</p>
<p>​	回家那一刻我就知道了2024的寒假注定是灰色的，看到最近天气15日阴天，以及温度逐渐下降甚至出现下雪的时候，我心情是复杂的。</p>
<p>​	上学期因荒废暑假后在学期中越想越痛，于是就发誓要好好利用寒假出去逛一逛，看看不同城市的风景。看到这天气后就有点挫伤。</p>
<p>​	于是就怀着这越来越渺茫的希望，打了把又一把游戏。</p>
<p>​	时机已到！那天下午，澡后我感到十分清爽，应该是内啡肽的作用。恰巧温度回升，下午的太阳也很舒服，就是现在！出发！</p>
<p>​	然而刚到市里就开始下雨了。。。。。。我还没带伞，包里就一个没电的相机和一本书。（《杀死一只知更鸟》英文原著）</p>
<p><img src="/images/nanchang/Nikon2023_5_3_332023_6_1163.jpg"></p>
<p><img src="/images/nanchang/Nikon2023_5_3_332023_6_1164.jpg"></p>
<p>​	好在火车上比较舒服，看看书，打了个盹就到了。刚好看完前半部分。看到了高中时期最喜欢的一段。</p>
<blockquote>
<p><strong>我想让你见识一下什么是真正的勇敢，而不要错误地认为一个人手握枪支就是勇敢。勇敢是：当你还未开始就已知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。你很少能贏，但有时也会。杜博斯太太赢了，用她那仅仅九十八磅重的身躯。按照她的观点，她死得无怨无悔，不欠任何人，也不依赖任何东西。她是我见过的最勇敢的人。</strong></p>
</blockquote>
<blockquote>
<p><strong>“ I wanted you to see what real courage is, instead of getting the idea that courage is a man with a gun in his hand. It’s when you know you’re licked before you begin but you begin anyway and you see it through no matter what. You rarely win, but sometimes you do. Mrs. Dubose won, all ninety-eight pounds of her. According to her views, she died beholden to nothing and nobody. She was the bravest person I ever knew. “</strong></p>
</blockquote>
<p>​	第二天早上，大雨，开始后悔。</p>
<p>​	在滕王阁附近的洪都大拇指奶茶店点了一杯推荐，坐在墙角的小板凳上，看着越下越大的雨，耳边Ólafur Arnalds的《1440》更增加了凄惨的氛围。 能够稍微安慰我的也就只有 手上的 “雪顶幽兰”逐渐散去的余热了。</p>
<p><img src="/images/nanchang/Nikon2023_5_3_332023_6_1165.jpg" alt="路上"></p>
<p><img src="/images/nanchang/Nikon2023_5_3_332023_6_1166.jpg"></p>
<p><img src="/images/nanchang/Nikon2023_5_3_332023_6_1170.jpg" alt="远处"></p>
<p>​	走近看才发现滕王阁原来这么大 ，虽然古人上滕王阁是用爬的，但是时代不一样了，有电梯了。 但是迁客骚人的览物之情却没怎么变化（古今对比），从最顶楼的许愿牌便可得出此结论。</p>
<p><img src="/images/nanchang/Nikon2023_5_3_332023_6_1172.jpg" alt="顶"></p>
<p><img src="/images/nanchang/Nikon2023_5_3_332023_6_1168.jpg" alt="檐"></p>
<p>​	越下越大的雨好像放大了览物之情，让我突然想念起了坐在电炉前乱弹吉他的温暖。于是便回家了······</p>
<hr>
]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>摄影</tag>
        <tag>photo</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Composition Principle</title>
    <url>/2024/02/27/Computer-Composition-Principle/</url>
    <content><![CDATA[<p>​			计算机组成原理</p>
<p>&#x3D;&#x3D;HIghLIght &#x3D;&#x3D;</p>
<h1 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h1><h2 id="计算机基本组成"><a href="#计算机基本组成" class="headerlink" title="计算机基本组成"></a>计算机基本组成</h2><h3 id="冯诺依曼计算机"><a href="#冯诺依曼计算机" class="headerlink" title="冯诺依曼计算机"></a>冯诺依曼计算机</h3><ul>
<li>特点</li>
</ul>
<ol>
<li>五大部件：运算器（ALU），控制器（CU），存储器（MEM），输入输出（I&#x2F;O）</li>
<li>指令与数据同等地位存储与存储器</li>
<li>使用二进制</li>
<li>指令由操作码和地址码组成</li>
<li>指令在存储器内顺序存放</li>
<li>以运算器为中心（现代计算以存储器为中心）</li>
</ol>
<h3 id="计算机工作过程"><a href="#计算机工作过程" class="headerlink" title="计算机工作过程"></a>计算机工作过程</h3><h4 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h4><ul>
<li><p>存储体：由存储单元组成（存储单元由存储原件组成，存储原件存储0和1）</p>
</li>
<li><p>存储字：存储单元中的二进制代码组合（？）</p>
</li>
<li><p>存储字长：</p>
</li>
<li><p>MAR：存储器的地址寄存器</p>
</li>
<li><p>MDR：存储器的数据寄存器</p>
</li>
</ul>
<h4 id="运算器的基本组成以及操作过程"><a href="#运算器的基本组成以及操作过程" class="headerlink" title="运算器的基本组成以及操作过程"></a>运算器的基本组成以及操作过程</h4><ul>
<li>ACC：	被加数，被减数，乘积高位，被除数，余数</li>
<li>ALU（算术逻辑单元）： </li>
<li>MQ： 	乘数，乘积低位</li>
</ul>
<h4 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h4><ul>
<li>CU：控制单元</li>
<li>IR：指令寄存器</li>
<li>PC：程序计数器</li>
</ul>
<h3 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h3><ol>
<li>机器字长<br> CPU一次能处理的数据位数与ALU中的寄存器位数有关</li>
<li>运算速度</li>
</ol>
<ul>
<li>MIP<strong>（Million Instructions Per Second）</strong></li>
</ul>
<p>​	表示每秒钟能够执行的指令数量。不考虑指令的复杂度和执行时间。</p>
<ul>
<li>MIPS<strong>（Million Instructions Per Second）</strong></li>
</ul>
<p>​	表示每秒钟能够执行的指令数量。MIPS通常用于描述某个特定计算机系统的实际性能，考虑了指令的复杂度和执行时间。</p>
<ul>
<li>CPI<strong>（Cycles Per Instruction）</strong></li>
</ul>
<p>​	表示每条指令执行所需的时钟周期数。CPI的倒数也常被用作衡量计算机性能的指标之一，称为IPC（Instructions Per Cycle）。</p>
<ul>
<li>FLOPS<strong>（Floating Point Operations Per Second）</strong></li>
</ul>
<p>​	表示每秒钟能够执行的浮点运算次数。FLOPS是衡量计算机在执行浮点运算时的速度和效率的重要指标之一。</p>
<h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>使用总线的原因：希望随时增加或减少设备</li>
<li>总线的定义: 链接多个部件的信息传输线，是各部件信息共享的传输介质</li>
</ul>
<h2 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h2><p>​	按照数据传输方式：并行传输总线，串行传输总线</p>
<h3 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h3><p>​	芯片内部的总线</p>
<h3 id="系统总线-1"><a href="#系统总线-1" class="headerlink" title="系统总线"></a>系统总线</h3><ul>
<li>系统总线的定义：是指CPU，主存，I&#x2F;O各大部件之间的信息传输线</li>
</ul>
<h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>​	传输各部件之间的数据信息</p>
<ul>
<li>特点</li>
</ul>
<ol>
<li>双向传输</li>
<li>与机器字长，存储字长有关</li>
<li>数据总线位数即数据总线宽度</li>
</ol>
<h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><ul>
<li>特点：</li>
</ul>
<ol>
<li>用于指明CPU欲访问的存储单元或I&#x2F;O端口的地址。</li>
<li><strong>单向</strong>输出（仅由CPU输出）</li>
</ol>
<h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>​	为了使各个部件在不同时刻占有总线使用权</p>
<ul>
<li>特点</li>
</ul>
<ol>
<li>对于特定控制线：单向的，对于控制总线总体来说是双向的</li>
<li>对于CPU来说，控制信号既有输出也有输入</li>
</ol>
<ul>
<li>常见控制信号<br>  时钟，复位，总线请求和允许，中断请求和响应，存储器读写，IO读写，传输响应</li>
</ul>
<h3 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h3><pre><code>目的：用于计算机系统之间活着计算机系统与其他系统之间的通信。
</code></pre>
<h4 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h4><ol>
<li>串行通信总线（远距离）</li>
<li>并行通信总线（近距离）</li>
</ol>
<h1 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h1><ol>
<li>总线宽度（数据总线的宽度）</li>
<li>总线带宽（总线的数据传输速率）</li>
<li>时钟同步&#x2F;异步：分为同步总线，异步总线</li>
<li>总线复用：分时使用与地址或者数据</li>
<li>信号线数：地址，数据，控制总线总和</li>
<li>总线控制方式</li>
<li>其他指标</li>
</ol>
<h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><ol>
<li>ISA</li>
<li>EISA</li>
<li>VL-BUS</li>
<li>PCI</li>
<li>AGP</li>
</ol>
<h2 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h2><h3 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h3><ul>
<li>总线判优控制的分类<ul>
<li>集中式：有链式查询，计数器定时查询，独立请求方式</li>
<li>分布式</li>
</ul>
</li>
</ul>
<h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><ul>
<li>特点：</li>
</ul>
<ol>
<li>离总线控制部件最近的设备具有最高优先级 </li>
<li>只需很少几根线</li>
<li>容易扩充设备</li>
<li>对电路故障很敏感</li>
<li>优先级低的设备很难获取请求</li>
</ol>
<h4 id="计数器定时查询"><a href="#计数器定时查询" class="headerlink" title="计数器定时查询"></a>计数器定时查询</h4><ul>
<li>特点：</li>
</ul>
<ol>
<li>优先次序可变，并且是顺序，</li>
<li>设备使用总线的优先级相等</li>
<li>增加了控制线数，控制复杂。</li>
<li>对电路故障敏感度不如链式查询</li>
</ol>
<h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><ul>
<li>特点：</li>
</ul>
<ol>
<li>响应速度快</li>
<li>优先次序灵活</li>
<li>控制线多，控制复杂</li>
</ol>
<h3 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h3><ul>
<li>目的：解决通信双方协调配合的问题。</li>
<li>分类：<ul>
<li>通常有：同步，异步，半同步，分离式。</li>
</ul>
</li>
</ul>
<h4 id="总线周期"><a href="#总线周期" class="headerlink" title="总线周期"></a>总线周期</h4><ul>
<li>定义：完成一次总线操作的时间。</li>
</ul>
<ol>
<li>申请分配阶段</li>
<li>寻址阶段</li>
<li>传数阶段</li>
<li>结束阶段</li>
</ol>
<h4 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h4><h4 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h4><p>​	异步通信的应答方式：不互锁，半互锁，全互锁。</p>
<h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><p>“半同步通信”是一种混合型通信模型，结合了同步通信和异步通信的特点。在半同步通信中，通常存在两个部分：一个同步部分和一个异步部分。</p>
<ul>
<li><strong>同步部分</strong>：在同步部分，通信的发送者和接收者会在通信开始和结束时进行显式的同步，以确保数据的正确传输。这意味着发送方和接收方会通过一些同步机制来进行通信，例如信号量、条件变量或者消息队列等。在同步部分中，通信的发送和接收通常是一个阻塞操作，直到通信完成。</li>
<li><strong>异步部分</strong>：在异步部分，通信的发送者和接收者不需要严格的同步，可以在不同的时间进行数据的发送和接收。在异步部分中，通常采用非阻塞的方式进行通信，发送方可以继续执行其他任务，而不需要等待通信完成。</li>
</ul>
<p>半同步通信通常用于解决在异步通信中可能出现的数据一致性问题，同时又希望通过同步通信确保数据的正确性和完整性。这种通信模型可以在一定程度上提高通信的灵活性和效率，同时保持数据的安全性。</p>
<h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><p>“分离式通信”是一种通信模型，其中通信的发送和接收是通过分开的机制进行的。在分离式通信中，发送者和接收者之间不直接进行数据传输，而是通过中间的通信通道或者中介进行交互。</p>
<p>通常，分离式通信包含以下两个主要组成部分：</p>
<ol>
<li><strong>发送端（Sender）</strong>：发送端负责将数据发送到通信通道或者中介。它将要发送的数据传递给通信通道或者中介，并可能在发送后继续执行其他任务。</li>
<li><strong>接收端（Receiver）</strong>：接收端负责从通信通道或者中介接收数据。它从通信通道或者中介获取数据，并可能对接收到的数据进行处理或者响应。</li>
</ol>
<p>分离式通信的通信通道或者中介可以是各种形式的，例如消息队列、事件、共享内存、套接字等。这些通道或者中介起到了一个连接发送端和接收端的桥梁作用，使得它们能够进行间接的数据交换。</p>
<p>分离式通信常用于解耦发送者和接收者之间的依赖关系，以提高系统的可扩展性、灵活性和性能。同时，它还可以用于实现异步通信，其中发送者和接收者可以以不同的速率进行数据交换。</p>
<h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><h3 id="按存储介质"><a href="#按存储介质" class="headerlink" title="按存储介质"></a>按存储介质</h3><ol>
<li>半导体存储器 </li>
<li>磁表面存储器</li>
<li>磁芯存储器</li>
<li>光盘存储器</li>
</ol>
<h3 id="按存取方式"><a href="#按存取方式" class="headerlink" title="按存取方式"></a>按存取方式</h3><ol>
<li><p>随机存储器</p>
<ol>
<li>静态RAM（触发器原理寄存信息）</li>
<li>动态RAM（电容充放电原理寄存信息）</li>
</ol>
</li>
<li><p>只读存储器</p>
<ol>
<li>掩模型只读存储器（MROM）</li>
<li>可编程只读存储器（PROM）</li>
<li>可擦除可编程只读存储器（EPROM）</li>
<li>用电可擦除可编程只读存储器（EEPROM）</li>
</ol>
</li>
<li><p>顺序存取存储器</p>
</li>
<li><p>直接存取存储器、</p>
<p> -按在计算机中的作用</p>
</li>
<li><p>主存储器</p>
</li>
<li><p>辅存储器</p>
</li>
<li><p>缓冲存储器</p>
</li>
</ol>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h3><ul>
<li>按字寻址和按字节寻址</li>
</ul>
<blockquote>
<p>例：假设地址线24位，按字节寻址范围就是：2^24</p>
<p>如果机器字长32位，则按字寻址范围就是：2^24&#x2F;（32&#x2F;4）</p>
</blockquote>
<h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h3><p>​	<strong>存储容量和存储速度</strong></p>
<h4 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h4><p>​	定义：主存能存放二进制代码的总位数（存储单元* 存储字长）。也可以用字节总数表示。</p>
<h4 id="存储速度"><a href="#存储速度" class="headerlink" title="存储速度"></a>存储速度</h4><p>​	存储速度由存取时间和存取周期表示。</p>
<ul>
<li><p>存取时间（存储器访问时间（Memory Access Time））</p>
<p>  定义：启动一次存储器操作<strong>到完成该操作所需的全部时间</strong>。</p>
<p>  分为读出时间和写入时间</p>
<ol>
<li>读出时间：收到有效地址到产生有效输出。</li>
<li>写入时间：存储器收到有效地址到数据写入被选中单元。</li>
</ol>
</li>
<li><p>存取周期（Memory Cycle Time）</p>
<p>  定义：存储器连续两次独立的存储器操作所需的最小时间间隔。</p>
</li>
</ul>
<h4 id="存储带宽"><a href="#存储带宽" class="headerlink" title="存储带宽"></a>存储带宽</h4><p>定义：单位时间内存储器存取的信息量</p>
<ul>
<li>提高带宽的措施</li>
</ul>
<ol>
<li>缩短存储周期</li>
<li>增加存储字长</li>
<li>增加存储体</li>
</ol>
<h3 id="半导体存储芯片"><a href="#半导体存储芯片" class="headerlink" title="半导体存储芯片"></a>半导体存储芯片</h3><p>地址线和数据线共同反应存储芯片的容量。</p>
<h4 id="译码驱动方式"><a href="#译码驱动方式" class="headerlink" title="译码驱动方式"></a>译码驱动方式</h4><ol>
<li><p>线选法：一根线拿出一个存储单元各位</p>
</li>
<li><p>重合法：类似键盘扫描</p>
</li>
</ol>
<h3 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h3><p>​	分为静态RAM和动态RAM</p>
<h4 id="静态RAM-SRAM"><a href="#静态RAM-SRAM" class="headerlink" title="静态RAM(SRAM)"></a>静态RAM(SRAM)</h4><p>​	用于存储0和1的电路称为 存储器的基本单元电路。</p>
<p>​	易失性半导体</p>
<h4 id="动态RAM-DRAM"><a href="#动态RAM-DRAM" class="headerlink" title="动态RAM(DRAM)"></a>动态RAM(DRAM)</h4><p>​	靠电容存储电荷的原理进行存储信息，需要再生（也称刷新）</p>
<h3 id="存储器与CPU的链接"><a href="#存储器与CPU的链接" class="headerlink" title="存储器与CPU的链接"></a>存储器与CPU的链接</h3><h4 id="存储容量的扩展"><a href="#存储容量的扩展" class="headerlink" title="* 存储容量的扩展"></a>* 存储容量的扩展</h4><ol>
<li>位扩展</li>
</ol>
<p>​		增加存储字长。相同地址线不同位数可以合体。两片1K×4位可以组成1K×8位</p>
<ol start="2">
<li>字扩展</li>
</ol>
<p>​	增加存储器字的数量。例如两片1K×8位可以组成2K×8位。</p>
<h4 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h4><p>​	注意篇与片之间的地址线，数据线，控制线的连接。</p>
<ol>
<li><p>地址线的连接</p>
<p> CPU地址线的低位与存储芯片的地址线相连。高位用于扩容或者片选</p>
</li>
<li><p>数据线的连接</p>
</li>
<li><p>读写命令线的连接</p>
</li>
<li><p>片选线的连接</p>
</li>
</ol>
<p>​	取决于片选控制端 CS非（低电平生效），同时其与访存控制信号MREQ非（低电平有效）有关，CPU需要时才会选择存储芯片。</p>
<ol start="5">
<li>合理选择存储芯片</li>
</ol>
<h3 id="存储器的检验"><a href="#存储器的检验" class="headerlink" title="* 存储器的检验"></a>* 存储器的检验</h3><ul>
<li><p>汉明码：具有一位纠错能力的的编码</p>
</li>
<li><p>编码最小距离</p>
<ul>
<li>在一种编码系统中任意两组合法代码之间的最小二进制位数差异。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L-1=D+C        （D&gt;=C）</span><br></pre></td></tr></table></figure>

<ul>
<li>L(编码最小距离)</li>
<li>D(检测错误的位数)</li>
<li>C（纠正错误的位数）</li>
</ul>
<h3 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h3><h4 id="单体多字系统"><a href="#单体多字系统" class="headerlink" title="单体多字系统"></a>单体多字系统</h4><ul>
<li>使用前提：<ul>
<li>指令和数据必须在主存内连续存放。遇到转移指令或操作数不能连续存放则效果不明显。</li>
</ul>
</li>
<li>单体 W 字可以将带宽拓宽 W  倍</li>
</ul>
<h4 id="多体并行系统"><a href="#多体并行系统" class="headerlink" title="多体并行系统"></a>多体并行系统</h4><ul>
<li><p>高位交叉编址（顺序存储）</p>
<ul>
<li>特征：<ul>
<li>在体内顺序存放，不同的请求源可以同时访问不同的体</li>
<li>高位地址表示体号，低位地址表示体内地址</li>
</ul>
</li>
</ul>
</li>
<li><p>低位交叉编址（模M编址）</p>
<ul>
<li>特征：<ul>
<li>程序连续存放在相邻体中，有交叉存储之称。</li>
<li>低位地址表示体号，高位地址表示体内地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="求交叉存储和顺序存储的存储器带宽"><a href="#求交叉存储和顺序存储的存储器带宽" class="headerlink" title="* 求交叉存储和顺序存储的存储器带宽"></a>* 求交叉存储和顺序存储的存储器带宽</h4><h2 id="高速缓冲缓存器（Cache）"><a href="#高速缓冲缓存器（Cache）" class="headerlink" title="高速缓冲缓存器（Cache）"></a>高速缓冲缓存器（Cache）</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><p>​	<strong>定义：</strong> 程序访问的局部性原理包括时间局部性和空间局部性。时间局部性是指在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环。空间局部性是指在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是连续的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。</p>
<h1 id="杂记（待整理）"><a href="#杂记（待整理）" class="headerlink" title="杂记（待整理）"></a>杂记（待整理）</h1><blockquote>
<ol>
<li><strong>指令寄存器（IR）：</strong> 这是一个 CPU 内部的寄存器，用于存储当前正在执行的机器指令。当 CPU 从主存中取出指令并解码后，指令的操作码会被加载到指令寄存器中，CPU 根据其中的指令来执行相应的操作。</li>
<li><strong>乘法商寄存器（MQ）：</strong> 这是一个专门用于乘法运算的寄存器，通常在一些早期的 CPU 设计中出现。在执行乘法指令时，乘法器会将被乘数加载到 MQ 中，并将乘法的结果存储在 MQ 中，或者 MQ 用于存储商或余数。这样可以简化乘法运算的硬件设计。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>PC 寄存器（Program Counter Register）</strong>，也称为指令指针寄存器（Instruction Pointer Register），是一种特殊的寄存器，用于存储当前正在执行的 CPU 指令的地址或下一条指令的地址。</p>
<p>PC 寄存器在 CPU 内部起着关键的作用，它指示了 CPU 下一步将要执行的指令的位置。当 CPU 执行完一条指令后，PC 寄存器会自动更新，指向下一条指令的地址，以便 CPU 继续执行。这个过程被称为指令流水线（Instruction Pipeline）。</p>
<p>PC 寄存器用于存储指令地址，控制程序的执行流程；而 IR 寄存器用于存储指令内容，辅助 CPU 解码和执行指令。</p>
</blockquote>
<blockquote>
<p>AGP（Accelerated Graphics Port）和PCI（Peripheral Component Interconnect）是两种计算机总线标准，用于连接计算机主板与外部设备。它们分别用于不同的目的：</p>
<ol>
<li><strong>AGP（加速图形端口）：</strong><ul>
<li>AGP 是一种专门用于连接图形显卡的高速总线标准。它最初被设计用于提供高性能图形渲染的支持，使图形处理单元（GPU）能够快速访问系统内存，从而加速图形处理和显示。</li>
<li>AGP 总线通常用于连接显卡到主板的插槽上，并提供了比传统的 PCI 总线更高的带宽和更低的延迟。这使得 AGP 接口在处理图形密集型任务时表现更好。</li>
</ul>
</li>
<li><strong>PCI（外围组件互连）：</strong><ul>
<li>PCI 是一种通用的、高性能的总线标准，用于连接各种外部设备，如网卡、声卡、扩展卡等。PCI 总线提供了一种标准化的接口，允许不同的设备在计算机系统中进行通信和交换数据。</li>
<li>PCI 总线通常用于连接各种外部设备到主板上的插槽上，例如 PCI 插槽、PCI Express（PCIe）插槽等。它是一种通用的、灵活的接口，适用于连接各种类型的设备。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>微型计算机中控制总线提供的完整信息是( )。</p>
<ul>
<li>所有存储器和1&#x2F;0设备的时序信号和控制信号</li>
<li>来自I&#x2F;O设备和存储器的响应信号</li>
</ul>
</blockquote>
<blockquote>
<p>所谓的三总线结构的计算机中的“三总线”包含___。</p>
<p>A、I&#x2F;O总线B、<em>主存总线C、</em>DMA总线</p>
</blockquote>
]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Database Principles</title>
    <url>/2024/02/27/Database-Principles/</url>
    <content><![CDATA[<h1 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h1><h2 id="1-数据库概论"><a href="#1-数据库概论" class="headerlink" title="1.数据库概论"></a>1.数据库概论</h2><h3 id="数据库以及相关概念"><a href="#数据库以及相关概念" class="headerlink" title="数据库以及相关概念"></a>数据库以及相关概念</h3><ol>
<li>数据（<strong>data</strong>）：信息的表现形式和载体。</li>
<li>数据库（<strong>database</strong>）：长期存储在计算机内，有组织的，统一管理的相关数据的集合。</li>
<li>数据库管理系统（<strong>DBMS</strong>）：位于用户与操作系统逐之间的一层数据管理软件，为用户或应用程序提供访问DB的方法，包括DB的建立，查询，更新及各种数据控制。</li>
<li>数据库系统（<strong>DBS</strong>）：采用数据库技术的计算机系统。</li>
<li>数据库技术：研究数据库结构，存储设计管理和使用的一门软件学科。</li>
</ol>
<h3 id="高级数据库阶段"><a href="#高级数据库阶段" class="headerlink" title="高级数据库阶段"></a>高级数据库阶段</h3><h4 id="对象数据库技术"><a href="#对象数据库技术" class="headerlink" title="对象数据库技术"></a>对象数据库技术</h4><ul>
<li>面向对象与数据库技术结合的产物</li>
</ul>
<blockquote>
<p>主要特征</p>
<ol>
<li>可以完整的描述现实数据结构，以及数据之间嵌套递归的联系。 </li>
<li>具有封装性和继承性，提高了软件的可重用性</li>
</ol>
</blockquote>
<h4 id="分布式数据库系统"><a href="#分布式数据库系统" class="headerlink" title="分布式数据库系统"></a>分布式数据库系统</h4><blockquote>
<p>主要特征：</p>
<ol>
<li>数据物理上分布在不同场地，逻辑上是一个整体 。</li>
<li>每个场地可以执行局部应用，也可以执行全部应用<br>3.。 各地计算机由数据通信网络联系，本地计算机不能完成的任务可以通过通信网络获取其他场地支持。</li>
</ol>
</blockquote>
<h4 id="开放数据库互联技术"><a href="#开放数据库互联技术" class="headerlink" title="开放数据库互联技术"></a>开放数据库互联技术</h4><ul>
<li>用于单个应用程序访问不同的数据库</li>
</ul>
<ol start="4">
<li>XML数据库技术</li>
</ol>
<ul>
<li>灵活</li>
</ul>
<h4 id="现代信息集成技术"><a href="#现代信息集成技术" class="headerlink" title="现代信息集成技术"></a>现代信息集成技术</h4><ol>
<li>数据仓库</li>
<li>连及分析处理技术</li>
<li>数据挖掘</li>
</ol>
<h3 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h3><p>​	数据描述有两种形式：物理数据描述和逻辑数据描述。</p>
<ol>
<li>物理数据描述：数据在存储设备上的存储方式的描述。</li>
<li>逻辑数据描述：程序员或者用户用以操作的数据形式的描述，是抽象的概念化数据。</li>
</ol>
<h4 id="概念设计中的数据描述"><a href="#概念设计中的数据描述" class="headerlink" title="概念设计中的数据描述"></a>概念设计中的数据描述</h4><ul>
<li>实体（entity）</li>
<li>实体集 （entity set）</li>
<li>属性（attribute）</li>
<li>实体标识符（identifier）</li>
</ul>
<h4 id="逻辑设计中的数据描述"><a href="#逻辑设计中的数据描述" class="headerlink" title="逻辑设计中的数据描述"></a>逻辑设计中的数据描述</h4><ul>
<li>字段（Field）</li>
<li>记录（Record）</li>
<li>文件（file）</li>
<li>关键码（Key）</li>
</ul>
<h4 id="物理设计中的概念描述"><a href="#物理设计中的概念描述" class="headerlink" title="物理设计中的概念描述"></a>物理设计中的概念描述</h4><ol>
<li>物理存储介质层次，可分为以下六类</li>
</ol>
<ul>
<li>高速缓冲存储器（<strong>cache</strong>）</li>
<li>主存储器（<strong>main menory</strong>）</li>
<li>快擦鞋存储器(<strong>flash memory</strong>)</li>
<li>磁盘存储器(<strong>magnetic disk</strong>)</li>
<li>光存储器(<strong>optical sstorage</strong>)</li>
<li>磁带(<strong>tape storage</strong>)</li>
</ul>
<ol start="2">
<li>物理存储中的数据描述</li>
</ol>
<ul>
<li>位(<strong>bit</strong>)</li>
<li>字节（<strong>byte</strong>）</li>
<li>字(<strong>word</strong>)</li>
<li>块( <strong>Block</strong>)</li>
<li>桶 (<strong>bucket</strong>)</li>
<li>卷(<strong>volume</strong>)</li>
</ul>
<h4 id="数据联系的描述"><a href="#数据联系的描述" class="headerlink" title="数据联系的描述"></a>数据联系的描述</h4><p><strong>联系：是实体之间的互相关系。</strong></p>
<p><strong>联系的元数：与一个联系有关的实体集个数。</strong></p>
<ul>
<li>二元联系的三种类型</li>
</ul>
<ol>
<li>一对一联系</li>
<li>一对多联系</li>
<li>多对多联系</li>
</ol>
<h3 id="数据抽象过程"><a href="#数据抽象过程" class="headerlink" title="数据抽象过程"></a>数据抽象过程</h3><p>模型（model）: 是对现实世界的抽象。使用数据模型（data model）的概念描述数据库的结构和语义，对现实世界的数据进行抽象。</p>
<ul>
<li><strong>概念模型</strong>：用来表达用户需求观点的数据全局逻辑结构模型称为概念模型</li>
<li><strong>逻辑模型：</strong>表达计算机实现观点的DB全局逻辑结构的模型</li>
<li>**外部模型:**表达用户使用观点DB局部逻辑结构的模型</li>
<li><strong>内部模型：</strong>表达DB物理结构的模型</li>
</ul>
<p>他们之间的关系如图所示</p>
<p><img src="/images/" alt="structure"></p>
<h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><p>​	概念模型抽象级别最高，具有以下特点：</p>
<blockquote>
<ol>
<li>表达了数据的整体逻辑结构，他是系统用户对整个应用项目涉及的数据的全面描述</li>
<li>从用户需求的观点出发对数据建模</li>
<li>独立于硬件和软件。</li>
<li>是数据库设计人员与用户之间进行交流的工具。</li>
</ol>
</blockquote>
<p>​	<strong>现在采用的概念模型主要是实体联系模型（ER）(Entity Relationship Ship)</strong></p>
<ul>
<li><p>ER图有三个基本成分</p>
<ul>
<li><ol>
<li>矩形框：表示实体类型</li>
<li>菱形框：表示联系类型</li>
<li>椭圆形框：表示实体类型和联系类型的属性</li>
</ol>
</li>
</ul>
</li>
<li><p>ER图的优点</p>
<ul>
<li>简单易理解，真实反应客户需求</li>
<li>与计算机无关，客户容易接受</li>
</ul>
</li>
<li><p>ER图的缺点</p>
<ul>
<li>只能说明实体间语义的练习，不能说明详细的数据结构</li>
</ul>
</li>
</ul>
<h4 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h4><ul>
<li>逻辑模型的特点</li>
</ul>
<ol>
<li>表达了DB整体的逻辑结构</li>
<li>从数据库实现的观点出发对数据建模</li>
<li>独立于硬件，依赖于软件（DBMS）</li>
<li>是数据库设计人员与应用程序猿之间进行交流的工具</li>
</ol>
<h5 id="逻辑模型的种类"><a href="#逻辑模型的种类" class="headerlink" title="逻辑模型的种类"></a>逻辑模型的种类</h5><ol>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
<li>对象模型</li>
</ol>
<h4 id="三层模式和两级映像"><a href="#三层模式和两级映像" class="headerlink" title="三层模式和两级映像"></a>三层模式和两级映像</h4><ul>
<li>型和值</li>
</ul>
<ol>
<li>型：对一类数据的结构和属性的说明</li>
<li>值：是型的一个具体赋值</li>
</ol>
<ul>
<li>&#x3D;&#x3D;模式&#x3D;&#x3D;</li>
</ul>
<p>​    定义：数据模型使用DB的数据定义语言（DDL），定义后的内容称为模式。</p>
<ol>
<li>描述数据库逻辑结构和特征</li>
<li>对”型“的描述</li>
<li>反映数据结构及其联系</li>
<li>相对稳定</li>
<li>以某一种数据模型为基础</li>
</ol>
<ul>
<li>三层模式：在数据库设计中，有时会使用三层模式来描述数据库的结构和组织方式。这通常涉及到将数据库划分为三个不同的层次或组件：外部模式、概念模式和内部模式。</li>
</ul>
<ol>
<li><p>外部模式（External Schema）：也称为用户视图或子模式，是用户或应用程序能够直接访问和操作的部分数据库。每个外部模式都是特定用户或应用程序对数据库的定制视图。</p>
</li>
<li><p>概念模式（Conceptual Schema）：也称为全局模式或逻辑模式，是数据库的整体逻辑结构和组织方式的抽象表示。它描述了数据库中的所有数据对象、它们之间的关系以及约束条件。</p>
</li>
<li><p>内部模式（Internal Schema）：也称为存储模式，是数据库在物理存储层面的表示。它描述了数据在存储介质上的存储方式、索引结构等细节。</p>
</li>
</ol>
<ul>
<li>两级映像</li>
</ul>
<h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><h4 id="DBMS的工作模式"><a href="#DBMS的工作模式" class="headerlink" title="DBMS的工作模式"></a>DBMS的工作模式</h4><ol>
<li>接受应用程序的数据请求和处理请求</li>
<li>将用户的数据请求(高级指令)转换成复杂的机器代码(低层指令)3</li>
<li>实现对数据库的操作</li>
<li>从对数据库的操作中接受查询结果</li>
<li>对查询结果进行处理(格式转换)</li>
<li>将处理结果返回给用户</li>
</ol>
<h4 id="DBMS的主要功能"><a href="#DBMS的主要功能" class="headerlink" title="DBMS的主要功能"></a>DBMS的主要功能</h4><ol>
<li>数据库的定义功能(DDL，(Data Definition<br> 数据库三层结构、两级映像、定义数据的完整性约anguage束、保密限制约束等</li>
<li>数据库的操纵功能(DML，data manipul<br> ation language<br> 检索:查询，更新::插入、删除、更新</li>
<li>数据库的保护功能<br> 恢复，并发控制，完整性，安全性</li>
<li>数据库的维护功能(Utilities<br> 数据载入、转换、转储等</li>
<li>数据字典(DD</li>
</ol>
<h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><h4 id="DBS的组成"><a href="#DBS的组成" class="headerlink" title="DBS的组成"></a>DBS的组成</h4><ol>
<li>数据库</li>
<li>硬件</li>
<li>软件</li>
<li>数据管理员</li>
</ol>
<h4 id="DBS的全局结构"><a href="#DBS的全局结构" class="headerlink" title="DBS的全局结构"></a>DBS的全局结构</h4><p><img src="C:\Users\Regen\AppData\Roaming\Typora\typora-user-images\image-20240311125039548.png" alt="image-20240311125039548"></p>
<h4 id="DBS结构的分类"><a href="#DBS结构的分类" class="headerlink" title="DBS结构的分类"></a>DBS结构的分类</h4><ol>
<li><strong>层次数据库结构（Hierarchical Database Structure）</strong>：<ul>
<li>层次数据库结构是最早期的数据库组织方式之一，它使用树状结构来组织数据。每个节点可以有一个或多个子节点，但每个节点只有一个父节点。</li>
<li>典型的例子是IBM的IMS（Information Management System）数据库系统。</li>
</ul>
</li>
<li><strong>网络数据库结构（Network Database Structure）</strong>：<ul>
<li>网络数据库结构扩展了层次数据库的概念，允许一个节点有多个父节点，形成一个图状结构。这种结构提供了更灵活的数据组织方式。</li>
<li>CODASYL（Conference on Data Systems Languages）标准定义了一种常见的网络数据库模型，例如IDMS（Integrated Data Management System）。</li>
</ul>
</li>
<li><strong>关系数据库结构（Relational Database Structure）</strong>：<ul>
<li>关系数据库结构是当前最常用的数据库组织方式之一。它基于关系模型，使用表格（称为关系）来表示数据，并使用关系之间的键值关联来建立数据之间的联系。</li>
<li>关系数据库的代表性产品包括Oracle、MySQL、SQL Server等。</li>
</ul>
</li>
<li><strong>面向对象数据库结构（Object-Oriented Database Structure）</strong>：<ul>
<li>面向对象数据库结构将面向对象编程的思想引入数据库系统，允许将复杂数据结构和对象存储在数据库中，并支持面向对象的查询和操作。</li>
<li>典型的面向对象数据库系统包括ObjectDB、db4o等。</li>
</ul>
</li>
<li><strong>文档数据库结构（Document Database Structure）</strong>：<ul>
<li>文档数据库结构是一种非常灵活的数据库组织方式，它使用文档来存储数据，文档可以是JSON、XML等格式。</li>
<li>MongoDB是一种常见的文档数据库系统。</li>
</ul>
</li>
<li><strong>键-值存储结构（Key-Value Store Structure）</strong>：<ul>
<li>键-值存储结构是一种简单的数据库组织方式，它使用键值对来存储数据，其中每个键都唯一地标识一个值。</li>
<li>Redis、Amazon DynamoDB等是常见的键-值存储数据库系统。</li>
</ul>
</li>
</ol>
<h2 id="2-关系模型和关系运算理论"><a href="#2-关系模型和关系运算理论" class="headerlink" title="2.关系模型和关系运算理论"></a>2.关系模型和关系运算理论</h2><h3 id="关系模型的基本概念"><a href="#关系模型的基本概念" class="headerlink" title="关系模型的基本概念"></a>关系模型的基本概念</h3><p>​	定义：用二维表格表示实体集，用关键码表示实体之间联系的数据模型称为关系模型（Relational Model）。</p>
<ul>
<li>非平凡的函数依赖</li>
</ul>
<p>如果X→Y，但Y不包含于X，则称		X→Y是非平凡的函数依赖。</p>
<ul>
<li>平凡的函数依赖</li>
</ul>
<p>如果X→Y，但Y包含于X，则称		X→Y是平凡的函数依赖。</p>
<ul>
<li>决定因子</li>
</ul>
<p>如果X→Y，则X称为决定因子。 </p>
<h4 id="关键码"><a href="#关键码" class="headerlink" title="关键码"></a>关键码</h4><ul>
<li>超键（super）</li>
</ul>
<p>在关系中能唯一标识元组的属性或属性集称为关系模式的超键。</p>
<ul>
<li>候选键(Candidate)</li>
</ul>
<p>不含有多余属性的超键称为侯选建</p>
<ul>
<li>主键（primary）</li>
</ul>
<p>用户选作元组标识的候选键称为主键</p>
<ul>
<li>外键(foreign)</li>
</ul>
<p>若模式R中属性K是其他模式的主键，则K在R中称为外键。</p>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>定义：一个属性相同的元组的集合。</p>
<blockquote>
<p>规范性限制</p>
<p>关系中每一个属性值都是不可分解的；</p>
<p>关系中不允许出现重复元组，即不允许出现相同的元组；</p>
<p>由于关系是一个集合，因此不考虑元组间的顺序，即没有行序；</p>
<p>元组中的属性在理论上也是无序的，但使用时按习惯考虑列的顺序。</p>
</blockquote>
<h4 id="3类完整性规则"><a href="#3类完整性规则" class="headerlink" title="3类完整性规则"></a>3类完整性规则</h4><h4 id="实体完整性给规则"><a href="#实体完整性给规则" class="headerlink" title="实体完整性给规则"></a>实体完整性给规则</h4><p>要求关系中元组在组成主键的属性上不能有空值。如果出现空值，那么主键值就起不了惟一标识元组的作用。</p>
<h4 id="参照完整性规则"><a href="#参照完整性规则" class="headerlink" title="参照完整性规则"></a>参照完整性规则</h4><p>如果属性集K是关系模式R1的主键，K也是关系模式R2的外键，那么在R2的关系中，K的取值只允许两种可能，或者为空值，或者等于R1关系中某个主键值。</p>
<h4 id="用户定义的完整性规则"><a href="#用户定义的完整性规则" class="headerlink" title="用户定义的完整性规则"></a>用户定义的完整性规则</h4><p>用户可以针对具体的数据约束，设置完整性规则，由系统来检验实施，以使用统一的方法处理它们，不再由应用程序承担这项工作。</p>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>​	在关系模型中，记录类型称为关系模式，而关系模式的集合就是数据库的概念模式。</p>
<h4 id="关系模式与关系"><a href="#关系模式与关系" class="headerlink" title="关系模式与关系"></a>关系模式与关系</h4><p>关系模式是型，是对关系的描述，是静态的，稳定的。关系是值，由赋予它的元组语义来确定的，是动态的，不断变化的关系是关系模式在某一时刻的状态或内容</p>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><h3 id="关系代数表达式的优化"><a href="#关系代数表达式的优化" class="headerlink" title="关系代数表达式的优化"></a>关系代数表达式的优化</h3><p>​	</p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System Principles</title>
    <url>/2024/02/27/Operating-System-Principles/</url>
    <content><![CDATA[<p>&#x3D;&#x3D;操作系统原理&#x3D;&#x3D;</p>
<h1 id="1-操作系统概论"><a href="#1-操作系统概论" class="headerlink" title="1.操作系统概论"></a>1.操作系统概论</h1><h1 id="2-操作系统接口"><a href="#2-操作系统接口" class="headerlink" title="2.操作系统接口"></a>2.操作系统接口</h1><h2 id="用户与操作系统接口的分类"><a href="#用户与操作系统接口的分类" class="headerlink" title="用户与操作系统接口的分类"></a>用户与操作系统接口的分类</h2><ol>
<li>用户接口<br> 提供给用户使用，通过该接口取得操作系统的服务。</li>
<li>程序接口<br> 提供给程序员使用，用户程序使用系统服务的唯一途径</li>
</ol>
<h3 id="用户接口（操作接口）"><a href="#用户接口（操作接口）" class="headerlink" title="用户接口（操作接口）"></a>用户接口（操作接口）</h3><ol>
<li>联机用户接口（交互式）</li>
<li>脱机用户接口（批处理 ）</li>
</ol>
<h4 id="联机用户接口（交互式）"><a href="#联机用户接口（交互式）" class="headerlink" title="联机用户接口（交互式）"></a>联机用户接口（交互式）</h4><ol>
<li>字符显示式联机用户接口</li>
</ol>
<ul>
<li>命令行方式：shell 语言</li>
<li>批命令方式：.sh</li>
</ul>
<ol start="2">
<li>图形化联机用户接口</li>
</ol>
<ul>
<li>GUI ：包括窗口，图标，菜单，鼠标和面向对象技术</li>
</ul>
<h4 id="脱机用户接口（批处理-）"><a href="#脱机用户接口（批处理-）" class="headerlink" title="脱机用户接口（批处理 ）"></a>脱机用户接口（批处理 ）</h4><pre><code>由一组作业控制语言组成。
</code></pre>
<ul>
<li>作业：一次应用业务处理中，从输入开始到输入结束。用户要求计算机所做工作的集合。</li>
<li>作业步：作业加工处理的技术</li>
<li>作业分类：脱机作业，联机作业。</li>
<li>作业I&#x2F;O方式：联机IO，脱机IO，SpooLing方式</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><pre><code>系统调用（System Call），提供了用户程序和操作系统之间的接口。用户不能直接调用，但是用户程序可以。
</code></pre>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><blockquote>
<ul>
<li>作业：在一次应用业务处理过程中，从输入开始到输出结束，用户要求计算机所做工作的集合。</li>
<li>作业步：作业加工处理的步骤。</li>
<li>作业的分类：脱机作业、联机作业。</li>
<li>作业的I&#x2F;O 方式：联机I&#x2F;O 、脱机I&#x2F;O 、SpooLing方式。</li>
</ul>
</blockquote>
<h3 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h3><ul>
<li>特权指令<br>  不允许用户程序直接使用的指令，关系到系统全局。<br>  特点：<ol>
<li>内存访问范围不受限制</li>
<li>用户和系统存储空间都能访问</li>
</ol>
</li>
<li>非特权指令<br>  只能完成一般性的操作和任务，不能直接访问系统的硬件和软件。<br>  访问范围局限于用户空间</li>
</ul>
<h3 id="管态和目态"><a href="#管态和目态" class="headerlink" title="管态和目态"></a>管态和目态</h3><ol>
<li><p>管态（系统态，核心态）：<br> 可以执行包括特权指令的所有机器指令。</p>
</li>
<li><p>目态（用户态）：<br> 不允许执行特权指令。</p>
</li>
</ol>
<h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><p>​	定义：系统调用是操作系统提供的一组用于实现各种系统功能的子程序，并将它们提供给应用程序调用。 </p>
<p>&#x3D;&#x3D;系统调用是应用程序获得操作系统服务的唯一途径！&#x3D;&#x3D;</p>
<ul>
<li>系统调用会将用户态切换到内核态</li>
<li>执行完成后，系统又将CPU状态从系统态转换到用户态，再继续执行应用程序。</li>
<li>系统调用是一种特殊的过程调用，通常由特殊的机器指令实现。除了提供对操作系统子程序的调用外，这个指令还将系统转入特权方式（管态）。</li>
</ul>
<h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3. *进程管理"></a>3. *进程管理</h1><h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="*进程的基本概念"></a>*进程的基本概念</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><ul>
<li>程序的特征</li>
</ul>
<ol>
<li>顺序性，处理机的操作严格按照程序所规定的顺序执行</li>
<li>封闭性，程序运行时独占全机资源</li>
<li>结果的确定性，执行结果和中断次数无关</li>
<li>可再现性，只要程序顺序执行的环境和初始条件相同，不论执行过程如何，都将获得相同的结果</li>
</ol>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>非正式<br>  执行中的程序<br>  运行中的代码段 </li>
<li>正式<br>  可并发执行的程序在一个数据集合上的执行过程，是系统进行资源分配和调度的一个独立单位<br>  注意：进程 !&#x3D; 程序</li>
</ul>
<h3 id="进程与程序的关系"><a href="#进程与程序的关系" class="headerlink" title="进程与程序的关系"></a>进程与程序的关系</h3><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>｜进程｜程序｜<br>｜——-｜——-｜<br>｜动态｜静态｜<br>｜并发｜顺序｜<br>｜暂时｜永久｜</p>
<ul>
<li>出现原因：支持多道编程</li>
</ul>
<h4 id="进程的特征（属性）"><a href="#进程的特征（属性）" class="headerlink" title="进程的特征（属性）"></a>进程的特征（属性）</h4><p>特征：</p>
<ol>
<li>结构特征<br>进程实体：由程序段、数据段、核心栈及进程控制块部分构成，总称“进程映像”（Process Image）。</li>
<li>动态性(最基本的特征)<br>由“创建”而产生，由“调度”而执行；由得不到资源而阻塞；由撤消而消亡。（而程序是静态的）。</li>
<li>并发性（重要特征）<br>只有建立了进程，才能并发执行。</li>
<li>独立性<br>独立运行，独立获得资源、独立接受调度。</li>
<li>异步性<br>进程按各自独立、不可预知的速度向前推进</li>
</ol>
<h2 id="进状态及转换"><a href="#进状态及转换" class="headerlink" title="*进状态及转换"></a>*进状态及转换</h2><h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><ul>
<li>就绪状态</li>
<li>执行&#x2F;运行状态</li>
<li>阻塞&#x2F;等待&#x2F;睡眠&#x2F;暂停&#x2F;封锁状态</li>
</ul>
<p>###进程状态变迁情况及原因：</p>
<ol>
<li>就绪状态→运行状态：由OS中的进程调度程序，按一定的原则调度就绪队列中进程占用CPU。</li>
<li>运行状态→就绪状态：时间片到，高优先进程进入就绪队列，等等。</li>
<li>运行状态→阻塞状态：等待I&#x2F;O传输，申请内存空间，程序运行出错，等等。</li>
<li>阻塞状态→就绪状态： I&#x2F;O传输完成，内存空间获得，程序运行错误处理完成，等等。</li>
</ol>
<h4 id="进程的五态模型"><a href="#进程的五态模型" class="headerlink" title="进程的五态模型"></a>进程的五态模型</h4><ol>
<li>NULL-创建态：新进程的产生</li>
<li>创建态-就绪态：资源允许的情况</li>
<li>执行态-终止态：自然结束，强行终止</li>
<li>终止态-NULL：完成善后操作</li>
<li>阻塞态-终止态：强行终止</li>
<li>就绪态-终止态：强行终止</li>
</ol>
<ul>
<li>程序状态字PSW（程序状态寄存器）又称（标志寄存器）</li>
</ul>
<p>​	PSW用来存放两类信息：一类是体现当前指令执行结果的各种状态信息，称为状态标志，如有无进位（CF位），有无溢出（OF位），结果正负（SF位），结果是否为零（ZF位），奇偶标志位（PF位）等；另一类是存放控制信息，称为控制状态，如允许中断(IF位)，跟踪标志（TF位），方向标志(DF)等。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="*进程控制"></a>*进程控制</h2><p>​	进程控制的职责是对系统中的全部进程实施有效的管理，它是处理机管理的一部分。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程之间的制约关系"><a href="#进程之间的制约关系" class="headerlink" title="进程之间的制约关系"></a>进程之间的制约关系</h3><ol>
<li>间接制约：资源竞争关系</li>
</ol>
<p>需互斥地访问临界资源（进程互斥）</p>
<ul>
<li>临界资源：在一个时间段内只允许一个进程访问的资源。</li>
<li>临界区（Critical Section，CS）进程访问临界资源的一段代码。</li>
</ul>
<ol start="2">
<li>直接制约：相互协作关系</li>
</ol>
<h3 id="进程间资源访问冲突"><a href="#进程间资源访问冲突" class="headerlink" title="进程间资源访问冲突"></a>进程间资源访问冲突</h3><p>-共享变量的修改冲突</p>
<p>-操作顺序中冲突</p>
<h3 id="进程之间的交互关系"><a href="#进程之间的交互关系" class="headerlink" title="进程之间的交互关系"></a>进程之间的交互关系</h3><ol>
<li>互斥：指多个进程不能同时使用同一个资源</li>
<li>同步：进程之间的协作</li>
<li>死锁：指多个进程互不相让，都得不到足够的资源；</li>
</ol>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁（共享的变量）阻止了其他进程进入临界区</p>
<h3 id="临界区及其管理"><a href="#临界区及其管理" class="headerlink" title="临界区及其管理"></a>临界区及其管理</h3><p>​	临界区的执行在时间上是互斥的,进程必须请求允许进入临界区</p>
<p>间接同步（互斥）机制应遵循的准则</p>
<p>（1）空闲让进：当无进程处于临界区时，允许一进程立即进入临界区</p>
<p>（2）忙则等待：当某一进程已进入临界区时，其它试图进入临界区进程必须等待</p>
<p>（3）有限等待：应保证为有限等待，不会产生”死等”状态。（4）让权等待：不能进入临界区的执行进程应放弃CPU执行权。</p>
<h4 id="硬件方式-提供的低级原子级操作"><a href="#硬件方式-提供的低级原子级操作" class="headerlink" title="硬件方式-提供的低级原子级操作"></a>硬件方式-提供的低级原子级操作</h4><ol>
<li>关中断</li>
</ol>
<p>​	硬件上的关中断（禁止中断）。</p>
<ul>
<li>缺点：<ul>
<li>影响计算机效率</li>
<li>在多处理器下方法失效</li>
</ul>
</li>
</ul>
<h3 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h3><blockquote>
<p>​	进程死锁是指两个或多个进程在执行过程中，由于竞争系统资源而造成的一种僵局状态，导致它们永远无法继续执行下去。在死锁状态下，每个进程都在等待系统中的某个资源被释放，而释放该资源的操作又被其他进程所持有，从而导致所有进程都无法继续执行。换句话说，每个进程都在等待其他进程释放资源，而它们自身持有的资源又被其他进程等待，从而形成了一个相互等待的循环，无法解开。</p>
</blockquote>
<h3 id="信号量机制（必考）"><a href="#信号量机制（必考）" class="headerlink" title="* 信号量机制（必考）"></a>* 信号量机制（必考）</h3><p>​	<strong>定义</strong>：信号量机制是操作系统中用于控制对共享资源访问的一种同步机制。它通常用于多进程或多线程环境下，以确保对共享资源的访问不会导致竞态条件或数据不一致的问题。</p>
<ol>
<li><strong>P操作</strong><br> 获取信号量（P操作）：当一个线程或进程需要访问共享资源时，它需要首先尝试获取信号量。获取信号量的操作通常称为 P（或 wait）操作。如果信号量的值大于零，表示有可用的资源，线程或进程可以继续执行；如果信号量的值为零，表示资源已经被占用，线程或进程需要等待，直到有资源可用</li>
<li><strong>V操作</strong><br> 释放信号量（V操作）：当线程或进程使用完共享资源后，它需要释放信号量，以允许其他线程或进程继续访问。释放信号量的操作通常称为 V（或 signal）操作。通过增加信号量的值，V操作使得等待中的线程或进程可以继续执行。释放信号量（V操作）：当线程或进程使用完共享资源后，它需要释放信号量，以允许其他线程或进程继续访问。释放信号量的操作通常称为 V（或 signal）操作。通过增加信号量的值，V操作使得等待中的线程或进程可以继续执行。</li>
</ol>
<h4 id="信号量分类"><a href="#信号量分类" class="headerlink" title="* 信号量分类"></a>* 信号量分类</h4><p><strong>信号量分为：互斥信号量和资源信号量</strong></p>
<ul>
<li>互斥信号量用于申请或释放资源的使用权，常初始化为1。</li>
<li>资源信号量用于申请或归还资源，可以初始化为大于1的正整数，表示系统中某类资源的可用个数。</li>
</ul>
<ol>
<li><p>整形信号量</p>
<ol>
<li>设S为一个需要初始化值的整型量，对S的访问仅能通过两个标准的原子操作P(S)和V(S)。<strong>S的初值代表资源的总数</strong>。</li>
<li>如果S的值为1，表示有1个临界资源可以使用。</li>
<li>整型信号量S是一个全局变量（整型初始非负），并发进程都能够访问。S需要在主程序中定义，并赋予初值。</li>
</ol>
</li>
<li><p>记录型信号量</p>
<ol>
<li>在整型信号量的基础上进行改进</li>
<li>让不能进入临界区的进程“让权等待”，即进程状态由运行转换为阻塞状态，进程进入阻塞队列中等待。</li>
<li>Semaphore为一个记录型数据结构<ol>
<li><strong>value：</strong>代表资源数目，具有初值，该初值通常为非负整数。</li>
<li><strong>L</strong>：是一个初始状态为空的进程阻塞队列。</li>
</ol>
</li>
<li>工作流程<ol>
<li>记录型信号量的P操作是先减1，再测试，因此，测试条件是小于0，不是小于等于0；记录型信号量的V操作是先加1，再判断是否有进程阻塞，有进程阻塞则唤醒。</li>
<li>在P(S)操作中，S.value的值小于0时，表示不能访问临界资源，block(S.L)将调用P(S)的进程置成阻塞状态等待。</li>
<li>在V(S)操作中，S.value的值小于等于0时，表示有进程在阻塞队列等待临界资源，wakeup(S.L)将唤醒一个在阻塞队列等待的进程。</li>
</ol>
</li>
</ol>
</li>
<li><p>AND型信号量</p>
<ol>
<li>进程需要的资源越多，出现死锁的可能性也越大</li>
<li>解决的办法：将进程所需要的资源一次性地全部分配给进程，等进程运行完后再全部一起释放。</li>
<li><strong>缺点</strong><ol>
<li>虽然用AND型信号量会避免进程死锁，但是，AND型信号量使得并发进程变为先后执行，进程之间的相互等待，使得系统整体性能降低。</li>
</ol>
</li>
</ol>
</li>
<li><p>信号量集</p>
<ol>
<li>使用原因：<ol>
<li>当进程一次需要N个某类临界资源时，如果用记录型信号量，进程每次只能一次申请或释放一个临界资源，效率较低；每类资源数下限不同；对每类资源需求不同。因此引入信号量集：</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="管程"><a href="#管程" class="headerlink" title="* 管程"></a>* 管程</h3><h4 id="出现原因："><a href="#出现原因：" class="headerlink" title="出现原因："></a>出现原因：</h4><ul>
<li><p>为了避免凡要使用临界资源的进程都自备同步操作P(s)和V(s), 将同步操作的机制和临界资源结合到一起，形成管程。</p>
</li>
<li><p>信号量能够解决的同步问题，用管程同样可以解决，而且更加简单</p>
</li>
<li><p>管程机制作为同步工具，便于在高级语言编程中实现。</p>
</li>
</ul>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>一个数据结构和能为并发进程所执行的在该数据结构上的一组操作。</li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>管程名</li>
<li>局部于管程内部的共享数据结构说明</li>
<li>对该数据结构进行操作的一组过程</li>
<li>对共享数据结构设置初始值</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>​	进程可在任何需要的地方调用管程中的过程，但不能在管程外直接访问管程内的数据结构</p>
<p>​	管程本身被作为一种临界区，因此，实现管程时，需要考虑互斥、同步和控制变量等问题</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>模块化。是基本程序单位，可单独编译；</li>
<li>抽象数据类型。管程中不仅有数据，还有对数据的操作；</li>
<li>信息封装。管程中的数据结构只能被管程中的过程访问，这些过程供管程外的进程调用，而管程中的数据结构以及过程的具体实现外部不可见。</li>
<li>任一时刻，在管程中只能有一个进程运行。调用管程中过程的进程进入管程，如果不能访问临界资源时，则不能继续运行，需要在管程中阻塞等待临界资源。此时，在管程外等待访问管程的另一个进程可以进入管程。</li>
</ul>
<h4 id="管程与进程的比较"><a href="#管程与进程的比较" class="headerlink" title="* 管程与进程的比较"></a>* 管程与进程的比较</h4><ul>
<li>管程定义的是公用数据结构，而进程定义的是私有数据结构;</li>
<li>管程把共享变量上的同步操作集中起来，而临界区却分散在每个进程中；</li>
<li>管程是为管理共享资源而建立的，进程主要是为占有系统资源和实现系统并发性而引入的；</li>
<li>管程是被欲使用共享资源的进程所调用的，管程和调用它的进程不能并行工作，而进程之间能并行工作，并发性是其固有特性；</li>
<li>管程是语言或操作系统的成分，不必创建或撤销，而进程有生命周期，由创建而产生至撤销便消亡。</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>Inter Process Communication</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>管道（pipe）用于相关进程之间的通信</li>
<li>管道类似于共享文件，位于外存区域，但在文件系统中不可见一个<ul>
<li>进程在文件的一端写入</li>
<li>另一个进程从文件的另一端读出</li>
<li>管道 I&#x2F;O 类似于文件 I&#x2F;O</li>
</ul>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>管道通信效率低，不适合进程间频繁地交换数据。</li>
</ul>
<h4 id="记名管道"><a href="#记名管道" class="headerlink" title="记名管道"></a>记名管道</h4><ul>
<li>用途：记名管道用于不相关进程之间的通信</li>
<li>特点<ul>
<li>一个有名字的通信管道 </li>
<li>记名管道和文件系统共享一个名字空间</li>
<li>易于在非相关进程间通信</li>
<li>进程通过调用程序API创建记名管道</li>
</ul>
</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>无名管道</p>
<ul>
<li><p>无名管道是一种临时的、单向的通信管道，只能在相关进程之间使用。</p>
</li>
<li><p>无名管道在创建时不需要命名，因此也称为匿名管道。</p>
</li>
<li><p>无名管道通常用于具有父子关系的相关进程之间进行通信。</p>
</li>
</ul>
</li>
<li><p>命名管道</p>
<ul>
<li>命名管道是一种命名的、双向的通信管道，允许无关的进程之间进行通信。</li>
<li>命名管道在创建时会关联一个特定的文件路径名，因此也称为FIFO（First In, First Out）。</li>
<li>命名管道通常用于独立的进程之间进行通信，它们可以是同一台计算机上的不同进程，也可以是不同计算机上的进程。</li>
</ul>
</li>
</ul>
<h3 id="套接字和信号"><a href="#套接字和信号" class="headerlink" title="套接字和信号"></a>套接字和信号</h3><h4 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）:"></a>信号（signal）:</h4><ul>
<li>向一个进程通知发生异步事件，类似于信号中断，但无优先级</li>
<li>一个进程发送到另一个进程的内核对象或内核数据结构</li>
<li>信号可以被捕获或者忽略</li>
</ul>
<h4 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）:"></a>套接字（socket）:</h4><ul>
<li>网络中不同主机上的应用进程之间进行双向通信的端点的抽象</li>
<li>一种类似于文件的通信模式</li>
<li>通信双方（服务器和客户端）均需要创建套接字</li>
<li>本地的或远程的</li>
<li>进程通过调用套接字API创建套接字</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享存储器系统: 相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。 </p>
<ul>
<li>基于共享数据结构，低效，只能传递少量数据。(生产者-消费者问题) </li>
<li>通过共享存储区  </li>
<li>一个进程创建一段共享内存  </li>
<li>其它进程可以将该片内存映射到自己的地址空间  </li>
<li>共享内存的任何改变对进程都可见</li>
</ul>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p> 通过消息传递  应用最广泛的进程通信机制</p>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><ol>
<li>直接通信</li>
</ol>
<ul>
<li>发送进程利用OS所提供的发送命令，直接把消息发送给目标进程</li>
<li>发送进程和接收进程都以显式方式提供对方的标识符              Send(Receiver, message); 发送一个消息给接收进程；             Receive(Sender, message); 接收Sender发来的消息；      </li>
<li>例如，原语Send(P2, m1)表示将消息m1发送给接收进程P2; 而原语Receive(P1，m1)则表示接收由P1发来的消息m1</li>
</ul>
<ol start="2">
<li>间接通信</li>
</ol>
<ul>
<li>进程之间的通信需要通过作为共享数据结构的实体（信箱）</li>
</ul>
<blockquote>
<p>信箱：信箱可由操作系统创建，也可由用户进程创建，创建者是信箱的拥有者。据此，可把信箱分为以下三类</p>
<ul>
<li>私用信箱</li>
</ul>
<p>用户进程可为自己建立一个新信箱，并作为该进程的一部分。信箱的拥有者有权从信箱中读取消息，其他用户则只能将自己构成的消息发送到该信箱中。这种私用信箱可采用单向通信链路的信箱来实现。 当拥有该信箱的进程结束时，信箱也随之消失</p>
<ul>
<li>公用信箱</li>
</ul>
<p>由操作系统创建，并提供给系统中所有的核准进程使用。核准进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息。显然，公用信箱应采用双向通信链路的信箱来实现。通常，公用信箱在系统运行期间始终存在。</p>
<ul>
<li>共享信箱</li>
</ul>
<p>它由某进程创建，在创建时或创建后，指明它是可共享的，同时须指出共享进程(用户)的名字。信箱的拥有者和共享者，都有权从信箱中取走发送给自己的消息</p>
<p>信箱通信模式</p>
<ul>
<li>一对一关系。为发送进程和接收进程建立一条两者专用的通信链路，使两者之间的交互不受其他进程的干扰。</li>
<li>多对一关系。允许提供服务的进程与多个用户进程之间进行交互，也称为客户&#x2F;服务器交互，这时信箱称为端口（port）。</li>
<li>一对多关系。允许一个发送进程与多个接收进程进行交互，使发送进程可用广播方式，向多个接收者发送消息。</li>
<li>多对多关系。允许建立一个公用信箱，让多个进程都能向信箱中投递消息；也可从信箱中取走属于自己的消息。</li>
</ul>
</blockquote>
<ul>
<li>信箱的创建和撤消进程可利用信箱创建原语来建立一个新信箱。创建者进程应给出信箱名字、信箱属性(公用、私用或共享)；对于共享信箱， 还应给出共享者的名字。当进程不再需要读信箱时，可用信箱撤消原语将之撤消。</li>
<li>消息的发送和接收当进程之间要利用信箱进行通信时，必须使用共享信箱，并利用系统提供的下述通信原语进行通信。</li>
</ul>
<h5 id="消息传递系统实现中的若干问题"><a href="#消息传递系统实现中的若干问题" class="headerlink" title="消息传递系统实现中的若干问题"></a>消息传递系统实现中的若干问题</h5><ul>
<li>通信链路的建立</li>
</ul>
<blockquote>
<p>发送进程显式建立通信链路，主要用于计算机网络中使用系统的发送命令时，自动建立链路，主要用于单机系统中</p>
<p>通信链路分类:</p>
<ol>
<li><p>按照连接方式: </p>
<ol>
<li>点-点连接</li>
<li>多点连接</li>
</ol>
</li>
<li><p>按照通信方式</p>
<ol>
<li>单向通信链路</li>
<li>双向通信链路</li>
</ol>
</li>
</ol>
</blockquote>
<ul>
<li>消息格式:消息传递系统中所传递的消息，必须具有一定的格式。</li>
</ul>
<blockquote>
<p>格式类型</p>
<ul>
<li><p>定长消息格式</p>
<p>  可减少对消息的处理和存储开销。</p>
</li>
<li><p>变长消息格式</p>
<p>  方便发送较长消息的客户</p>
</li>
</ul>
</blockquote>
<ul>
<li>同步方式</li>
</ul>
<blockquote>
<p>发送接收均阻塞（汇合）：发送进程和接受进程间无缓冲，平时处于阻塞态，直到有消息传递</p>
<p>发送不阻塞，接收阻塞：应用最为广泛。如服务器。</p>
<p>发送接收均不阻塞：不要求任何一方等待。</p>
</blockquote>
<h4 id="三种方式比较"><a href="#三种方式比较" class="headerlink" title="三种方式比较"></a>三种方式比较</h4><p>1.无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享：有名管道虽然可以提供给任意关系的进程使用。但是由于其长期存在于系统之中，使用不当容易出错。</p>
<p>2.消息缓冲可以不局限于父子进程．而允许任意进程通过共享消息队列来实现进程间通信．并由系统调用函数来实现消息发送和接收之间的同步．从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题．使用方便，但是信息的复制需要额外消耗CPU的时间．不适宜于信息量大或操作频繁的场合。</p>
<p>3.共享内存利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的．因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<blockquote>
<p>资源：进程运行需要的事物计算机</p>
<p>资源的例子:  打印机，磁盘驱动器，数据表格，锁磁盘空间，内存，信号量，CPU</p>
</blockquote>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ol>
<li>竞争资源引起死锁</li>
<li>进程间推进顺序非法引起死锁</li>
</ol>
<h4 id="竞争资源引起的进程死锁"><a href="#竞争资源引起的进程死锁" class="headerlink" title="竞争资源引起的进程死锁"></a>竞争资源引起的进程死锁</h4><ul>
<li>可剥夺资源和不可剥夺资源</li>
</ul>
<blockquote>
<ol>
<li><strong>可剥夺资源</strong>：指的是系统可以在任意时刻剥夺并重新分配的资源。当一个进程占用了可剥夺资源时，操作系统可以在必要时将资源从该进程中取走，并分配给其他进程使用，以确保系统的公平性和效率。典型的可剥夺资源包括处理器（CPU）、内存和设备（如磁盘、网络接口）等。</li>
<li><strong>非剥夺资源</strong>：指的是系统不会在任意时刻剥夺的资源。一旦分配给某个进程，就必须等到该进程主动释放资源或者完成执行后，才能将资源分配给其他进程。典型的非剥夺资源包括硬件设备中的某些控制器、I&#x2F;O 设备中的某些部件等。</li>
</ol>
</blockquote>
<ul>
<li>竞争非剥夺性资源，可造成死锁</li>
<li>竞争临时性资源。</li>
</ul>
<blockquote>
<p>临时性资源是指由一个进程产生，被另一个进程使用一段时间后便无用的资源。</p>
</blockquote>
<h4 id="进程推进顺序不当引起死锁"><a href="#进程推进顺序不当引起死锁" class="headerlink" title="进程推进顺序不当引起死锁"></a>进程推进顺序不当引起死锁</h4><h3 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h3><ol>
<li>互斥条件: 某资源在一段时间内只能由一个进程占用</li>
<li>持有等待: 线程在请求新的资源时，其已经获得的资源并不释放，而是继续持有</li>
<li>不能抢占不能强迫进程放弃资源</li>
<li>环路等待条件</li>
</ol>
<h3 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h3><ol>
<li>不予理睬: 忽略问题的存在</li>
<li>静态预防: 消除死锁发生的4个必要条件中的任何一个。</li>
<li>动态避免: 仔细的资源分配</li>
<li>死锁检测与解除让死锁出现然后采取措施去纠正</li>
</ol>
<h4 id="不予理睬-忽略问题的存在"><a href="#不予理睬-忽略问题的存在" class="headerlink" title="不予理睬: 忽略问题的存在"></a>不予理睬: 忽略问题的存在</h4><ul>
<li><p>假装没有问题，“鸵鸟算法”</p>
</li>
<li><p>此种策略在如下情况下是合理的 </p>
<ol>
<li><p>死锁出现的概率很低 </p>
</li>
<li><p>预防死锁的代价很大</p>
</li>
</ol>
</li>
<li><p>UNIX 和Windows都采取这种方法方便和正确性之间的一种折中</p>
</li>
</ul>
<h4 id="静态预防-消除死锁发生的4个必要条件中的任何一个。"><a href="#静态预防-消除死锁发生的4个必要条件中的任何一个。" class="headerlink" title="静态预防: 消除死锁发生的4个必要条件中的任何一个。"></a>静态预防: 消除死锁发生的4个必要条件中的任何一个。</h4><ul>
<li>消除四个条件中的一个<ul>
<li>消除资源独占条件</li>
</ul>
</li>
</ul>
<blockquote>
<p>原则:</p>
<ol>
<li>不是绝对必须的时候避免分配资源</li>
<li>尽可能少的进程获得资源</li>
</ol>
</blockquote>
<ul>
<li>消除持有和等待条件</li>
</ul>
<blockquote>
<p>进程在启动之前请求所有的资源</p>
<ul>
<li>特点</li>
</ul>
<p>等待所有你需要的资源都被释放然后一次都获取它们B. 如果获取资源失败释放所有已经拥有的资源</p>
<ul>
<li>缺点</li>
</ul>
<p>一次获取所有的资源，造成资源浪费开始运行的时候可能不知道所有需要的资源</p>
</blockquote>
<ul>
<li>消除非抢占条件</li>
</ul>
<blockquote>
<ol>
<li>允许抢占</li>
<li>可以抢占 CPU ：通过将信息保存到进程控制表，之后再恢复它。</li>
<li>可以抢占内存 通过把内存倒出到磁盘上，之后再把它装回</li>
</ol>
<ul>
<li>局限性：有些资源不可以被抢占，比如锁打印机</li>
</ul>
</blockquote>
<ul>
<li>消除环路等待条件</li>
</ul>
<blockquote>
<ul>
<li><p>环路等待的原因是由于进程请求资源的顺序是随机的</p>
</li>
<li><p>可以通过定义资源类型的线性顺序来预防</p>
</li>
</ul>
</blockquote>
<ul>
<li>增加资源从而减少等待<ul>
<li>最小化了死锁的几率</li>
</ul>
</li>
</ul>
<h4 id="动态避免-仔细的资源分配"><a href="#动态避免-仔细的资源分配" class="headerlink" title="动态避免: 仔细的资源分配"></a>动态避免: 仔细的资源分配</h4><h4 id="死锁检测与解除让死锁出现然后采取措施去纠正"><a href="#死锁检测与解除让死锁出现然后采取措施去纠正" class="headerlink" title="死锁检测与解除让死锁出现然后采取措施去纠正"></a>死锁检测与解除让死锁出现然后采取措施去纠正</h4><ul>
<li>注意资源的占有和资源需求</li>
<li>通过查看有向图中的循环来检查死锁</li>
</ul>
<p><strong>矩阵检测</strong></p>
<p>矩阵检测的基本思想是将系统中的资源和进程状态抽象为一个矩阵，其中矩阵的行代表进程，列代表资源。这样，可以通过观察矩阵的状态来分析系统中是否存在资源分配问题（如死锁）或者资源使用情况是否合理。</p>
<p>在矩阵检测中，有两个主要的概念：</p>
<ol>
<li><strong>资源分配矩阵（Resource Allocation Matrix）</strong>：该矩阵显示了系统中各个进程对资源的请求以及已经被分配的资源情况。行表示进程，列表示资源，矩阵中的每个元素表示某个进程对某个资源的请求或分配情况。</li>
<li><strong>需求矩阵（Demand Matrix）</strong>：需求矩阵显示了每个进程对资源的需求情况。与资源分配矩阵相比，需求矩阵中的每个元素表示某个进程对某个资源的需求量。</li>
</ol>
<p>通过分析这些矩阵，可以发现潜在的问题，例如：</p>
<ul>
<li><strong>死锁检测</strong>：通过观察资源分配矩阵和需求矩阵，可以检测系统中是否存在死锁。如果存在某个进程无法满足其资源需求，同时该资源被其他进程占用，那么可能发生死锁。</li>
<li><strong>资源分配优化</strong>：通过观察资源分配矩阵，可以发现资源使用效率低下的情况，进而优化资源分配策略，提高系统整体的性能。</li>
</ul>
<h3 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h3><ol>
<li>抢占</li>
</ol>
<ul>
<li>将某个进程所占的资源强行拿走</li>
<li>取决于资源的性质</li>
</ul>
<ol start="2">
<li>上翻</li>
</ol>
<ul>
<li>定期检查进程</li>
<li>上翻到一个安全的状态 </li>
<li>如果发现死锁重启进程</li>
</ul>
<ol start="3">
<li>杀死进程</li>
</ol>
<ul>
<li>中断进程的最简单方法</li>
<li>杀死死锁循环中的一个进程</li>
<li>其他进程获得它的资源 </li>
<li>选择可以重新开始运行的进程</li>
</ul>
<h3 id="死锁的动态避免"><a href="#死锁的动态避免" class="headerlink" title="*死锁的动态避免"></a>*死锁的动态避免</h3><h4 id="死锁的动态避免原则："><a href="#死锁的动态避免原则：" class="headerlink" title="死锁的动态避免原则："></a>死锁的动态避免原则：</h4><p>使用资源规划，确保该资源请求批准后系统不会进入到死锁或者潜在的死锁状态。</p>
<blockquote>
<ul>
<li>状态分类为：<strong>安全状态</strong>和<strong>不安全状态</strong></li>
</ul>
<ol>
<li>安全状态<ul>
<li>指系统能按某种进程顺序（P1，P2，…，Pn），来为每个进程Pi分配其所需要资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利完成。</li>
</ul>
</li>
<li>不安全状态</li>
</ol>
</blockquote>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li><p>特点</p>
<ul>
<li>实现动态避免死锁</li>
<li>类似于一开始就预留所有的资源，但是更加高效</li>
</ul>
</li>
<li><p>介绍：</p>
</li>
</ul>
<ol>
<li>事先声明所需的最大资源，但实际上并不获得资源</li>
<li>当之后进程要求资源时, 银行家算法的策略:<ul>
<li>安全状态下满足要求</li>
<li>如果处于不安全状态则阻塞进程</li>
</ul>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程的缺陷"><a href="#进程的缺陷" class="headerlink" title="进程的缺陷"></a>进程的缺陷</h3><ul>
<li><p>一个进程在一个时间只能做一件事情</p>
</li>
<li><p>阻塞将使进程挂起，整个进程都无法继续执行</p>
</li>
</ul>
<h3 id="线程产生的原因"><a href="#线程产生的原因" class="headerlink" title="线程产生的原因"></a>线程产生的原因</h3><h4 id="进程的基本属性"><a href="#进程的基本属性" class="headerlink" title="进程的基本属性"></a>进程的基本属性</h4><ol>
<li>进程是拥有资源的独立单位.</li>
<li>进程是独立调度和分派的基本单位</li>
</ol>
<p>进程是资源拥有者，因而在进程的创建、撤消和切换中系统必须为之付出较大的时间、空间开销。因此，系统中所设置的进程的数目不宜过多，进程切换的频率不宜过高。这就限制了进程并发程度的提高。</p>
<p>&#x3D;&gt; 将进程的两个基本属性分开</p>
<h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>线程是进程中的一个实体，是系统独立调度和分派的基本单位。</p>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ol>
<li>轻型实体。 </li>
<li>独立调度和分派的基本单位。 </li>
<li>可并发执行。 </li>
<li>共享进程资源。</li>
</ol>
<h3 id="资源的共享与独享"><a href="#资源的共享与独享" class="headerlink" title="资源的共享与独享"></a>资源的共享与独享</h3><ol>
<li><p>有些资源被进程内所有的线程共享</p>
</li>
<li><p>有些资源是每个线程独享的</p>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>线程共享资源</strong></th>
<th><strong>线程独享资源</strong></th>
</tr>
</thead>
<tbody><tr>
<td>地址空间</td>
<td>程序计数器</td>
</tr>
<tr>
<td>全局变量</td>
<td>寄存器</td>
</tr>
<tr>
<td>打开的文件</td>
<td>栈</td>
</tr>
<tr>
<td>子进程</td>
<td>状态字</td>
</tr>
<tr>
<td>闹铃</td>
<td></td>
</tr>
<tr>
<td>信号及信号服务程序</td>
<td></td>
</tr>
<tr>
<td>记账信息</td>
<td></td>
</tr>
</tbody></table>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><h4 id="状态参数（Threaded-Control-Block，TCB）"><a href="#状态参数（Threaded-Control-Block，TCB）" class="headerlink" title="状态参数（Threaded Control Block，TCB）"></a>状态参数（Threaded Control Block，TCB）</h4><p>在OS中的每一个线程都可以利用线程标识符和一组状态参数进行描述。状态参数通常有：</p>
<p>① 寄存器状态， 它包括程序计数器PC和堆栈指针中的内容； </p>
<p>② 堆栈， 在堆栈中通常保存有局部变量和返回地址； </p>
<p>③ 线程运行状态， 用于描述线程正处于何种运行状态；</p>
<p>④ 优先级， 描述线程执行的优先程度； </p>
<p>⑤ 线程专有存储器， 用于保存线程自己的局部变量拷贝； </p>
<p>⑥ 信号屏蔽， 即对某些信号加以屏蔽。 </p>
<h4 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a>三种基本状态</h4><p>①执行状态，表示线程正获得处理机而运行；</p>
<p>②就绪状态，指线程已具备了各种执行条件，一旦获得CPU便可执行的状态；</p>
<p>③阻塞状态，指线程在执行中因某事件而受阻，处于暂停执行时的状态。  </p>
<h3 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h3><ul>
<li>创建</li>
</ul>
<p>在多线程OS环境下，应用程序在启动时，通常仅有一个线程在执行，该线程被人们称为“初始化线程”。它可根据需要再去创建若干个线程。在创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程创建函数执行完后，将返回一个线程标识符供以后使用。</p>
<ul>
<li>终止</li>
</ul>
<p>终止线程的方式有两种：一种是在线程完成了自己的工作后自愿退出；另一种是线程在运行中出现错误或由于某种原因而被其它线程强行终止。 </p>
<h3 id="多线程操作系统中的进程"><a href="#多线程操作系统中的进程" class="headerlink" title="多线程操作系统中的进程"></a>多线程操作系统中的进程</h3><p>在多线程OS中，进程是作为拥有系统资源的基本单位，通常的进程都包含多个线程并为它们提供资源，但此时的进程就不再作为一个执行的实体。多线程OS中的进程有以下属性：       </p>
<p>(1) 作为系统资源分配的单位。        </p>
<p>(2) 可包括多个线程。        </p>
<p>(3) 进程不是一个可执行的实体。 </p>
<h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><ol>
<li>内核态线程的实现（Windows XP、IBM OS&#x2F;2）</li>
<li>用户态线程的实现（Java，Informix）</li>
<li>组合实现（Solaris）</li>
</ol>
<h4 id="内核态线程的实现（Windows-XP、IBM-OS-2）"><a href="#内核态线程的实现（Windows-XP、IBM-OS-2）" class="headerlink" title="内核态线程的实现（Windows XP、IBM OS&#x2F;2）"></a>内核态线程的实现（Windows XP、IBM OS&#x2F;2）</h4><ul>
<li>完全在内核空间实现</li>
<li>内核空间设置线程控制块OS </li>
<li>进行线程调度、资源分配等</li>
<li>OS 维护线程的信息</li>
</ul>
<blockquote>
<p>优缺点：</p>
<ul>
<li>优点</li>
</ul>
<ol>
<li>多处理器系统中，内核能同时调度同一进程中多个线程并行执行。</li>
<li>阻塞线程不会阻塞进程。</li>
<li>内核态线程具有很小的数据结构和堆栈，线程切换快，切换开销小。</li>
<li>内核本身可采用多线程技术，提高系统执行速度和效率。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>多处理器系统中，内核能同时调度同一进程中多个线程并行执行。</li>
<li>阻塞线程不会阻塞进程。</li>
<li>内核态线程具有很小的数据结构和堆栈，线程切换快，切换开销小。</li>
<li>内核本身可采用多线程技术，提高系统执行速度和效率。</li>
</ol>
</blockquote>
<h4 id="用户态线程的实现（Java，Informix）"><a href="#用户态线程的实现（Java，Informix）" class="headerlink" title="用户态线程的实现（Java，Informix）"></a>用户态线程的实现（Java，Informix）</h4><ul>
<li>在用户空间实现。用户空间建立线程库：一组管理线程的过程</li>
<li>用户自己写执行系统进行调度。</li>
<li>线程自愿合作。</li>
<li>操作系统不知道线程的存在，     其调度仍以进程为单位执行。</li>
</ul>
<blockquote>
<p>优缺点：</p>
<ol>
<li><p>优点</p>
</li>
<li><p>线程切换快：不需要陷入到内核空间</p>
</li>
<li><p>线程调度是应用程序特定的：可以选择最好的算法</p>
</li>
<li><p>灵活性，可以在任何操作系统上实现</p>
</li>
<li><p>缺点</p>
</li>
<li><p>编程困难</p>
</li>
<li><p>多线程应用不能利用多处理机提高并行效率</p>
</li>
<li><p>系统调用的阻塞问题，线程受阻导致整个进程受阻!</p>
</li>
</ol>
</blockquote>
<h4 id="组合实现（Solaris）"><a href="#组合实现（Solaris）" class="headerlink" title="组合实现（Solaris）"></a>组合实现（Solaris）</h4><ul>
<li>执行系统管理用户态线程</li>
<li>操作系统管理内核态线程</li>
<li>用户态线程被多路复用到内核态线程上</li>
</ul>
<h5 id="Solaris"><a href="#Solaris" class="headerlink" title="Solaris"></a>Solaris</h5><p>Solaris的多线程模型中包括四种实体：进程，内核线程，用户线程和轻量级进程（Light Weight Process，LWP）</p>
<ul>
<li>Solaris内核是多线程的<ul>
<li>进程是资源分配和管理的单元</li>
<li>内核级线程是内核的调度单元</li>
<li>用户级线程是程序执行在用户态的抽象</li>
<li>LWP把用户线程和内核线程绑定到一起：</li>
</ul>
</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程是指在单个进程内同时执行多个线程的并发编程模型。每个线程是进程中的独立执行路径，它可以独立执行任务，并且共享相同进程的资源，如内存空间、文件句柄等。多线程的主要优势包括提高系统资源利用率、增加程序响应速度、简化编程模型等。</p>
<p>以下是多线程的一些重要概念和特点：</p>
<ol>
<li><strong>并发性</strong>：多线程允许多个任务同时执行，提高了系统的并发性。每个线程独立执行，它们之间可以并发执行，从而实现了程序的并行处理。</li>
<li><strong>共享内存</strong>：在多线程编程中，各个线程共享同一进程的内存空间。这意味着线程可以方便地共享数据，但也需要考虑线程间的同步和互斥，以避免数据竞争和不一致的情况。</li>
<li><strong>轻量级</strong>：与进程相比，线程是更轻量级的执行单元。创建和销毁线程的开销比创建和销毁进程要小得多，因此多线程通常更适合于处理大量的并发任务。</li>
<li><strong>并行性</strong>：多线程可以在多核处理器上实现并行执行，从而提高了程序的性能。在具有多个核心的系统中，不同线程可以在不同的核心上并行执行，从而更有效地利用系统资源。</li>
<li><strong>线程同步</strong>：多线程编程需要考虑线程之间的同步和互斥问题。当多个线程访问共享资源时，需要使用同步机制来保证数据的一致性，例如使用锁、信号量、条件变量等。</li>
<li><strong>线程调度</strong>：线程的调度由操作系统负责，操作系统根据线程的优先级和调度算法来确定线程的执行顺序。不同的操作系统可能有不同的线程调度策略。</li>
</ol>
<p>多线程广泛应用于各种计算机应用中，包括服务器编程、图形界面程序、游戏开发、数据处理等。它提供了一种有效的方式来处理并发任务，提高系统的性能和响应速度。</p>
<h4 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h4><h5 id="共享内存-1"><a href="#共享内存-1" class="headerlink" title="共享内存"></a>共享内存</h5><p>在共享内存模型中，多个线程共享同一进程的内存空间。线程可以通过读写共享内存来进行通信。常见的共享内存通信方式包括：</p>
<ol>
<li><strong>互斥锁（Mutex）</strong>：使用互斥锁来保护共享资源，只有获取锁的线程可以访问共享资源，其他线程需要等待直到锁被释放。这样可以防止多个线程同时修改共享资源导致的数据竞争问题。</li>
<li><strong>条件变量（Condition Variable）</strong>：条件变量用于在线程之间传递信号，允许线程等待某个条件变为真。一个线程可以在条件变量上等待，而另一个线程可以通过发送信号来通知等待的线程条件已经满足。</li>
<li><strong>信号量（Semaphore）</strong>：信号量是一种计数器，用于控制对共享资源的访问。它可以确保多个线程不会同时访问临界区，从而避免竞争条件。</li>
</ol>
<h5 id="消息传递-1"><a href="#消息传递-1" class="headerlink" title="消息传递"></a>消息传递</h5><p>在消息传递模型中，线程之间通过发送消息来进行通信，而不共享内存。常见的消息传递通信方式包括：</p>
<ol>
<li><strong>消息队列（Message Queue）</strong>：线程可以通过向消息队列发送消息或者从消息队列接收消息来进行通信。消息队列可以是进程内的，也可以是跨进程的。</li>
<li><strong>管道（Pipe）</strong>：管道是一种特殊的文件，用于进程间通信。线程可以通过管道来发送和接收数据。</li>
<li><strong>套接字（Socket）</strong>：套接字是在网络编程中使用的一种通信机制，它也可以在同一台主机的不同线程之间进行通信。</li>
<li><strong>消息传递接口（MPI）</strong>：MPI是一种用于并行计算的标准通信库，它提供了一套丰富的消息传递函数，用于在并行计算中进行进程间通信。</li>
</ol>
<h4 id="线程之间的同步"><a href="#线程之间的同步" class="headerlink" title="线程之间的同步"></a>线程之间的同步</h4><h5 id="互斥锁（Mutex）"><a href="#互斥锁（Mutex）" class="headerlink" title="互斥锁（Mutex）"></a>互斥锁（Mutex）</h5><p>互斥锁是一种最常见的线程同步机制。它用于保护共享资源，一次只允许一个线程访问共享资源。线程在访问共享资源之前会尝试获取互斥锁，如果成功获取，则可以访问资源，否则会阻塞直到锁可用。</p>
<h5 id="2-条件变量（Condition-Variable）"><a href="#2-条件变量（Condition-Variable）" class="headerlink" title="2. 条件变量（Condition Variable）"></a>2. 条件变量（Condition Variable）</h5><p>条件变量允许一个线程等待某个条件为真，当条件为真时，另一个线程可以通过发送信号来通知等待线程。它通常与互斥锁一起使用，用于实现线程间的等待和唤醒机制。</p>
<h5 id="3-信号量（Semaphore）"><a href="#3-信号量（Semaphore）" class="headerlink" title="3. 信号量（Semaphore）"></a>3. 信号量（Semaphore）</h5><p>信号量是一个计数器，用于控制对共享资源的访问。它可以用来限制同时访问某一资源的线程数量。信号量通常用于解决生产者-消费者问题等场景。</p>
<h5 id="4-屏障（Barrier）"><a href="#4-屏障（Barrier）" class="headerlink" title="4. 屏障（Barrier）"></a>4. 屏障（Barrier）</h5><p>屏障用于等待多个线程都到达某一点之后再继续执行。当所有线程都到达屏障点时，它们会被释放，然后继续执行后续操作。</p>
<h5 id="5-自旋锁（Spin-Lock）"><a href="#5-自旋锁（Spin-Lock）" class="headerlink" title="5. 自旋锁（Spin Lock）"></a>5. 自旋锁（Spin Lock）</h5><p>自旋锁是一种不会阻塞线程的锁，当一个线程尝试获取锁时，如果锁已被其他线程占用，它会一直自旋等待直到锁可用。自旋锁适用于锁被持有时间短、并发度高的情况。</p>
<h5 id="6-读写锁（Read-Write-Lock）"><a href="#6-读写锁（Read-Write-Lock）" class="headerlink" title="6. 读写锁（Read-Write Lock）"></a>6. 读写锁（Read-Write Lock）</h5><p>读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁适用于读操作远远多于写操作的情况，可以提高并发性能。</p>
<h5 id="7-原子操作（Atomic-Operation）"><a href="#7-原子操作（Atomic-Operation）" class="headerlink" title="7. 原子操作（Atomic Operation）"></a>7. 原子操作（Atomic Operation）</h5><p>原子操作是一种不可中断的操作，它可以保证在多线程环境下对共享变量的操作是原子的，从而避免了数据竞争问题。</p>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><h1 id="4-处理机调度"><a href="#4-处理机调度" class="headerlink" title="4. *处理机调度"></a>4. *处理机调度</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&#x3D;&#x3D;处理机调度指在多道程序环境下将处理机分配给各<strong>进程</strong>&#x3D;&#x3D;</p>
<h3 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h3><h4 id="作业概念"><a href="#作业概念" class="headerlink" title="作业概念"></a>作业概念</h4><p>作业：作业是用户在一次解题或一个事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据及命令等。</p>
<p>作业由一组统一管理和操作的进程集合构成，是用户要求计算机系统完成的一项相对独立的工作。</p>
<h4 id="作业分类"><a href="#作业分类" class="headerlink" title="作业分类"></a>作业分类</h4><h5 id="按需要处理工作的类型"><a href="#按需要处理工作的类型" class="headerlink" title="按需要处理工作的类型"></a>按需要处理工作的类型</h5><ol>
<li><p>计算型作业</p>
<blockquote>
<ul>
<li><strong>特点</strong>：<ul>
<li>计算密集型作业是指需要大量的 CPU 计算资源来完成的任务。</li>
<li>这类作业通常不需要太多的输入输出操作，而是以大量的计算为主。</li>
<li>例如，科学计算、数值模拟、图形渲染等任务就属于计算密集型作业。</li>
</ul>
</li>
<li><strong>特征</strong>：<ul>
<li>需要大量的 CPU 计算时间，但相对较少的 I&#x2F;O 操作。</li>
<li>对 CPU 的利用率较高，但是可能会导致其他任务在等待 CPU 资源时出现阻塞。</li>
</ul>
</li>
<li><strong>优化</strong>：<ul>
<li>优化计算算法和数据结构，以减少计算时间和资源消耗。</li>
<li>可以采用并行计算的方式，利用多核处理器或分布式计算集群来加速计算过程。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>I&#x2F;O型作业</p>
<blockquote>
<ul>
<li><strong>特点</strong>：<ul>
<li>I&#x2F;O 密集型作业是指需要大量的输入输出操作来完成的任务。</li>
<li>这类作业通常对 CPU 的要求不高，但需要大量的数据传输和处理。</li>
<li>例如，文件操作、网络通信、数据库查询等任务就属于 I&#x2F;O 密集型作业。</li>
</ul>
</li>
<li><strong>特征</strong>：<ul>
<li>需要大量的输入输出操作，而计算操作相对较少。</li>
<li>对 CPU 的利用率较低，但可能会导致 CPU 等待 I&#x2F;O 操作完成而出现阻塞。</li>
</ul>
</li>
<li><strong>优化</strong>：<ul>
<li>优化 I&#x2F;O 操作，减少等待时间，例如使用异步 I&#x2F;O、缓存等技术。</li>
<li>可以采用多线程或事件驱动的方式来处理并发的 I&#x2F;O 操作，提高系统的响应性。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<h5 id="按作业提交的方式不同"><a href="#按作业提交的方式不同" class="headerlink" title="按作业提交的方式不同"></a>按作业提交的方式不同</h5><ol>
<li><p>批处理作业</p>
<blockquote>
<ul>
<li><strong>特点</strong>：<ul>
<li>批处理作业是一组按顺序排列的任务，通常一次性提交给系统执行，而无需用户交互。</li>
<li>这些作业通常是长时间运行的，不需要实时用户交互。</li>
<li>作业提交后，系统会按照作业的顺序执行，并在完成后将结果输出到指定的输出设备或文件。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>批处理作业适用于一些需要大量计算和处理时间的任务，如大规模数据处理、科学计算、批量文件处理等。</li>
<li>典型的批处理作业包括数据分析、报表生成、批量图像处理等。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>可以高效地利用计算机资源，减少用户等待时间。</li>
<li>可以自动化执行，无需用户交互，提高了系统的整体效率。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>终端型作业</p>
<blockquote>
<ul>
<li><strong>特点</strong>：<ul>
<li>交互式作业是需要用户实时交互的任务，用户可以在程序执行过程中输入命令、进行数据输入或查看输出。</li>
<li>这些作业通常需要较短的响应时间，以满足用户实时操作的要求。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>交互式作业适用于需要用户实时交互和反馈的任务，如命令行界面、图形用户界面、文本编辑器等。</li>
<li>典型的交互式应用包括操作系统的命令行界面、办公软件、图像编辑器等。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>提供了实时的用户交互体验，可以根据用户的需求动态调整程序行为。</li>
<li>可以与用户直接交互，满足用户个性化的需求。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="作业控制块（Job-Control-Block，JCB）"><a href="#作业控制块（Job-Control-Block，JCB）" class="headerlink" title="作业控制块（Job Control Block，JCB）"></a>作业控制块（Job Control Block，JCB）</h4><p>JCB是作业在系统中存在的标志</p>
<ul>
<li>作业步：每个作业都要经过若干个相对独立而又相互关联的顺序加工步骤才能得到结果，每一个步骤称为一个作业步。</li>
<li>作业流：若干个作业进入系统后被依次存放在外存上，形成了输入的作业流。</li>
<li>作业的状态：一个作业进入系统到运行结束，一般需要经历收容、运行、完成三个阶段，与之相对应的是作业的三种状态（批处理作业）： <ul>
<li>后备状态 </li>
<li>运行状态 </li>
<li>完成状态</li>
</ul>
</li>
</ul>
<h4 id="作业和进程的关系"><a href="#作业和进程的关系" class="headerlink" title="作业和进程的关系"></a>作业和进程的关系</h4><p>&#x3D;&#x3D;作业是任务实体，进程是完成任务的执行实体&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;作业概念更多地用在批处理操作系统，而进程则可以用在各种多道程序设计系统。&#x3D;&#x3D;</p>
<h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><h3 id="低级调度（进程调度（Process-Scheduling））"><a href="#低级调度（进程调度（Process-Scheduling））" class="headerlink" title="低级调度（进程调度（Process Scheduling））"></a>低级调度（进程调度（Process Scheduling））</h3><p>低级调度概念</p>
<p>进程调度是处理机调度的最低层次，负责决定哪个<strong>进程</strong>将获得 CPU 的使用权。</p>
<h4 id="低级调度特征"><a href="#低级调度特征" class="headerlink" title="低级调度特征"></a>低级调度特征</h4><ul>
<li>主要任务是按照某种策略和方法选取一个处于就绪状态的进程，将处理机分配给它</li>
<li>低级调度的时间尺度通常是毫秒级的。由于低级调度算法的频繁使用，要求在实现时做到高效</li>
<li>常见的低级调度有非抢占式和抢占式两种</li>
</ul>
<blockquote>
<ul>
<li>**非抢占方式(Non-preemptive)**把处理机分配给某进程后，便让其一直执行，直到该进程完成或发生某事件而被阻塞时，才把处理机分配给其它进程，不允许其他进程抢占已经分配出去的处理机。</li>
</ul>
<blockquote>
<p>**优点:**实现简单、系统开销小，适用于大多数批处理系统环境；</p>
<p>**缺点:**难以满足紧急任务的要求，不适用于实时、分时系统要求</p>
<p><strong>引起进程调度的因素</strong>：</p>
<ol>
<li>正在执行的进程执行完毕，或因发生某事件而不能再继续执行</li>
<li>执行中的进程因提出I&#x2F;O请求而暂停执行</li>
<li>在进程通信或同步过程中执行了某种原语操作，如Block、Wakeup原语</li>
</ol>
</blockquote>
<ul>
<li>**抢占方式(Preemptive)**允许调度程序根据某个原则，去停止某个正在执行的进程，将处理机重新分配给另一个进程。</li>
</ul>
<blockquote>
<p>**优点:**适于时间要求严格的实时系统</p>
<p>**缺点:**调度算法复杂，系统开销大</p>
<p><strong>抢占式调度主要有以下原则：</strong></p>
<ol>
<li>优先权原则：允许高优先权的新到进程抢占当前进程的处理机</li>
<li>短作业(进程)优先原则：允许执行时间短的新到进程抢占当前进程的处理机 </li>
<li>时间片原则：时间片用完后停止执行，重新进行调度，适用于分时系统</li>
</ol>
</blockquote>
</blockquote>
<h3 id="中级调度（Medium-term-Scheduling）"><a href="#中级调度（Medium-term-Scheduling）" class="headerlink" title="中级调度（Medium-term Scheduling）"></a>中级调度（Medium-term Scheduling）</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>​	为了提高内存利用率和系统吞吐量。使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待。</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>​	按照给定的原则和策略，将处于外存对换区中重要的又具备运行条件的就绪进程调入内存，或将处于内存就绪状态或内存阻塞状态的进程交换到外存对换区。</p>
<h3 id="高级调度（作业调度（Job-Scheduling）"><a href="#高级调度（作业调度（Job-Scheduling）" class="headerlink" title="高级调度（作业调度（Job Scheduling）"></a>高级调度（作业调度（Job Scheduling）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>作业调度是处理机调度的最高层次，负责从外存中选择作业并将其调入内存，以便进一步执行。</p>
<h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><ol>
<li>最大化系统的吞吐量和效率，即尽可能地保持 CPU 处于忙碌状态，</li>
<li>同时避免资源的空闲浪费。</li>
</ol>
<h4 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h4><p>​	按一定的原则对外存上处于后备状态的作业进行选择，给选中的作业分配内存、输入&#x2F;输出设备等必要的资源，并建立相应的进程，放入就绪队列，以使该作业的进程获得竞争处理机的权利</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><ol>
<li>当一个进程运行完毕或由于某种错误而终止运行</li>
<li>当一个进程在运行中处于等待状态（等待I&#x2F;O）</li>
<li>分时系统中时间片到（就绪）</li>
<li>可抢占下，当有一个优先级更高的进程就绪  例如：新创建一个进程，或一个阻塞进程变成就绪</li>
<li>在进程通信中，执行中的进程执行了某种原语操作（P操作，阻塞原语）</li>
</ol>
<h2 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h2><p>只要OS取得对CPU的控制，进程切换就可能发生: </p>
<ol>
<li>超级用户调用来自程序的显式请求 (如：打开文件)，该进程通常会被阻塞 </li>
<li>陷阱最末（新）一条指令导致出错，会引起进程移至退出状态 </li>
<li>中断 外部因素影响当前指令的执行，控制被转移至IH（中断处理程序）</li>
</ol>
<h2 id="调度队列模型"><a href="#调度队列模型" class="headerlink" title="调度队列模型"></a>调度队列模型</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ol>
<li>仅有进程调度的调度队列模型</li>
<li>具有高级和低级调度的调度队列模型</li>
<li>同时具有三级调度的调度队列模型</li>
</ol>
<h3 id="仅有进程调度的调度队列模型"><a href="#仅有进程调度的调度队列模型" class="headerlink" title="仅有进程调度的调度队列模型"></a>仅有进程调度的调度队列模型</h3><ul>
<li>在分时系统中，通常仅设有进程调度</li>
<li>系统把这些进程组织成一个就绪队列</li>
<li>每个进程在执行时，可能有以下几种情况：进<ul>
<li>程获得CPU正在执行</li>
<li>任务在给定时间片内已完成，释放处理机后为完成状态</li>
<li>任务在时间片内未完成，进入就绪队列末尾</li>
<li>在执行期间因某事件而阻塞</li>
</ul>
</li>
</ul>
<h3 id="具有高级和低级调度的调度队列模型"><a href="#具有高级和低级调度的调度队列模型" class="headerlink" title="具有高级和低级调度的调度队列模型"></a>具有高级和低级调度的调度队列模型</h3><p>在批处理系统中，不仅需要进程调度，而且还要有作业调度</p>
<ul>
<li>就绪队列的形式在批处理系统中，常用高优先权队列。进程进入就绪队列时，按优先权高低插入相应位置，调度程序总是把处理机分配给就绪队列首进程</li>
<li>设置多个阻塞队列根据事件的不同设置多个队列提高效率</li>
</ul>
<h3 id="同时具有三级调度的调度队列模型"><a href="#同时具有三级调度的调度队列模型" class="headerlink" title="同时具有三级调度的调度队列模型"></a>同时具有三级调度的调度队列模型</h3><p>这种模型一般包括以下三个调度队列：</p>
<h4 id="1-高优先级队列（High-Priority-Queue）："><a href="#1-高优先级队列（High-Priority-Queue）：" class="headerlink" title="1. 高优先级队列（High Priority Queue）："></a>1. 高优先级队列（High Priority Queue）：</h4><ul>
<li><strong>特点</strong>：<ul>
<li>这个队列用于存放优先级较高的进程，例如实时进程或紧急任务等。</li>
<li>这些进程通常要求立即执行，因此会被优先调度。</li>
</ul>
</li>
<li><strong>调度策略</strong>：<ul>
<li>可能采用最高响应比优先（HRRN）或优先级调度等策略。</li>
</ul>
</li>
</ul>
<h4 id="2-中优先级队列（Medium-Priority-Queue）："><a href="#2-中优先级队列（Medium-Priority-Queue）：" class="headerlink" title="2. 中优先级队列（Medium Priority Queue）："></a>2. 中优先级队列（Medium Priority Queue）：</h4><ul>
<li><strong>特点</strong>：<ul>
<li>这个队列用于存放普通优先级的进程，即不属于高优先级或低优先级的进程。</li>
<li>这些进程的执行不是很紧急，但也不能被忽视。</li>
</ul>
</li>
<li><strong>调度策略</strong>：<ul>
<li>可能采用轮转调度（Round Robin）等策略，以平衡各个进程之间的执行时间。</li>
</ul>
</li>
</ul>
<h4 id="3-低优先级队列（Low-Priority-Queue）："><a href="#3-低优先级队列（Low-Priority-Queue）：" class="headerlink" title="3. 低优先级队列（Low Priority Queue）："></a>3. 低优先级队列（Low Priority Queue）：</h4><ul>
<li><strong>特点</strong>：<ul>
<li>这个队列用于存放优先级较低的进程，例如后台任务或者长时间运行的任务。</li>
<li>这些进程的执行不紧急，通常在其他任务执行完毕后才会被调度执行。</li>
</ul>
</li>
<li><strong>调度策略</strong>：<ul>
<li>可能采用先来先服务（FCFS）等策略，确保这些任务不会长时间被阻塞。</li>
</ul>
</li>
</ul>
<h4 id="调度过程："><a href="#调度过程：" class="headerlink" title="调度过程："></a>调度过程：</h4><ul>
<li>当系统空闲时，调度器会首先从高优先级队列中选择一个进程执行。</li>
<li>如果高优先级队列为空，调度器则会从中优先级队列中选择进程执行。</li>
<li>当高优先级或中优先级队列中的进程执行完毕或者发生阻塞时，调度器会从低优先级队列中选择一个进程执行。</li>
<li>进程从低优先级队列中执行完毕后，如果没有更高优先级的进程需要执行，则继续选择低优先级队列中的下一个进程执行。</li>
</ul>
<h2 id="调度目标"><a href="#调度目标" class="headerlink" title="调度目标"></a>调度目标</h2><h3 id="不同类型系统的调度目标"><a href="#不同类型系统的调度目标" class="headerlink" title="不同类型系统的调度目标"></a>不同类型系统的调度目标</h3><ol>
<li><p>批处理系统</p>
<blockquote>
<p>系统吞吐率:最大化单位时间的工作量</p>
<p>周转时间:最小化任务提交到结束之间的时间</p>
<p>CPU 利用率:保持CPU始终处在繁忙工作状态</p>
</blockquote>
</li>
<li><p>交互式系统</p>
<blockquote>
<p>响应时间—快速响应需求</p>
<p>适度性—满足用户期望</p>
</blockquote>
</li>
<li><p>实时系统</p>
<blockquote>
<p>满足截止时间—避免丢失数据</p>
<p>提供性能可预测性</p>
</blockquote>
</li>
</ol>
<h3 id="不同使用模式的调度目标"><a href="#不同使用模式的调度目标" class="headerlink" title="不同使用模式的调度目标"></a>不同使用模式的调度目标</h3><ol>
<li><p>对于计算密集型程序，极大化系统吞吐量</p>
<ul>
<li>单位时间内完成尽可能多的程序</li>
</ul>
</li>
<li><p>对于I&#x2F;O密集型程序，极小化平均响应时间</p>
<p> ​	* 平均化完成每项工作的时间</p>
</li>
<li><p>对于平衡性程序，响应时间和周转时间之间的平衡</p>
<ul>
<li>各进程之间以某种平等的方式共享 CPU</li>
</ul>
</li>
</ol>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务-First-Come-First-Served，FCFS"><a href="#先来先服务-First-Come-First-Served，FCFS" class="headerlink" title="先来先服务(First Come First Served，FCFS)"></a>先来先服务(First Come First Served，FCFS)</h3><p>按照作业&#x2F;进程进入系统的先后次序进行调度，先进入系统者先调度；即启动等待时间最长的作业&#x2F;进程</p>
<p>是一种最简单的调度算法，既可用于作业调度，也可用于进程调度</p>
<ul>
<li><p>周转时间：完成时间-到达时间</p>
</li>
<li><p>带权周转时间：周转时间&#x2F;服务时间</p>
</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>优点<ol>
<li>有利于长作业（进程）</li>
<li>有利于CPU繁忙型作业（进程）</li>
<li>用于批处理系统</li>
</ol>
</li>
<li>缺点<ol>
<li>不利于短作业（进程）</li>
<li>不利于I&#x2F;O繁忙型作业（进程）</li>
<li>不适于分时系统</li>
</ol>
</li>
</ol>
<h3 id="短作业-进程-优先（Short-Job-Process-First，SJF-SPF）"><a href="#短作业-进程-优先（Short-Job-Process-First，SJF-SPF）" class="headerlink" title="短作业(进程)优先（Short Job\Process First，SJF\SPF）"></a>短作业(进程)优先（Short Job\Process First，SJF\SPF）</h3><p>以要求运行时间长短进行调度，即启动要求运行时间最短的作业</p>
<ul>
<li><p>短作业优先调度算法SJF，是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行； </p>
</li>
<li><p>短进程优先调度算法SPF，则是从就绪队列中选出一估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>对长作业不利。严重的是，若一长作业(进程)进入系统的后备队列(就绪队列)，由于调度程序总是优先调度那些(即使是后进来的)短作业(进程)，将导致长作业(进程)长期不被调度——饥饿</li>
<li>完全未考虑作业(进程)的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li>
<li>由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</li>
</ol>
<h3 id="高优先权优先（Highest-Priority-First，HPF）"><a href="#高优先权优先（Highest-Priority-First，HPF）" class="headerlink" title="高优先权优先（Highest Priority First，HPF）"></a>高优先权优先（Highest Priority First，HPF）</h3><p>优先权调度算法的类型</p>
<ol>
<li>非抢占式优先权调度算法</li>
<li>抢占式优先权调度算法</li>
</ol>
<h4 id="非抢占式优先权调度算法"><a href="#非抢占式优先权调度算法" class="headerlink" title="非抢占式优先权调度算法"></a>非抢占式优先权调度算法</h4><p>特点：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成，或因发生某事件使该进程放弃处理机时，系统才将处理机重新分配给另一优先权最高的进程</p>
<p>主要用于批处理系统中，也可用于某些对实时性要求不严格的实时系统中</p>
<h4 id="抢占式优先权调度算法"><a href="#抢占式优先权调度算法" class="headerlink" title="抢占式优先权调度算法"></a>抢占式优先权调度算法</h4><p>特点：把处理机分配给优先权最高的进程，但在执行期间，只要出现另一个优先权更高的进程，则进程调度程序就立即停止当前进程的执行，并将处理机分配给新到的优先权最高的进程</p>
<p>注意：只要系统中出现一个新的就绪进程，就进行优先权比较</p>
<p>该调度算法，能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中</p>
<h4 id="优先权的类型"><a href="#优先权的类型" class="headerlink" title="优先权的类型"></a>优先权的类型</h4><ol>
<li><p>静态优先权</p>
<blockquote>
<p>静态优先权在创建进程时确定，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0～7或0～255， 又把该整数称为优先数</p>
<p>特点：系统开销小、不够精确、一般用在要求不高的系统中</p>
</blockquote>
</li>
<li><p>动态优先权</p>
</li>
</ol>
<blockquote>
<p>随进程的推进或随其等待时间的增加而改变，以获得更好的调度性能</p>
<p>具有相同优先权初值的进程，则最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即FCFS算法</p>
<p>具有各不相同的优先权初值的就绪进程，则优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机</p>
<p>当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机</p>
</blockquote>
<h3 id="高响应比优先（Highest-Response-First，HRF）"><a href="#高响应比优先（Highest-Response-First，HRF）" class="headerlink" title="高响应比优先（Highest Response First，HRF）"></a>高响应比优先（Highest Response First，HRF）</h3><p>高响应比优先调度算法是FCFS和SJF的结合，克服了两种算法的缺点</p>
<p>调度策略：响应比最高的作业优先启动<br>$$<br>优先权&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}<br>$$<br>又可表示为<br>$$<br>优先权&#x3D;\frac{响应时间}{要求服务时间}<br>$$</p>
<h4 id="缺点：要进行响应比计算，增加了系统开销"><a href="#缺点：要进行响应比计算，增加了系统开销" class="headerlink" title="缺点：要进行响应比计算，增加了系统开销"></a>缺点：要进行响应比计算，增加了系统开销</h4><h3 id="基于时间片的轮转调度算法-Round-Robin，RR"><a href="#基于时间片的轮转调度算法-Round-Robin，RR" class="headerlink" title="基于时间片的轮转调度算法(Round Robin，RR)"></a>基于时间片的轮转调度算法(Round Robin，RR)</h3><p>系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片；当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便停止该进程的执行，并将其放就绪队列尾；然后，再把处理机分配给就绪队列中新的队首；</p>
<p>时间片的大小从几ms到几百ms。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点：公平。保证就绪队列中所有进程在一给定的时间内，均能获得一时间片的处理机执行时间</li>
<li>缺点：紧迫任务响应慢。UNIX中采用：时间片+优先权</li>
<li>时间片轮转策略特别适合于分时系统中使用</li>
</ul>
<h4 id="时间片长度的确定"><a href="#时间片长度的确定" class="headerlink" title="时间片长度的确定"></a>时间片长度的确定</h4><ul>
<li>过长：退化为FCFS 算法，进程在一个时间片内都执行完，响应时间长。  </li>
<li>过短：用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，系统开销大。</li>
<li>最佳的时间片量值应能使分时用户得到好的响应时间</li>
</ul>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>设置多个就绪队列，并为各个队列赋予不同的优先级</p>
<p>第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低</p>
<p>该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍</p>
<ul>
<li>一个进程永久分到一个队列，每个队列有自己的调度算法</li>
<li>前台的就绪队列是交互性作业的进程，采用时间片轮转。</li>
<li>后台的就绪队列是批处理作业的进程，采用优先权或短作业优先算法。</li>
<li><strong>调度方式</strong>有两种： 优先调度前台，若前台无可运行进程，才调度后台 分配占用CPU的时间比例，如：前台80%，后台20%</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>终端型作业用户终端型作业用户所提交的作业多属于交互型作业，通常较小，系统只要能使这些作业在第一队列所规定的时间片内完成即可 </li>
<li>短批处理作业用户若在第1队列中执行一个时间片即可完成，便可获得与终端型作业一样的响应时间如在第一个队列中不能完成，只需在第2、3队列中各执行一个时间片 </li>
<li>长批处理作业用户长作业将依次在第1，2，3…，n队列中执行，最终按轮转方式运行</li>
</ul>
<h3 id="其他调度算法"><a href="#其他调度算法" class="headerlink" title="其他调度算法"></a>其他调度算法</h3><ol>
<li><strong>保证调度</strong>保证每个进程享用CPU的时间完全一样，即如果系统中共有n个进程，保证每个进程使用 1&#x2F;n  CPU 时间（需要计算CPU获得比率）。</li>
<li>彩票调度概率调度算法，发布一定数量的彩票给相应的进程，调度器每次随机抽取一张，彩票数量多的进程获得CPU的概率就大。</li>
<li><strong>用户公平调度</strong>按照每个用户而不是每个进程来公平分配CPU。如果一个用户的进程数量多，则其所拥有的每个进程获得CPU时间将短。</li>
<li><strong>混合调度算法</strong> (Multiple queue)将优先级分类各类内部采用轮转调度动态调整进程的优先级类别（否则产生饥饿）</li>
</ol>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><h4 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h4><ol>
<li>提供必要的调度信息<ul>
<li>就绪时间</li>
<li>开始&#x2F;完成截止时间；</li>
<li>处理时间；</li>
<li>资源要求；</li>
<li>优先级；</li>
</ul>
</li>
<li>系统处理能力强</li>
<li>采用抢占调度方式</li>
<li>具有快速切换机制</li>
</ol>
<h4 id="最早截止时间优先算法（EDF）"><a href="#最早截止时间优先算法（EDF）" class="headerlink" title="最早截止时间优先算法（EDF）"></a>最早截止时间优先算法（EDF）</h4><p>最早截止时间优先算法（EDF）根据任务的截止时间来确定任务的优先级</p>
<p>总是运行最早结束的作业</p>
<p>如果一个新到达的进程比正在运行的进程截止期靠前非抢占：非周期实时任务抢占：周期实时任务</p>
<h4 id="最低松弛度优先LLF算法"><a href="#最低松弛度优先LLF算法" class="headerlink" title="最低松弛度优先LLF算法"></a>最低松弛度优先LLF算法</h4><p>松弛度：若A进程需在200ms时完成，其本身运行需要100ms，当前时刻是10ms，则A的松弛度为：200－100－10＝90松弛度&#x3D;截止时间-要求服务时间-当前时刻主要用于可抢占的调度方式中例：两个周期性实时任务A、B，任务A每20ms执行一次，执行时间是10ms；任务B每50ms执行一次，执行时间是25ms。</p>
<h1 id="5-存储管理"><a href="#5-存储管理" class="headerlink" title="5. *存储管理"></a>5. *存储管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><ul>
<li>内存架构<ol>
<li>CPU寄存器: 低容量、高速度、高价格</li>
<li>主存: 中容量、中速度、中价格</li>
<li>辅存: 大容量、低速度、低成本</li>
</ol>
</li>
</ul>
<h3 id="1-处理器寄存器-register"><a href="#1-处理器寄存器-register" class="headerlink" title="1. 处理器寄存器 register"></a>1. 处理器寄存器 register</h3><p>​	用于存储处理器中与控制流和数据流相关的信息。访问速度最快，价格十分昂贵，存储空间非常有限，只能存储少量信息。</p>
<h3 id="2-高速缓存cache"><a href="#2-高速缓存cache" class="headerlink" title="2. 高速缓存cache"></a>2. 高速缓存cache</h3><p>​	为了解决处理器与内存之间速度不匹配而引入的存储空间。其存储容量比处理器寄存器大，访问速度比内存快。如果高速缓存的访问命中率高，则处理器从整体上以接近高速缓存的速度访问存储器，明显快于访问内存。</p>
<h3 id="3-内存-main-memory"><a href="#3-内存-main-memory" class="headerlink" title="3. 内存  main memory"></a>3. 内存  main memory</h3><p>​	也称为主存。内存中存放有处理器执行时所需要的代码和数据。内存空间远远大于高速缓存空间。一个计算机系统中所配置内存的大小是衡量计算机系统性能的一个非常重要的指标。</p>
<h3 id="4-外存-secondary-memory"><a href="#4-外存-secondary-memory" class="headerlink" title="4. 外存 secondary memory"></a>4. 外存 secondary memory</h3><p>​	外存是计算机系统中最大规模的存储器，存储有计算机系统所需要的各种软件资源。包括各种磁盘、磁带、光盘以及其他移动存储设备。磁盘中的硬盘是计算机系统中大量联机信息的保存者。在存储器管理和设备管理中，硬盘又被作为内存的补充，实现虚拟存储器和虚拟设备的管理</p>
<h2 id="程序的装入与链接"><a href="#程序的装入与链接" class="headerlink" title="程序的装入与链接"></a>程序的装入与链接</h2><p>​	用户用高级语言编写的源程序，需要经过编译、链接和装入之后，才能被处理器运行。</p>
<ul>
<li><strong>编译</strong>将用户用高级语言编写的源程序转换为目标模块；</li>
<li><strong>链接</strong>将用户程序需要的所有目标模块链接在一起，形成一个可执行模块，即装入模块；</li>
<li><strong>装入</strong>将装入模块放入内存</li>
</ul>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>​	在程序装入内存前，装入模块中给出的程序地址为程序的逻辑地址或相对地址。一个用户作业的所有装入模块的逻辑地址集合称为该作业的逻辑地址空间。</p>
<p>​	当用户作业被装入内存后，其物理地址由用户作业所对应的进程物理地址体现，进程物理地址的总体构成了用户程序实际运行的物理地址空间。</p>
<p>​	为了保证用户作业的正确运行，必须把用户作业的逻辑地址转换为物理地址，这一工作由操作系统的存储管理单元（MMU）在作业装入内存的过程中完成，称为<strong>地址变换</strong>或<strong>重定位</strong>。</p>
<h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p>​	逻辑地址是指由程序产生的与段相关的偏移地址部分。由CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。也称为虚拟地址。如C语言中的&amp;操作（取地址），得到的是相对于当前进程数据段的地址（偏移地址），与物理地址无关。</p>
<h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p>​	在操作系统中，存储器管理功能负责为进程分配和回收内存，实现内存空间在时间和空间上的复用，在某一进程结束或撤销后，进程的内存空间可以由其它进程覆盖；		</p>
<p>​	从内部结构上看，计算机存储器由大量的字节阵列或字阵列组成，每个字节或字都有自己的地址，要访问存储器中的信息必须知道信息的地址。计算机的内存也称为物理内存，其地址从最低开始到最高上界，按照顺序编号，是一个一维线性存储空间。</p>
<p>​	内存中的地址称为物理地址。  物理地址就是物理存储器实际的寻址范围。</p>
<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>​	地址空间是一个进程可用于寻址内存的一套地址集合，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。      </p>
<p>​	当内存空间占满时，通过外存与内存的对换实现内存空间的虚拟扩充（虚拟空间）。存储器管理在提供多进程共享内存的同时，还通过可靠的隔离机制阻止一个进程读写另一个进程的内存，实现内存地址空间的保护。</p>
<h3 id="程序链接"><a href="#程序链接" class="headerlink" title="程序链接"></a>程序链接</h3><p>​	链接是将用户程序所需要的所有目标模块链接在一起的过程。</p>
<ol>
<li><p>静态链接</p>
<blockquote>
<p>​	静态链接指链接过程在程序装入内存前完成并形成整个程序的逻辑地址空间。</p>
<p>​	通常，由编译产生的所有目标模块的起始地址可能都是从0开始，每个模块中的程序代码地址都是相对于模块的起始地址。     例如，如果一个用户作业由3个目标模块A、B、C组成，长度分别为m、n、k，每个模块在链接前的起始地址都从0开始，</p>
<p>​	经过静态链接后，模块A、B和C被链接为一个大的模块，原来的模块B和C的起始地址根据模块A的地址进行了调整，分别为m和m + n.</p>
</blockquote>
</li>
<li><p>装入时动态链接</p>
<blockquote>
<p>​	装入时动态链接将目标模块的链接过程放在这些目标模块装入内存的过程中完成。目标模块在装入内存时，采用边装入边链接的方式。</p>
<p>​	优点：</p>
<ol>
<li>便于模块的修改和更新<ul>
<li>静态链接会使得系统每次修改或更新某个模块，都要重新完成所有模块的链接。装入时动态链接，只要模块没有装入内存，系统都可以随时修改和更新模块。</li>
</ul>
</li>
<li>便于实现目标模块的共享<ul>
<li>静态链接只要有某个目标模块被多个模块共享，会多次链接该目标模块，装入内存后，在内存中存在共享模块的多个副本。而装入时动态链接将共享模块只放一个版本在内存中，节约了内存，实现了真正的模块共享。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>运行时动态链接</p>
<blockquote>
<p>​	运行时动态链接是一种较先进的链接方式，在程序装入内存时不链接模块，将链接过程推迟到程序运行时进行。在程序运行过程中，若发现被调用的某个模块尚未装入内存，操作系统找到该模块，将其装入内存，同时链接到调用模块上。</p>
<p>​	运行时动态链接的优点除了具有装入时动态链接的优点外，还可以做到<strong>不运行的模块，不需要链接</strong>。与静态链接和装入时动态链接相比，更节约内存。静态链接和装入时动态链接都需要将程序的全部目标模块进行链接，使得某些在运行时不需要的目标模块也进行了链接，造成了内存空间的浪费。</p>
</blockquote>
</li>
</ol>
<h3 id="程序装入"><a href="#程序装入" class="headerlink" title="程序装入"></a>程序装入</h3><p>​	目标模块放入内存的过程为装入过程。</p>
<p>装入方式</p>
<ol>
<li><p>绝对装入方式、</p>
<blockquote>
<p>​	在编译前程序员写源程序的时候如果知道程序所对应的进程驻留在内存中的物理地址，则链接会按照模块在内存中的物理地址生成逻辑地址，装入程序根据装入模块中的逻辑地址将程序装入内存，这样的装入方式称为绝对装入方式。绝对装入方式下程序的逻辑地址和物理地址相同。</p>
<p>​	绝对装入方式对程序员的要求很高。程序员在编程时必须熟悉内存的使用情况，知道程序的物理地址，能够在内存中调整程序和数据的地址。</p>
<p>​	绝对装入方式适合用于实时操作系统和嵌入式操作系统，其他的操作系统很少采用。</p>
</blockquote>
</li>
<li><p>静态重定位装入方式</p>
<blockquote>
<p>​	静态重定位装入方式将程序装入内存时，<strong>系统根据内存当时的实际使用情况，将装入模块装入到内存的适当位置。</strong></p>
<p>​	“重定位”是指程序在内存中的物理地址不再是原来程序的逻辑地址，而是根据内存的情况被重新定位。  </p>
<p>​	“静态”指的是用户程序从逻辑地址到物理地址的变换过程在程序执行前完成，在执行期间不再改变。如果物理地址要发生改变，则需要进行重新装入。 </p>
<p>​	   优点：</p>
<ol>
<li><p>实现简单，从逻辑地址到物理地址变换不需要专门的硬件便能完成；</p>
</li>
<li><p>可用于多道程序环境。</p>
<p> 缺点：</p>
</li>
<li><p>程序在执行过程中不能在内存中移动。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>动态重定位装入方式</p>
</li>
</ol>
<blockquote>
<p>​	动态重定位装入方式可以使程序运行时，CPU访问内存前，重新定位程序在内存中的地址，实现内存管理的灵活性，提高内存空间的利用率</p>
<p>​	优点：</p>
<ol>
<li><p>目标模块装入内存时无需任何修改，因而装入之后再搬迁也不会影响其正确执行，这对于存储器紧缩、解决碎片问题是非常有利的；</p>
</li>
<li><p>一个程序由若干个相对独立的目标模块组成时，每个目标模块各装入一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的定位寄存器就行。</p>
</li>
</ol>
<p>缺点：	实现过程中需要附加硬件（重定位寄存器）支持，内存管理更加复杂。</p>
</blockquote>
<hr>
<p>​	在操作系统中，存储器管理功能负责为进程分配和回收内存，实现内存空间在时间和空间上的复用，在某一进程结束或撤销后，进程的内存空间可以由其它进程覆盖</p>
<p>​	达到两个目标:</p>
<ol>
<li>地址独立：程序发出的地址应与物理主存地址无关</li>
<li>地址保护：一个进程不能访问另一个进程的地址空间</li>
</ol>
<h2 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h2><p>​	为一个用户程序分配一个连续的内存空间。</p>
<ol>
<li><p>单一连续分配</p>
<ul>
<li><p>应用于单道编程</p>
</li>
<li><blockquote>
<p>最简单的存储管理方式</p>
<p>内存分为：系统区和用户区</p>
<p>缺点：</p>
<ol>
<li>将整个程序加载到内存空间</li>
<li>浪费资源 (CPU 和 Memory)</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>固定分区分配</p>
<ul>
<li><p>应用于多道编程</p>
</li>
<li><blockquote>
<p>多道编程中最简单的内存管理方式</p>
<ol>
<li><p>将内存划分为几个固定的区域，可同时装入多个作业&#x2F;任务</p>
</li>
<li><p>程序被加载到固定的分区</p>
</li>
</ol>
<p>将分区按大小排队，并将其地址、分配标识做记录</p>
<p>与单一连续分配方式比较，固定分区分配方式使得系统的资源利用率和吞吐量有一定程度的提高。</p>
<p>缺点：</p>
<ol>
<li>内存利用率不高      由于分区大小固定，装入进程的大小受到限制。超过最大分区的进程，只有采用覆盖技术才能在内存中运行，降低了系统的运行效率；较小的进程，造成内存“碎片”（内碎片、内零头），降低了内存的利用率。</li>
<li>划分分区大小困难      划分分区的大小对系统性能有很大影响，合理划分分区的大小很困难。</li>
<li>需要预先知道进程大小      固定分区分配方式适合进程大小已知的情况，如果进程大小不知或进程大小变化很大，则采用固定分区分配不是特别适合。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>可变分区分配</p>
<ul>
<li><p>应用于多道编程</p>
<ul>
<li><blockquote>
<p>​	根据作业的实际需要，动态地为之分配内存空间不在系统初始化时进行分区划分，而在每个用户作业装入内存时，根据作业的大小和内存的使用情况，动态划分分区并分配。克服了固定分区分配的内存利用率低的问题，更适合多道程序环境。</p>
<p>​	为了完成有效分配和回收分区，需要构建对分区信息进行描述的数据结构，并在已知分区数据结构的基础上完成分区分配算法与回收方法。</p>
<p>​	空闲分区表：包括分区序号、分区始址、分区大小等</p>
<p>​	空闲分区链：空闲分区链是空闲分区最常用的组织形式，操作系统将所有的空闲分区通过前向和后向指针串在一起组成双向空闲分区链。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>覆盖与交换（动态重定位分区分配）</p>
</li>
</ol>
<h4 id="可变分区分配：基于顺序搜索"><a href="#可变分区分配：基于顺序搜索" class="headerlink" title="可变分区分配：基于顺序搜索"></a>可变分区分配：基于顺序搜索</h4><h5 id="1-首次适应法first-fit，FF"><a href="#1-首次适应法first-fit，FF" class="headerlink" title="1. 首次适应法first fit，FF"></a>1. 首次适应法first fit，FF</h5><p>首先将空闲分区按照地址递增的顺序组织成空闲分区链。为作业分配内存时，系统根据作业大小，从空闲分区链的第一个空闲分区开始查找，只要找到第一个满足作业大小的空闲分区，从该空闲分区中分割一部分分配给作业，另一部分仍作为空闲分区；如果空闲分区链全部查找完也不能满足作业要求，则系统不能为作业分配内存。</p>
<p>缺点：</p>
<ol>
<li>系统每次都是从链首开始查找空闲分区，低地址段的大空闲分区被分配或被分割，剩下了小空闲分区或空闲分“碎片”；</li>
<li>系统每次从链首开始查找空闲分区，增加查找开销。</li>
</ol>
<h5 id="2-循环首次适应算法next-fit，NF"><a href="#2-循环首次适应算法next-fit，NF" class="headerlink" title="2. 循环首次适应算法next fit，NF"></a>2. 循环首次适应算法next fit，NF</h5><p>​	将空闲分区按照地址递增的顺序组织成空闲分区链。为作业分配内存时，系统不是从空闲分区链的第一个空闲分区开始查找，而是从空闲分区链上，上次为作业分配分区后的位置开始查找，找到第一个满足作业大小的空闲分区，分割并分配该空闲分区。如果找到空闲分区链的链尾还没有找到，系统可以再从链首开始查找。</p>
<p>优点：克服了首次适应算法的缺点，使得空闲分区的分布更加均匀，查找空闲分区所需要的时间更短，</p>
<p>缺点：空闲分区链中的小分区或“碎片”问题仍然不能解决</p>
<h5 id="3-最佳适应算法best-fit，BF"><a href="#3-最佳适应算法best-fit，BF" class="headerlink" title="3. 最佳适应算法best fit，BF"></a>3. 最佳适应算法best fit，BF</h5><p>​	空闲分区链需要按照分区大小递增的顺序组织扫描整个空闲分区链，从中挑选出一个满足进程要求的最小分区进行分配，因此，被分配的空闲分区是大小最适合的分区。避免分割大空闲分区，使得内存“碎片”更小。</p>
<p>​	该算法克服了FF算法和NF算法的缺点，是一种较优的分区分配算法。该算法由于找到的空闲分区是最小能够满足要求的分区，剩余的空闲分区很小，这一部分很小的“碎片”，难以再次利用。</p>
<h5 id="4-最坏适应算法worst-fit，WF"><a href="#4-最坏适应算法worst-fit，WF" class="headerlink" title="4. 最坏适应算法worst fit，WF"></a>4. 最坏适应算法worst fit，WF</h5><p>​	空闲分区链需要按照分区大小递减的顺序组织，</p>
<p>每次从链首最大的分区开始分配，挑选满足作业要求的最大分区，使得分配的空闲分区分配给作业后剩下的部分比较大，能够再作为空闲分区进行分配。减少了内存中“碎片”的大小和个数。</p>
<p>优点：查找效率高</p>
<p>缺点：该算法存在的问题是最后会导致系统缺乏较大的空闲分区。</p>
<h4 id="可变分区分配：基于索引搜索"><a href="#可变分区分配：基于索引搜索" class="headerlink" title="可变分区分配：基于索引搜索"></a>可变分区分配：基于索引搜索</h4><h5 id="5-快速适应算法quick-fit，QF"><a href="#5-快速适应算法quick-fit，QF" class="headerlink" title="5. 快速适应算法quick fit，QF"></a>5. 快速适应算法quick fit，QF</h5><p>​	将空闲分区根据进程常用空间大小进行分类，并单独设立空闲分区链。</p>
<p>​	内存中设立一张管理索引表，每一个表项对应了空闲分区类型</p>
<p>​	空闲分区管理索引表有每个空闲分区链的长度范围和开始指针。为作业分配内存时，首先根据作业大小查找空闲分区管理索引表，得到空闲分区链的起始指针，然后再从相应的空闲分区链中为作业分配一个空闲分区</p>
<p>​	该算法的<strong>优点</strong>是能够快速得到空闲分区，查找效率高，不会分割空闲分区，并能够保留大的空闲分区，对大的作业也不会产生内存“碎片”。该算法的<strong>缺点</strong>是回收分区较困难，算法复杂，系统的开销较大。</p>
<h4 id="可变分区分配与回收"><a href="#可变分区分配与回收" class="headerlink" title="可变分区分配与回收"></a>可变分区分配与回收</h4><p>​	分区分配：分区分配操作首先根据分配算法从空闲分区表中查找所需大小的分区，如果用户进程的大小为u.size，空闲分区的大小为m.size，则m.size与u.size之差为分配后的剩余部分size，首次适应法和循环首次适应法只需要该差值大于0即可，最佳适应法需要该差值为最小，最差适应法需要该差值为最大。如果能够分配分区，则分区分配成功后会将分配区的首址返回给分配过程的调用者。</p>
<p>​	分区回收当作业完成时会释放内存，系统需要回收为作业分配的内存，回收的内存需要进入空闲分区链中才能被再次分配。根据回收区的首址，采取不同的回收方法。</p>
<ol>
<li>上邻空闲区：合并，修改大小</li>
<li>下邻空闲区：合并，修改大小、首址</li>
<li>上、下邻空闲区：合并，修改大小</li>
<li>不邻接：则建立一新表项，插入空闲链的适当位置。</li>
</ol>
<h4 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h4><p>​	紧凑&#x2F;拼接&#x2F;紧缩 compaction通过作业移动将原来分散的小分区拼接成一个大分区，拼接时要耗费较多的时间。作业的移动需重定位。只有重定位是动态的时候，才有可能进行紧缩，紧缩在执行时期进行I&#x2F;O problem1. Latch job in memory while it is involved in I&#x2F;O.（当I&#x2F;O的时候，把作业锁定在内存中。）2. Do I&#x2F;O only into OS buffers.（只在操作系统的缓冲区进行I&#x2F;O。）</p>
<h4 id="交换-对换（swapping）"><a href="#交换-对换（swapping）" class="headerlink" title="交换&#x2F;对换（swapping）"></a>交换&#x2F;对换（swapping）</h4><p>​	把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入内存。</p>
<pre><code>1. 是提高内存利用率的有效措施
</code></pre>
<p>对换类型：</p>
<ol>
<li>整体对换（中级调度）：以整个进程为单位，也称“进程对换”，解决内存紧张</li>
<li>部分对换（分页&#x2F;分段对换）：以页或段为单位，也称页面对换&#x2F;分段对换：提供虚存支持。</li>
</ol>
<p>为实现进程对换，系统须实现三方面功能：</p>
<ol>
<li><p>对换空间的管理</p>
<blockquote>
<p>外存分为：文件区和对换区    </p>
<p>文件区侧重存储空间利用率，对换区侧重于换入换出速度。</p>
<p>因此，文件区一般采用离散分配方式，对换区一般采用连续分配方式。采用数据结构和分配回收类似于动态分区分配。</p>
</blockquote>
</li>
<li><p>进程的换出</p>
<blockquote>
<p>选择被换出进程：      </p>
<p>考虑因素：进程状态，优先级，驻留时间</p>
<p>换出过程： 对于共享段：计数减1， 是0则换出，否则不换 修改PCB</p>
</blockquote>
</li>
<li><p>进程的换入</p>
<blockquote>
<p>选择换入进程：进程就绪，优先级，换出时间等。申请内存。</p>
</blockquote>
</li>
</ol>
<p>换系统中，进程的进入和退出留下一个可用内存空间的混杂区有些区域可能太小而无法利用，外部碎片</p>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>让进程比它所分配到的内存空间大，可以使用覆盖（overlay）技术。覆盖的思想是在任何时侯只在内存中保留所需的指令和数据。当需要其他指令时，将其装入到不再需要的指令所占用的内存空间。</p>
<h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><p>​	将物理内存分配成固定大小的块 (或页框)固定单元易于分配任何空闲物理页可以存储任何逻辑页</p>
<p>​	将逻辑地址空间分成相同大小的页（或页面）每个逻辑页可以存在物理内存中或者倒出到磁盘上</p>
<p>​	进程通过逻辑地址访问内存每个逻辑地址引用被MMU翻译成物理内存地址</p>
<p>​	页面大小页太大：页内碎片大页太小：进程页表很长，占用大量内存；换入&#x2F;换出效率低页面大小应适中，是2的幂，一般1kB~8kB</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><ul>
<li>页表是分页系统中的关键组件</li>
<li>用于实现逻辑页面到物理页面的地址映射（MMU 用页表执行地址翻译）</li>
</ul>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><ul>
<li><p>实现从逻辑地址到物理地址的转换</p>
</li>
<li><p>系统设置一个页表寄存器(page-table register, PTR)，存放页表在内存的首址和页表长度。</p>
</li>
</ul>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><ul>
<li><p>具有并行查寻能力的特殊高速缓冲寄存器</p>
</li>
<li><p>加快了内存访问速度，缓存了从虚拟页面到物理页面的映射</p>
</li>
</ul>
<p>使用过程</p>
<blockquote>
<ol>
<li>在使用快表的情况下，当处理器给出进程的逻辑地址后，从逻辑地址中得到页号，地址变换机构查询快表，如果该页已在快表中，从快表得到物理块号；</li>
<li>如果该页不在快表中，再查询内存中的页表，得到物理块号，同时将该页信息写入快表以便以后使用；</li>
<li>如果此时快表已满，处理器需要将快表中不需要的表项换到内存页表中再写入快表。</li>
</ol>
</blockquote>
<h3 id="分页存储管理的优缺点"><a href="#分页存储管理的优缺点" class="headerlink" title="分页存储管理的优缺点"></a>分页存储管理的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>简单的内存分配 </li>
<li>可以共享许多小片地址空间</li>
<li>容易增长地址空间</li>
<li>没有外碎片，每个内碎片不超过页的大小。</li>
<li>一个程序不必连续存放。</li>
<li>便于改变程序占用空间的大小(主要指随着程序运行而动态生成的数据增多，要求地址空间相应增长，通常由系统调用完成而不是操作系统自动完成)。</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>页表的尺寸可能很大</p>
<ol>
<li>程序要全部装入内存。</li>
<li>采用动态地址变换机构会增加计算机的成本和降低处理机的速度。</li>
<li>各种表格要占用一定的内存空间，而且要花费一定的时间来建立和管理这些表格。 </li>
<li>存储扩充问题没有得到解决。  </li>
<li>不便于动态连接。 </li>
<li>不易实现共享（相对于段式存储管理）。</li>
</ol>
<h3 id="两级或多级页表"><a href="#两级或多级页表" class="headerlink" title="两级或多级页表"></a>两级或多级页表</h3><ul>
<li>把页表分成2个或更多个级<ul>
<li>一级页表总是驻留在内存</li>
<li>二级页表在需要的时候放入内存</li>
</ul>
</li>
</ul>
<p>一级页表存放二级页表的信息，二级页表存放三级页表的信息 最后一级页表存放的才是逻辑页面到物理页面的映射</p>
<h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><p>​	为了能够快速查找页表页面在内存中的物理块号，这些页表页面设计有一个地址索引表，即页目录表（外部页表）页目录表的表项为每个页表页面所在的内存物理块号和相关信息      这样，系统将页表分为了两级：一级为页目录表，二级为页表页面。页表页面中的每项是每个页面所在的页号和物理块号</p>
<p>两级页表的逻辑地址被划分为三部分：	</p>
<ol>
<li>页目录<ol>
<li>由页目录表（一级页表）在内存中的起始地址加上页目录号（即需要查找的页表某页在页目录中的编号）,得到页表某页的物理块号；</li>
</ol>
</li>
<li>页表页<ol>
<li>通过页表某页的物理块号得到页表页（二级页表中的一页），由页表页号（某页在页表页中的编号）查询该页表页项（二级页表中的一页），得到对应的物理块号；</li>
</ol>
</li>
<li>页表页内<ol>
<li>将该物理块号加上页表页内号（页内偏移）则为所需要的物理地址。</li>
</ol>
</li>
</ol>
<h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><p>分段管理把一个程序按照逻辑单元分成多个程序段（逻辑分段）连续的逻辑内存空间区域，每个段定义一组逻辑信息</p>
<p>每一个段使用自己单独的虚地址空间独立的逻辑单位, 比如数据, 代码, 栈等</p>
<p>纯粹分段中整个程序占有一个虚拟地址空间</p>
<blockquote>
<p>好处：方便编程；信息共享；信息保护；动态链接；动态增长（如数据段的增长）。</p>
</blockquote>
<h2 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h2><p>将外存作为内存的补充，从逻辑上扩充内存</p>
<p>概念：在具有层次结构存储器的计算机系统中，采用自动实现部分装入和部分对换功能，为用户提供一个比物理内存容量大得多的，可寻址的一种“内存储器”。</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol>
<li>程序中只有少量分支和过程调用，大部分是顺序执行的，即要执行的下一条指令紧跟在当前执行指令之后。 </li>
<li>程序往往包含若干个循环，这些是由相对较少的几个指令重复若干次组成的，在循环过程中，计算被限制在程序中一个很小的相邻部分中（如计数循环）。</li>
<li>很少会出现连续不断的过程调用序列，相反，程序中过程调用被限制在一个小的范围内，因而，一段时间内，指令引用被局限在很少几个过程中。</li>
<li>对于连续访问数组之类的数据结构，往往是对存储区域中的数据或相邻位置的数据（如动态数组）的操作。 </li>
<li>程序中有些部分是彼此互斥的，不是每次运行时都用到的，例如，出错处理程序，仅当在数据和计算中出现错误时才会用到，正常情况下，出错处理程序不放在内存，不会影响整个程序的运行。</li>
</ol>
<h3 id="虚拟存储器特征"><a href="#虚拟存储器特征" class="headerlink" title="虚拟存储器特征"></a>虚拟存储器特征</h3><ul>
<li>多次性<ul>
<li>最重要的特征   虚拟存储器在实现上需要将一个作业分多次调入内存运行。</li>
</ul>
</li>
<li>对换性   <ul>
<li>虚拟存储器允许作业在运行过程中将暂时不运行的部分换出，在需要时再换入，对换性使得作业运行所需内存更少，系统的多道度提高。</li>
</ul>
</li>
<li>虚拟性  <ul>
<li>虚拟存储器从逻辑上扩充内存容量，使得用户能够使用的内存容量远远大于实际内存容量，提高了系统运行程序的能力。</li>
</ul>
</li>
</ul>
<h3 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h3><p>计算机系统的可寻址范围为虚拟存储器的最大范围</p>
<h2 id="虚拟存储管理方式"><a href="#虚拟存储管理方式" class="headerlink" title="虚拟存储管理方式"></a>虚拟存储管理方式</h2><h3 id="请求分页方式"><a href="#请求分页方式" class="headerlink" title="请求分页方式"></a>请求分页方式</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>作业的程序和数据可以按页分散存放在内存中，减少了移动的开销，有效地解决了碎片问题；</li>
<li>由于采用请求分页虚存管理，用户可用的内存空间大大扩展，既有利于改进内存利用率，又有利于多道程序运行。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>要有一定硬件支持，要进行缺页中断处理，成本增加，系统开销加大;</li>
<li>页内会出现碎片，如果页面较大，则内存的损失仍然较大。</li>
</ol>
<p>以页为单位置换</p>
<p>需求：</p>
<ol>
<li><p>硬件支持</p>
<ol>
<li>请求分页的页表机构（页表中增加用于请求分页的控制位）</li>
<li>缺页中断机构（待访问页面不在内存中，产生缺页中断）</li>
<li>地址变换机构（查询&#x2F;修改快表、页表，修改控制位，缺页中断处理）</li>
</ol>
</li>
<li><p>软件支持</p>
<ol>
<li>用于实现请求调页的软件</li>
<li>实现页面置换的软件</li>
</ol>
</li>
</ol>
<p>内存管理单元MMU（Memory Management Unit）</p>
<p>请求分页虚拟存储系统是将作业信息的副本存放在磁盘中，当作业被调度投入运行时，并不把作业的程序和数据全部装入内存，而仅仅装入即将使用的那些页面，在执行过程中访问到不在内存的页面时，再把它们动态地装入。</p>
<h4 id="页面置换算法存储管理"><a href="#页面置换算法存储管理" class="headerlink" title="页面置换算法存储管理"></a>页面置换算法存储管理</h4><ol>
<li><p>最佳置换算法</p>
<blockquote>
<p>最佳置换算法（Belady算法）选择一个不再访问或最长时间不会被访问的页面进行替换</p>
</blockquote>
</li>
<li><p>LRU (least recently used) 置换算法</p>
<blockquote>
<p>替换一个最近最久未被访问的旧页面</p>
</blockquote>
</li>
<li><p>FIFO (first in first out) 先进先出页面置换算法</p>
<blockquote>
<p>更换最早进入内存的页面（替换当前内存中存在时间最久的页面）</p>
</blockquote>
</li>
<li><p>第二次机会页面置换算法</p>
</li>
<li><p>时钟置换（clock）</p>
</li>
</ol>
<h3 id="请求分段存储管理"><a href="#请求分段存储管理" class="headerlink" title="请求分段存储管理"></a>请求分段存储管理</h3><h3 id="段页式虚拟存储管理"><a href="#段页式虚拟存储管理" class="headerlink" title="段页式虚拟存储管理"></a>段页式虚拟存储管理</h3><h1 id="6-设备管理"><a href="#6-设备管理" class="headerlink" title="6. *设备管理"></a>6. *设备管理</h1><h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><p>操作系统中负责管理输入输出设备的部分称为I&#x2F;O系统</p>
<p>I&#x2F;O系统管理的主要对象是：</p>
<ol>
<li>I&#x2F;O设备</li>
<li>相应的设备控制器</li>
<li>I&#x2F;O操作有关的软硬件</li>
</ol>
<p>目的：</p>
<ol>
<li>完成用户提出的I&#x2F;O请求</li>
<li>提高I&#x2F;O速率</li>
<li>提高设备的利用率</li>
<li>为更高层的进程方便地使用这些设备提供手段。</li>
</ol>
<h3 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I&#x2F;O 设备"></a>I&#x2F;O 设备</h3><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ol>
<li>按设备使用特性分类：<ol>
<li>存储设备，外存或辅助存储器</li>
<li>输入输出设备，包括输入设备、输出设备、交互式设备</li>
</ol>
</li>
<li>按信息交换单位分类:<ol>
<li>块设备，以数据块为单位存储和传输数据，数据块可寻址，	如磁盘（DMA方式）</li>
<li>字符设备，以字符为单位存放和传输数据，字符是不可寻址的，如交互式终端，打印机等（中断驱动方式）</li>
</ol>
</li>
<li>按设备的共享属性分类<ol>
<li>独占设备，即临界资源</li>
<li>共享设备，可寻址和可随机访问的设备，如磁盘</li>
<li>虚拟设备，通过虚拟技术把一台独占设备变换为若干台逻辑设备（spooling技术）</li>
</ol>
</li>
<li>按从属关系分类<ol>
<li>系统设备：计算机系统标准设备</li>
<li>用户设备：用户自行安装配置后由OS统一管理的设备</li>
</ol>
</li>
<li>按传输速率分类：<ol>
<li>低速设备：如键盘、鼠标中速设备：如打印机</li>
<li>高速设备：如磁带、磁盘、光盘</li>
</ol>
</li>
</ol>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>设备控制器是计算机中的一个实体（IO设备的电子部分）</p>
<ol>
<li>控制一个或多个I&#x2F;O设备</li>
<li>实现设备和计算机之间的数据交换</li>
<li>也称为适配器（adapter），是CPU和I&#x2F;O设备之间的接口</li>
<li>通常是一块印刷电路板，也叫接口卡</li>
</ol>
<h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ol>
<li>接收和识别处理器命令      设备控制器具有控制（命令）寄存器和命令译码器，将处理器的命令接收到控制寄存器中并对命令进行译码。</li>
<li>数据交换      具备数据寄存器。实现处理器与设备控制器之间（数据总线）、设备控制器与设备之间的数据交换。</li>
<li>了解和报告设备的状态      设备控制器中的状态寄存器能够存储接收到的设备状态信息，并将信息上传给处理器。</li>
<li>识别设备地址      配置地址译码器。系统中的每一个设备都有一个地址,设备控制器能够识别所控制设备的地址。</li>
<li>数据缓冲      设备控制器中设置缓冲以解决I&#x2F;O设备与CPU速度不匹配的问题。</li>
<li>差错控制      设备控制器兼管从设备传送来的数据差错检查，保证数据的正确性。</li>
</ol>
<h3 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I&#x2F;O通道"></a>I&#x2F;O通道</h3><h4 id="通道概念"><a href="#通道概念" class="headerlink" title="通道概念"></a>通道概念</h4><p>​	通道是一种特殊的执行I&#x2F;O指令的处理机，用于代替处理器实现外部设备的输入&#x2F;输出操作和管理，实现外部设备与处理器的并行操作。</p>
<p>引入目的：解脱CPU对I&#x2F;O的组织和管理，建立独立的I&#x2F;O操作。</p>
<p>采用通道后计算机系统可以实现三级并行：</p>
<ol>
<li>通道与处理器并行执行，</li>
<li>通道与通道之间并行操作，</li>
<li>不同通道上的外围设备并行操作。</li>
</ol>
<p>因此，通道使得系统的并行工作能力大大提高。</p>
<h4 id="通道类型"><a href="#通道类型" class="headerlink" title="通道类型"></a>通道类型</h4><p>按照信息交换方式和设备连接方式的不同，通道分为</p>
<ol>
<li><p>字节多路通道</p>
<blockquote>
<p>连接设备控制器的每个子通道，以字节为单位，分时共享方式传输数据，主要连接大量<strong>低速</strong>外围设备，如终端、打印机。</p>
</blockquote>
</li>
<li><p>数组选择通道</p>
<blockquote>
<p>选择通道每个子通道以一组数据为单位，对一个子通道而言，传送效率更高。</p>
<p>数组选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输。当一台设备数据传输完成后，再选择另一个子通道的设备进行数据传输。</p>
<p>主要用于连接磁盘等高速输入&#x2F;输出设备。</p>
</blockquote>
</li>
<li><p>数组多路通道</p>
<blockquote>
<p>结合了数组选择通道传送速度高和字节多路通道能进行分时并发传送多个设备数据的优点</p>
<p>数组多路通道主要用于连接高、中速设备。</p>
</blockquote>
</li>
</ol>
<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><ol>
<li><p>可编程 I&#x2F;O 是最简单的</p>
<blockquote>
<p>CPU 等待 I&#x2F;O 完成</p>
<p>这种模式称为轮询或者繁忙等待 </p>
<p>性能低，编程简单</p>
</blockquote>
</li>
<li><p>中断驱动 I&#x2F;O 是最常用的</p>
<blockquote>
<p>CPU 初始化 I&#x2F;O并启动第一次I&#x2F;O操作</p>
<p>CPU 去忙别的事情</p>
<p>I&#x2F;O完成时, CPU 将被中断</p>
<p>CPU 处理中断</p>
<p>CPU 恢复被中断的程序</p>
</blockquote>
</li>
<li><p>直接内存访问I&#x2F;O 用于改进效率</p>
<blockquote>
<p>数据传输的基本单位是块</p>
<p>用 DMA 控制器处理 I&#x2F;O 中断</p>
<p>降低CPU响应中断的频率</p>
<p><strong>DMA控制器组成</strong></p>
<ol>
<li>主机与DMA控制器接口</li>
<li>DMA控制器与块设备接口</li>
<li>I&#x2F;O控制逻辑</li>
</ol>
</blockquote>
</li>
<li><p>I&#x2F;O通道控制方式</p>
<blockquote>
<p>把对一个数据块为单位的读写干预减少为对一组数据块的读写及有关的控制和管理为单位的干预</p>
<p>I&#x2F;O通道控制方式，CPU只需给出：</p>
<ol>
<li>通道程序首址</li>
<li>要访问I&#x2F;O设备后，通道程序就可完成一组块操作</li>
<li>通道是通过执行通道程序并与设备控制器共同实现对I&#x2F;O设备的控制的</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="DIsk"><a href="#DIsk" class="headerlink" title="DIsk"></a>DIsk</h2><h1 id="7-文件系统管理"><a href="#7-文件系统管理" class="headerlink" title="7. *文件系统管理"></a>7. *文件系统管理</h1><h1 id="8-操作系统安全"><a href="#8-操作系统安全" class="headerlink" title="8. 操作系统安全"></a>8. 操作系统安全</h1>]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>PCB Technique</title>
    <url>/2024/03/03/PCB-Technique/</url>
    <content><![CDATA[<h1 id="PCB-Technique"><a href="#PCB-Technique" class="headerlink" title="PCB Technique"></a>PCB Technique</h1><p>​	本篇课程基于B站UP主<code>Expert电子实验室</code>的教学视频，同时加上本人思考与总结汇总而成。</p>
<p>​	<a href="https://www.bilibili.com/video/BV1At421h7Ui/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=c33a47a3f08b3b6b6c1614d37f34903f">零基础入门PCB设计保姆级教学</a></p>
<p>​	<a href="https://space.bilibili.com/346179450">Expert电子实验室</a></p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1800822510&bvid=BV1At421h7Ui&cid=1445021959&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<p>​	本部分笔记为扫盲篇（基础篇）</p>
<h6 id="进阶需实战，纸上得来终觉浅，绝知此事要躬行。"><a href="#进阶需实战，纸上得来终觉浅，绝知此事要躬行。" class="headerlink" title="&#x3D;&#x3D;进阶需实战，纸上得来终觉浅，绝知此事要躬行。&#x3D;&#x3D;"></a>&#x3D;&#x3D;进阶需实战，纸上得来终觉浅，绝知此事要躬行。&#x3D;&#x3D;</h6><p>​	</p>
<h2 id="1-电路设计"><a href="#1-电路设计" class="headerlink" title="1. 电路设计"></a>1. 电路设计</h2><h2 id="1-1-原理图四要素"><a href="#1-1-原理图四要素" class="headerlink" title="1.1 原理图四要素"></a>1.1 原理图四要素</h2><ol>
<li>元件符号</li>
<li>连接线</li>
<li>结点</li>
<li>注释</li>
</ol>
<h2 id="1-2-基本原件介绍"><a href="#1-2-基本原件介绍" class="headerlink" title="1.2 基本原件介绍"></a>1.2 基本原件介绍</h2><h3 id="1-2-1-电阻"><a href="#1-2-1-电阻" class="headerlink" title="1.2.1 电阻"></a>1.2.1 电阻</h3><ul>
<li>对于贴片电阻的读数</li>
</ul>
<blockquote>
<p>1）3位读数：前2位为有效数字，第3位表示10的n次幂(也可以理解为0的个数)。精度为±5%</p>
<p>2）4位读数：前3位为有效数字，第4位表示10的n次幂(也可以理解为0的个数)。读法和3位的原理一样，精度为±1%</p>
<p>3）阻值小于10的读数：通常在两个数之间插入一个字母R，用字母R来代替小数点</p>
</blockquote>
<h3 id="1-2-2-电容"><a href="#1-2-2-电容" class="headerlink" title="1.2.2 电容"></a>1.2.2 电容</h3><ul>
<li><p>主要功能：<strong>储能和滤波</strong></p>
</li>
<li><p>单位计算</p>
</li>
</ul>
<p><code>1uF=1000nF；1nF=1000pF</code></p>
<ul>
<li>分类</li>
</ul>
<p><img src="/images/PCB/capacityType.png" alt="Type"></p>
<ul>
<li>读数以及含义</li>
</ul>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%872.png" alt="Type—1"></p>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%873.png" alt="Type—2"></p>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%874.png" alt="Type—3"></p>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%875.png" alt="Type—4"></p>
<h3 id="1-2-3-电感"><a href="#1-2-3-电感" class="headerlink" title="1.2.3 电感"></a>1.2.3 电感</h3><p>​	Inductor，</p>
<ul>
<li>单位换算</li>
</ul>
<p><code>1H=1000mH；1mH=1000uH；</code></p>
<ul>
<li>主要功能：滤波，扼流，谐振，储能</li>
<li>分类</li>
</ul>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%876.png" alt="Inductors"></p>
<ul>
<li>读数以及含义</li>
</ul>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%877.png" alt="Type—1"></p>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%878.png" alt="Type—2"></p>
<h3 id="1-2-4-二极管"><a href="#1-2-4-二极管" class="headerlink" title="1.2.4 二极管"></a>1.2.4 二极管</h3><ul>
<li>主要功能</li>
</ul>
<p>​	实现对交流电整流、对调制信号检波、限幅和钳位以及对电源电压的稳压等多种功能 。</p>
<ul>
<li>分类以及简单介绍</li>
</ul>
<p><img src="/images/PCB/%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%88%86%E7%B1%BB.png" alt="二极管种类以及介绍"></p>
<ul>
<li>外观（判断正负极）</li>
</ul>
<ol>
<li>对于直插式发光二极管：长脚为正极，内部小块为正极。</li>
<li>一般封装类型的正负极判断</li>
</ol>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%879.png" alt="二极管一般封装类型的正负极判断"></p>
<h3 id="1-2-5-三极管"><a href="#1-2-5-三极管" class="headerlink" title="1.2.5 三极管"></a>1.2.5 三极管</h3><ul>
<li><p>分类：NPN（控地） 和 PNP（控电源）</p>
</li>
<li><p>工作状态</p>
</li>
</ul>
<ol>
<li>截止状态</li>
</ol>
<p>​	发射结反偏，集电结反偏。即：I ce&#x3D;0</p>
<ol start="2">
<li>放大状态</li>
</ol>
<p>​	发射结正偏，集电结反偏。</p>
<ol start="3">
<li><p>饱和状态</p>
<p> 发射结正偏，集电结正偏</p>
</li>
</ol>
<ul>
<li>常见封装</li>
</ul>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%8710.png" alt="三极管一般封装类型"></p>
<h3 id="1-2-6-场效应管（尚未掌握）"><a href="#1-2-6-场效应管（尚未掌握）" class="headerlink" title="1.2.6 场效应管（尚未掌握）"></a>1.2.6 场效应管（尚未掌握）</h3><ul>
<li>基本介绍</li>
</ul>
<p>​	场效应晶体管（Field Effect Transistor缩写(FET)）简称场效应管。它是利用控制输入回路的电场效应来控制输出回路电流的一种半导体器件。</p>
<ul>
<li>特点</li>
</ul>
<p>​	具有输入电阻高、噪声小、功耗低、动态范围大、易于集成、没有二次击穿现象、安全工作区域宽等优点。</p>
<ul>
<li>类型</li>
</ul>
<ol>
<li><p>结型场效应管（junction FET—JFET) </p>
</li>
<li><p>金属 - 氧化物半导体场效应管（metal-oxide semiconductor FET，简称MOS-FET）</p>
</li>
</ol>
<ul>
<li>与三极管的对比</li>
</ul>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%8711.png" alt="compare"></p>
<ul>
<li>封装</li>
</ul>
<p><img src="/images/PCB/MOS.png" alt="MOS"></p>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%8712.png" alt="MOS"></p>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%8713.png" alt="MOS"></p>
<h3 id="1-2-7-芯片-IC"><a href="#1-2-7-芯片-IC" class="headerlink" title="1.2.7 芯片 &#x2F; IC"></a>1.2.7 芯片 &#x2F; IC</h3><p><strong>&#x3D;&#x3D;具体见数据手册&#x3D;&#x3D;</strong></p>
<h2 id="1-3-数据手册"><a href="#1-3-数据手册" class="headerlink" title="1.3 数据手册"></a>1.3 数据手册</h2><p>自己找去</p>
<h2 id="1-4-电路原理图设计"><a href="#1-4-电路原理图设计" class="headerlink" title="1.4 电路原理图设计"></a>1.4 电路原理图设计</h2><h3 id="网络标签"><a href="#网络标签" class="headerlink" title="网络标签"></a>网络标签</h3><p>​	网络标签 (Net Label)：网络标号表示一个电器连接点，具有相同网络标号的器件表明是电气连接在一起。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote>
<ol>
<li><p>分模块、分图页</p>
</li>
<li><p>标注重要参数</p>
</li>
<li><p>标注元件特殊&#x2F;重要功能</p>
</li>
<li><p>标注注意事项</p>
</li>
<li><p>合理的网络标签</p>
</li>
<li><p>标注LOGO&#x2F;版本号</p>
</li>
</ol>
</blockquote>
<p>&#x3D;&#x3D;<strong>成功的原理图设计&#x3D;合理的元件选型+正确的电路设计</strong>&#x3D;&#x3D;</p>
<h2 id="2-PCB设计"><a href="#2-PCB设计" class="headerlink" title="2. PCB设计"></a>2. PCB设计</h2><ul>
<li>PCB基本介绍</li>
</ul>
<blockquote>
<p>​	PCB板就是印制电路板，又称印刷电路板，是电子元器件电气连接的提供者。PCB根据其基板材料的不同而不同，高频微波板、金属基板，铝基板、铁基板、铜基板、双面板及多层板PCB是英文Printed Circuit Board的缩写，中文名称为印制电路板，又称印刷电路板、印刷线路板，是重要的电子部件。</p>
</blockquote>
<h3 id="2-1PCB-组成"><a href="#2-1PCB-组成" class="headerlink" title="2.1PCB 组成"></a>2.1PCB 组成</h3><h4 id="2-1-1铺铜"><a href="#2-1-1铺铜" class="headerlink" title="2.1.1铺铜"></a>2.1.1铺铜</h4><ul>
<li>作用</li>
</ul>
<p>​	将PCB上闲置的空间作为基准面，然后用固体铜填充，这些铜区又称为灌铜。覆铜的意义在于，减小地线阻抗，提高抗干扰能力；降低压降，提高电源效率；与地线相连，还可以减小环路面积。</p>
<ul>
<li>方式</li>
</ul>
<ol>
<li>大面积覆铜</li>
</ol>
<p>​	大面积覆铜，具备了加大电流和屏蔽双重作用，但是大面积覆铜，如果过波峰焊时，板子就可能会翘起来，甚至会起泡。因此大面积覆铜，一般也会开几个槽，缓解铜箔起泡。低频电路、有大电流的电路等常用大面积的覆铜。</p>
<ol>
<li>网格覆铜</li>
</ol>
<p>从散热的角度说，它降低了铜的受热面，又起到了一定的电磁屏蔽的作用。因此，高频电路对抗干扰要求高的多用网格覆铜</p>
<h4 id="2-1-2过孔"><a href="#2-1-2过孔" class="headerlink" title="2.1.2过孔"></a>2.1.2过孔</h4><ul>
<li>功能</li>
</ul>
<ol>
<li>电气连接：过孔用于将不同层面的电路连接起来，使得电路板能够在不同的层次上进行有效的信号和电源传输。</li>
<li>器件固定或定位：过孔还可以用作固定电子部件的位置，如电阻、电容等，确保其在电路板上的正确布局。</li>
</ol>
<ul>
<li>分类</li>
</ul>
<ol>
<li>通孔：从PCB的上层钻到底层的机械钻孔。</li>
<li>盲孔：从 PCB 的上层或底层到内层钻孔和电镀的孔。</li>
<li>埋孔：指位于印刷线路板内层的连接孔，它不会延伸到线路板的表面。</li>
</ol>
<h4 id="2-1-3焊盘"><a href="#2-1-3焊盘" class="headerlink" title="2.1.3焊盘"></a>2.1.3焊盘</h4><ul>
<li>定义：</li>
</ul>
<p>​	元件通过PCB上的引线孔，用焊锡焊接固定在PCB上，印制导线把焊盘连接起来，实现元件在电路中的电气连接。引线孔及周围的铜箔称为焊盘。</p>
<h4 id="2-1-4丝印"><a href="#2-1-4丝印" class="headerlink" title="2.1.4丝印"></a>2.1.4丝印</h4><p>​	PCB丝印是指在电子线路板（Printed Circuit Board）上印刷的信息，如文字、标志、图形等。这些丝印具有重要的功能，它们可以帮助标识电子元件的位置、数值、型号等信息，以及元件的方向和正确的安装方式。</p>
<h4 id="2-1-5阻焊"><a href="#2-1-5阻焊" class="headerlink" title="2.1.5阻焊"></a>2.1.5阻焊</h4><p>​	在铜层上面覆盖油墨层，油墨层覆盖住铜层上面不需要焊接的线路，防止PCB上的线路和其他的金属、焊锡或者其它的导电物体接触导致短路，起到绝缘及保护铜层作用，选择性露出焊接需要的铜PAD、IC等。</p>
<h3 id="2-2PCB结构"><a href="#2-2PCB结构" class="headerlink" title="2.2PCB结构"></a>2.2PCB结构</h3><ul>
<li>叠层结构</li>
</ul>
<p>​	PCB材料的组成主要有PP半固态片和Core芯板两部分组成，这就构成了所看到的绿色、红色或者黑色等的板子，再加上敷铜线路层，器件，就构成了电路板。</p>
<ul>
<li>&#x3D;&#x3D;叠层结构布局有讲究&#x3D;&#x3D;，但是一般的二层板双面都可能需要走底地线和电源。</li>
<li>图示</li>
</ul>
<p><img src="/images/PCB/%E5%9B%BE%E7%89%8714.png" alt="PCB叠层结构"></p>
<h3 id="2-3-PCB设计流程"><a href="#2-3-PCB设计流程" class="headerlink" title="2.3  PCB设计流程"></a>2.3  PCB设计流程</h3><p><img src="/images/PCB/%E5%9B%BE%E7%89%8715.png" alt="设计流程"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-end-1PCB设计规则总览（持续添加ing）"><a href="#2-end-1PCB设计规则总览（持续添加ing）" class="headerlink" title="2.end.1PCB设计规则总览（持续添加ing）"></a>2.end.1PCB设计规则总览（持续添加ing）</h3><ol>
<li><p><strong>电路布局与元器件安放</strong>：</p>
<ul>
<li><p>电路布局是否合理？</p>
</li>
<li><p>元器件之间的距离是否足够？</p>
</li>
<li><p>元器件的放置方向是否一致？</p>
</li>
<li><p>是否合理安排了元器件的布局顺序？</p>
</li>
<li><p>是否考虑了元器件的封装形式和选择？</p>
</li>
<li><p>是否进行了元器件的标注和排列规范？</p>
</li>
<li><p>是否考虑了元器件的插拔次数和位置？</p>
</li>
<li><p>是否进行了元器件的冗余设计？</p>
</li>
<li><p>是否考虑了元器件的热管理和散热问题？</p>
</li>
<li><p>是否进行了元器件的可靠性分析？</p>
</li>
</ul>
</li>
<li><p><strong>信号管理：</strong></p>
<ol>
<li><blockquote>
<p><strong>线宽与过孔</strong></p>
<p>1）8&#x2F;8mil，过孔选择12mil（0.3mm）。<br>2）6&#x2F;6mil，过孔选择12mil（0.3mm）。<br>3）4&#x2F;4mil，过孔选择8mil（0.2mm）。<br>4）3.5&#x2F;3.5mil，过孔选择8mil（0.2mm）。<br>5）3.5&#x2F;3.5mil，过孔选择4mil（0.1mm，激光打孔）。<br>6）2&#x2F;2mil，过孔选择4mil（0.1mm，激光打孔）。<br>参考过孔：内径12mil、外径20mil<br>参考内径20mil、外径30mil</p>
</blockquote>
</li>
<li><p>是否进行了信号完整性分析？</p>
</li>
<li><p>是否进行了阻抗匹配设计？</p>
</li>
<li><p>是否进行了信号线路的优化布局和仿真验证？</p>
</li>
<li><p>是否考虑了电磁干扰和射频干扰的影响？</p>
</li>
<li><p>是否进行了电磁场模拟分析？</p>
</li>
<li><p>是否考虑了信号传输速率和衰减问题？</p>
</li>
<li><p>是否考虑了线路的阻抗匹配和信号损耗？</p>
</li>
<li><p>是否进行了线路的阻抗匹配设计？</p>
</li>
</ol>
</li>
<li><p><strong>电源管理：</strong></p>
<ol>
<li><p>电流与布线宽度</p>
<blockquote>
<p>电源线、地线的宽度最好尽可能宽，地线比电源线宽。这些关系为：地线&gt;电源线&gt;信号线，通常信号线的宽度为0.2-0.3mm(8-12mil)，最细的宽度为0.05-0.07mm(2-2.8mil)，电源线为1.2-2.5mm(48-100mil)。(0.025mm&#x3D;1mil).</p>
<p><a href="https://eda365.com/article-12-1.html">PCB走线载流计算器-EDA365电子论坛通信数码-人工智能-计算机-半导体-手机家电消费电子硬件门户网站</a></p>
<p><img src="/../images/pcb/1.png"></p>
</blockquote>
</li>
<li><p>是否考虑了电源的滤波和稳压？</p>
</li>
<li><p>是否进行了电源线和地线的分离和规范设计？</p>
</li>
<li><p>是否考虑了过压和过流保护的设计？</p>
</li>
<li><p>是否进行了电源供应的充足性和稳定性分析？</p>
</li>
</ol>
</li>
<li><p><strong>PCB工艺与环境因素：</strong></p>
<ul>
<li><p>是否考虑了PCB的工作环境和应用场景</p>
</li>
<li><p>是否进行了PCB的加工工艺和成本分析？</p>
</li>
<li><p>是否进行了PCB布线的仿真验证？</p>
</li>
<li><p>是否考虑了PCB的防火、加固、环境友好等设计因素？</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>电路设计</tag>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry Pi</title>
    <url>/2024/03/16/Raspberry-Pi/</url>
    <content><![CDATA[<h1 id="嘿嘿开新坑！（目前基于python）"><a href="#嘿嘿开新坑！（目前基于python）" class="headerlink" title="嘿嘿开新坑！（目前基于python）"></a>嘿嘿开新坑！（目前基于python）</h1><p>​	早就久仰树莓派大名，奈何前两年芯片减产导致树莓派价格居高不下，甚至翻倍。现在终于降下来了，于是斥巨资买了一块3B前来学习。本篇Blog用于记录我的探索历程。</p>
<p>​	目前打算先使用python进行学习，待到有一定理解之后再使用C。</p>
<h2 id="1-装系统！"><a href="#1-装系统！" class="headerlink" title="1. 装系统！"></a>1. 装系统！</h2><p>​	要什么桌面环境，直接上命令行！</p>
<h2 id="2-联网-WIFI"><a href="#2-联网-WIFI" class="headerlink" title="2.联网-WIFI"></a>2.联网-WIFI</h2><ul>
<li>方法一：使用系统工具</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>

<p>选择系统选项，地区之后就可以通过<code>ssid</code>和<code>pask</code>进行联网</p>
<p>再使用<code>ifconfig</code>查看是否连接成功（会分配新的 ip 地址）</p>
<ul>
<li>方法二：使用系统配置<code>/etc/</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一开始没有VIM</span></span><br><span class="line">sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># add </span></span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=<span class="string">&quot;ssid_name&quot;</span></span><br><span class="line">        key_mgmt=WPA-PSK</span><br><span class="line">        psk=<span class="string">&quot;password&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-创建新用户并授权"><a href="#3-创建新用户并授权" class="headerlink" title="3. 创建新用户并授权"></a>3. 创建新用户并授权</h2><p>​	总不能一直用root吧，qwq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add user</span></span><br><span class="line">adduser regen</span><br><span class="line"><span class="comment"># grant privilege</span></span><br><span class="line">visudo</span><br><span class="line"><span class="comment"># add regen to sudoers</span></span><br><span class="line">regen   ALL=(ALL:ALL)       ALL</span><br></pre></td></tr></table></figure>

<h2 id="4-来点个灯吧！"><a href="#4-来点个灯吧！" class="headerlink" title="4.来点个灯吧！"></a>4.来点个灯吧！</h2><ol>
<li>代码界的点灯</li>
</ol>
<p>先看看这个gcc工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p>嘿嘿，是<code>aarch-linux-gnu</code>也就是arm架构的gcc版本啦，终于不是<code> x86_64-w64-mingw32</code>啦。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim hello_RaspberryPi.c</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>物理点灯</li>
</ol>
<h3 id="4-1-引脚信息"><a href="#4-1-引脚信息" class="headerlink" title="4.1 引脚信息"></a>4.1 引脚信息</h3><ul>
<li>看看引脚配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pinout</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpio readall</span><br></pre></td></tr></table></figure>

<p>然后就报错了。。。</p>
<p>没有安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install wiringpi</span><br></pre></td></tr></table></figure>

<p>又报错了。。。没有依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt --fix-broken install</span><br></pre></td></tr></table></figure>

<p>解决</p>
<h3 id="4-2-代码控制"><a href="#4-2-代码控制" class="headerlink" title="4.2  代码控制"></a>4.2  代码控制</h3><h4 id="4-2-1-使用Python的命令模式"><a href="#4-2-1-使用Python的命令模式" class="headerlink" title="4.2.1 使用Python的命令模式"></a>4.2.1 使用Python的命令模式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> GPIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>GPIO.setmode(GPIO.BOARD)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>GPIO.setup(<span class="number">11</span>,GPIO.OUT)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>GPIO.output(<span class="number">11</span>,<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>于是报错了，没有权限，直接换root就好了。好了现在又精通一个开发板的点灯了嘿嘿</p>
<h2 id="5-远程ssh"><a href="#5-远程ssh" class="headerlink" title="5. 远程ssh"></a>5. 远程ssh</h2><p>​	学以致用，之前在<code> Linux Projects</code>里面学习了使用<code>ZeroTier</code>进行内网穿透以提供远程服务。试试在我的内网频道加入新的成员<code>Raspberry PI</code>吧 ！</p>
<ul>
<li>开头也需要加<code>sudo</code>，否则报错</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -s https://install.zerotier.com | sudo bash</span><br></pre></td></tr></table></figure>

<ul>
<li>加入我的内网</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-cli <span class="built_in">join</span> &lt;NETWORK ID&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>开机自启动</li>
</ul>
<ol>
<li>新建一个脚本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim AutoStart/ZeroTierAutoStart.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">sudo zerotier-cli <span class="built_in">join</span> &lt;network ID&gt;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;zerotier network joined successfully&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加自启动</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/rc.local</span><br></pre></td></tr></table></figure>

<p>添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su regen -c <span class="string">&quot;exec /home/regen/AutoStart/ZeroTierAutoStart.sh&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>结束！</li>
</ol>
<p>​	现在就可以只需要给树莓派供个电就行了，可以远程写脚本，玩树莓派咯。</p>
<h1 id="作为硬件加速器"><a href="#作为硬件加速器" class="headerlink" title="作为硬件加速器"></a>作为硬件加速器</h1><ul>
<li>硬件加速器</li>
</ul>
<blockquote>
<p>专门设计用于加速特定计算任务的硬件设备。在这里主要用于网络优化，进行流量优化，缓存，路由优化。</p>
</blockquote>
<ul>
<li><strong>代理服务器</strong>：例如Shadowsocks、V2Ray等，可以作为本地代理服务，转发流量到远程服务器。</li>
<li><strong>缓存服务器</strong>：例如Squid，可以作为缓存代理，存储常用的数据来减少对外网的访问。</li>
<li><strong>TCP优化工具</strong>：如安装TCP BBR加速算法，优化数据传输效率。</li>
</ul>
]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>RUST basic</title>
    <url>/2024/03/25/RUST-basic/</url>
    <content><![CDATA[<h1 id="RUST简介"><a href="#RUST简介" class="headerlink" title="RUST简介"></a>RUST简介</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="内存安全性："><a href="#内存安全性：" class="headerlink" title="内存安全性："></a>内存安全性：</h3><blockquote>
<p>​	Rust 提供了内存安全的保证，通过所有权系统、借用检查器和生命周期检查器，可以在编译时捕获大多数常见的内存安全问题，如空指针解引用、数据竞争等。</p>
</blockquote>
<h3 id="并发安全性："><a href="#并发安全性：" class="headerlink" title="并发安全性："></a>并发安全性：</h3><blockquote>
<p>​	Rust 的所有权和借用系统使得编写并发程序更加容易和安全。它通过编译时检查来避免数据竞争和多线程错误，使得编写并行代码更加可靠。</p>
</blockquote>
<h3 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h3><blockquote>
<pre><code> Rust 允许开发者获得接近底层语言（如 C 和 C++）的性能，因为它提供了对内存和并发的细粒度控制，同时不需要牺牲安全性和抽象性。
</code></pre>
</blockquote>
<h3 id="表达能力："><a href="#表达能力：" class="headerlink" title="表达能力："></a>表达能力：</h3><blockquote>
<p>​	Rust 具有功能强大的类型系统和模式匹配功能，使得开发者可以以一种清晰、灵活的方式表达复杂的数据结构和逻辑。</p>
</blockquote>
<h3 id="资源管理："><a href="#资源管理：" class="headerlink" title="资源管理："></a>资源管理：</h3><blockquote>
<p>​	Rust 的所有权模型允许开发者在编写代码时显式地管理资源，避免了像内存泄漏和使用后释放的问题。它还通过 RAII（资源获取即初始化）模式自动管理资源生命周期。</p>
</blockquote>
<h3 id="生态系统："><a href="#生态系统：" class="headerlink" title="生态系统："></a>生态系统：</h3><blockquote>
<p>​	虽然相对较年轻，但 Rust 生态系统不断壮大，拥有丰富的库和工具，支持各种应用场景，从嵌入式系统到网络服务都有涉及。</p>
</blockquote>
<h3 id="跨平台性："><a href="#跨平台性：" class="headerlink" title="跨平台性："></a>跨平台性：</h3><blockquote>
<p>​	Rust 具有良好的跨平台支持，可以轻松地在各种操作系统和硬件架构上进行开发和部署。</p>
</blockquote>
<h3 id="社区支持："><a href="#社区支持：" class="headerlink" title="社区支持："></a>社区支持：</h3><blockquote>
<p>​	Rust 社区活跃，开发者可以从丰富的文档、教程和社区资源中获得支持和帮助。</p>
</blockquote>
<h1 id="RUST-启动！"><a href="#RUST-启动！" class="headerlink" title="RUST 启动！"></a>RUST 启动！</h1><h2 id="1-变量类型"><a href="#1-变量类型" class="headerlink" title="1.变量类型"></a>1.变量类型</h2>]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>rust</tag>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-DC Convert</title>
    <url>/2024/03/28/DC-DC-Convert/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>电源</tag>
        <tag>DC-DC</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 PROJECT keyboard</title>
    <url>/2024/04/16/STM32-PROJECT-keyboard/</url>
    <content><![CDATA[<p>​	之前就有使用别烧好的MCU来进行键盘客制化，始终觉得不得劲。仅仅只是设计了键位PCB和外观，虽然也学到了点东西，但是我就是不爽啊。有一种核心技术自己没掌握的感觉。</p>
<p>​	新坑_STM32_KEYBOARD 开始！</p>
<p>​	二话不说就弃坑了一段时间。。。</p>
<p>​	直接上手STM32有些难了点，先用了别人的方案试试先。基于<code> sayo monkey board</code>的键盘</p>
<h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><p>基于网站[keyboard-layout-editor](<a href="http://www.keyboard-layout-editor.com/#/">Keyboard Layout Editor (keyboard-layout-editor.com)</a>)设计，同时使用<a href="http://builder.swillkb.com/">Plate &amp; Case Builder - swillkb</a>)导出DXF。</p>
<p><img src="/../images/keyboard/layout.png" alt="layoyt"></p>
<h1 id="PCB设计"><a href="#PCB设计" class="headerlink" title="PCB设计"></a>PCB设计</h1><p>​	其实很简单，就是模块套模块，画一下 板子的封装即可。</p>
<p><img src="/../images/keyboard/schematic.png" alt="schematic"></p>
<p><img src="/../images/keyboard/pcb_front.png" alt="pcb"></p>
<p><img src="/../images/keyboard/pcb_bottom.png" alt="pcb"></p>
<h1 id="外壳设计"><a href="#外壳设计" class="headerlink" title="外壳设计"></a>外壳设计</h1><p>​	只是简单的用亚克力打的，CAD还不是很会用。</p>
<p><img src="/../images/keyboard/shield.png" alt="pcb"></p>
]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>project</tag>
        <tag>USB</tag>
        <tag>HID</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>《人间天堂》</title>
    <url>/2024/04/17/%E3%80%8A%E4%BA%BA%E9%97%B4%E5%A4%A9%E5%A0%82%E3%80%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>《爱你就像爱生命》</title>
    <url>/2024/04/17/%E3%80%8A%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD%E3%80%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>《太阳照常升起》</title>
    <url>/2024/04/17/%E3%80%8A%E5%A4%AA%E9%98%B3%E7%85%A7%E5%B8%B8%E5%8D%87%E8%B5%B7%E3%80%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytohn pyinstaller</title>
    <url>/2024/04/25/Pytohn-pyinstaller/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
        <tag>pyinstaller</tag>
        <tag>打包工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytohn tkinter(GUI lib)</title>
    <url>/2024/04/25/Pytohn-tkinter-GUI-lib/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
        <tag>GUI</tag>
        <tag>图形化工具</tag>
      </tags>
  </entry>
  <entry>
    <title>mqttSender</title>
    <url>/2024/04/27/mqttSender/</url>
    <content><![CDATA[<p>用于记录项目mqttSender</p>
<p><a href="https://github.com/regenm/MqttSender">regenm&#x2F;mqttSender</a></p>
<h1 id="MqttSender"><a href="#MqttSender" class="headerlink" title="MqttSender"></a>MqttSender</h1><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>A Software For me to send message to my mqtt server<br>So that I can contral my devices such as esp32 ,esp8266.</p>
<p>Another purpose is to learn python tkinter(GUI lib)</p>
<h3 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h3><ol>
<li>python tkinter</li>
<li>python pyinstaller</li>
<li>python mqtt</li>
</ol>
<h1 id="requirements-analization-v1-0"><a href="#requirements-analization-v1-0" class="headerlink" title="requirements analization v1.0"></a>requirements analization v1.0</h1><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><h3 id="version1-0"><a href="#version1-0" class="headerlink" title="version1.0"></a>version1.0</h3><ul>
<li>conponents</li>
</ul>
<ol>
<li>1 text call box（for output）</li>
<li>1 entry box (for input)</li>
<li>a send button()</li>
</ol>
<ul>
<li>features(or limits? qwq )</li>
</ul>
<ol>
<li>simple</li>
<li>change server(ip address, password , topics) by editing source code .</li>
</ol>
<h2 id="mqtt"><a href="#mqtt" class="headerlink" title="mqtt"></a>mqtt</h2><h3 id="paho-mqtt-version-1-6"><a href="#paho-mqtt-version-1-6" class="headerlink" title="paho-mqtt version 1.6"></a>paho-mqtt version 1.6</h3><ul>
<li>description</li>
</ul>
<p>When coding the parts of mqtt sucscribe and publish , I find that the mqtt lib had upugrade to version 2.0 . However , I get the version 1 example code . Making me annoyed.</p>
<p>So i just gona to use version 1.6</p>
<p>And I will definetly upgrade my code in the future.</p>
<ul>
<li>mqtt part function</li>
</ul>
<p>get the content( payload ) and the server information(settings)  then send it.</p>
<h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p><code>pyinstaller gui_ver_1.py -p mqttSender.py</code></p>
<h1 id="Version-2-0"><a href="#Version-2-0" class="headerlink" title="Version 2.0"></a>Version 2.0</h1><h2 id="requirements-analization-v1-0-1"><a href="#requirements-analization-v1-0-1" class="headerlink" title="requirements analization v1.0"></a>requirements analization v1.0</h2><ul>
<li>6 inut text</li>
<li>1 ouput text</li>
</ul>
<h3 id="Technique-1"><a href="#Technique-1" class="headerlink" title="Technique"></a>Technique</h3><ol>
<li>python tkinter</li>
<li>python pyinstaller</li>
<li>python mqtt</li>
<li>tkinter-designer</li>
</ol>
<h3 id="GUI-1"><a href="#GUI-1" class="headerlink" title="GUI"></a>GUI</h3><p>)<img src="/../images/mqttSender/1.png" alt="version_2"></p>
<h4 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use ?"></a>How to use ?</h4><ul>
<li><p>)use source code</p>
<ol>
<li>change <code>src\final\version_2_0\gui_ver_2.py </code> Line 70 to your own file position<br> <img src="/../images/mqttSender/2.png" alt="img"></li>
<li>RUN</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd src\final\version_2_0</span><br><span class="line">python gui_ver_2.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>use release ( to be finished )</p>
</li>
</ul>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>python</tag>
        <tag>mqtt</tag>
        <tag>IoT</tag>
        <tag>mosquitto</tag>
        <tag>GUI</tag>
        <tag>software</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 IIC with 0.96 OLED</title>
    <url>/2024/05/06/STM32-IIC-with-0-96-OLED/</url>
    <content><![CDATA[<h1 id="IIC-通信原理"><a href="#IIC-通信原理" class="headerlink" title="IIC 通信原理"></a>IIC 通信原理</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://regenm.github.io/2024/01/29/%E5%B8%B8%E8%A7%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/">点击跳转</a></p>
<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><h4 id="硬件层"><a href="#硬件层" class="headerlink" title="硬件层"></a>硬件层</h4><p>​	需要接上拉电阻（保证传输稳定性）</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Init</span><span class="params">()</span>&#123;</span><br><span class="line">  IIC_SCL=<span class="number">1</span>;</span><br><span class="line">  IIC_SDA=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>​	IIC总线的SCL保持高电平，SDA由高电平变为低电平后，延时(&gt;4.7us)，SCL变为低电平。</p>
<ul>
<li>步骤</li>
</ul>
<ol>
<li>SCL 高</li>
<li>SDA 高-&gt;低 + 延时（&gt;4.7us）</li>
<li>SCL 高-&gt;低</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">()</span>&#123;</span><br><span class="line">  IIC_SCL=<span class="number">1</span>;</span><br><span class="line">  IIC_SDA=<span class="number">1</span>;</span><br><span class="line">  delay_us(<span class="number">5</span>);</span><br><span class="line">  IIC_SDA=<span class="number">0</span>;</span><br><span class="line">  delay_us(<span class="number">5</span>);</span><br><span class="line">  IIC_SCL=<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="Tramsmit-Data"><a href="#Tramsmit-Data" class="headerlink" title="Tramsmit Data"></a>Tramsmit Data</h3><h4 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h4><pre><code> 传输时，SDA的宽度应该大于SCL的宽度，在SCL为高时读取SDA，SCL为低时改变SDA的电平。
 ==注意：==传输数据过程总不允许SDA变化（否则会被视为开始或停止信号）
</code></pre>
<ul>
<li>步骤</li>
</ul>
<ol>
<li>拉低SCL进行数据传输</li>
<li>SDA传送高低电平（0或1）</li>
<li>SCL在高电平时期读取SDA的数据</li>
<li>响应信号</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Transmit</span><span class="params">(u8 data)</span>&#123;</span><br><span class="line">  IIC_SCL=<span class="number">0</span>;  <span class="comment">// </span></span><br><span class="line">  u8 i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(data &amp; <span class="number">0x80</span> )&#123; </span><br><span class="line">      IIC_SDA=<span class="number">1</span>;	    <span class="comment">// transmit 1</span></span><br><span class="line">      delay_us(<span class="number">2</span>);</span><br><span class="line">      IIC_SCL=<span class="number">1</span>;</span><br><span class="line">      delay_us(<span class="number">2</span>);</span><br><span class="line">      IIC_SCL=<span class="number">0</span>;</span><br><span class="line">      delay_us(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      IIC_SDA=<span class="number">0</span>;  	   <span class="comment">// tramsmit 0	</span></span><br><span class="line">      delay_us(<span class="number">2</span>);</span><br><span class="line">      IIC_SCL=<span class="number">1</span>;</span><br><span class="line">      delay_us(<span class="number">2</span>);</span><br><span class="line">      IIC_SCL=<span class="number">0</span>;</span><br><span class="line">      delay_us(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    data&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Stop"><a href="#Stop" class="headerlink" title="Stop"></a>Stop</h3><h4 id="物理层-2"><a href="#物理层-2" class="headerlink" title="物理层"></a>物理层</h4><p>​	与Start相反：SCL为高时SDA由低到高</p>
<ol>
<li>SCL &#x3D; 1</li>
<li>SDA &#x3D; 0</li>
<li>SDA &#x3D; 1 + 延时(&gt;4.7us)</li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  IIC_SCL=<span class="number">0</span>;</span><br><span class="line">  IIC_SDA=<span class="number">0</span>;    </span><br><span class="line">   delay_us(<span class="number">4</span>);</span><br><span class="line">  IIC_SCL=<span class="number">1</span>; </span><br><span class="line">  IIC_SDA=<span class="number">1</span>;    </span><br><span class="line">  delay_us(<span class="number">4</span>);							   	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><h4 id="物理层-3"><a href="#物理层-3" class="headerlink" title="物理层"></a>物理层</h4><p>​	主机SCL拉高，读取从机SDA的电平，为低电平表示产生应答</p>
<blockquote>
<ul>
<li>应答信号为低电平时，规定为有效应答位（ACK，简称应答位），表示接收器已经成功地接收了该字节</li>
<li>应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功</li>
</ul>
</blockquote>
<ol>
<li>IIC_SCL&#x3D;0</li>
<li>IIC_SDA&#x3D;0</li>
<li>IIC_SCL&#x3D;1 读取ACK</li>
</ol>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   IIC_SCL=<span class="number">0</span>;   <span class="comment">//先拉低SCL，使得SDA数据可以发生改变</span></span><br><span class="line">   IIC_SDA=<span class="number">0</span>;   </span><br><span class="line">   delay_us(<span class="number">2</span>);</span><br><span class="line">   IIC_SCL=<span class="number">1</span>;</span><br><span class="line">   delay_us(<span class="number">5</span>);</span><br><span class="line">   IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_NAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   IIC_SCL=<span class="number">0</span>;   <span class="comment">//先拉低SCL，使得SDA数据可以发生改变</span></span><br><span class="line">   IIC_SDA=<span class="number">1</span>;   <span class="comment">//拉高SDA，不产生应答信号</span></span><br><span class="line">   delay_us(<span class="number">2</span>);</span><br><span class="line">   IIC_SCL=<span class="number">1</span>;</span><br><span class="line">   delay_us(<span class="number">5</span>);</span><br><span class="line">   IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p>回答基于GPT</p>
<h2 id="IIC通信是如何区分ACK和数据的？"><a href="#IIC通信是如何区分ACK和数据的？" class="headerlink" title="IIC通信是如何区分ACK和数据的？"></a>IIC通信是如何区分ACK和数据的？</h2><blockquote>
<p>在 I2C 通信中，数据传输包括两个方向：主设备向从设备发送数据（写操作），以及从设备向主设备发送数据（读操作）。在这两种情况下，都需要一种方法来区分 ACK（应答）和数据。</p>
<p>下面是 I2C 中如何区分 ACK 和数据的一般流程：</p>
<ol>
<li><strong>写操作</strong>：<ul>
<li>主设备发送一个字节的数据给从设备。</li>
<li>每当主设备发送完一个字节后，会释放 SDA 线并将其拉高，等待从设备的应答。</li>
<li>如果从设备收到数据并且成功接收，它将拉低 SDA 线表示 ACK。</li>
<li>如果从设备未成功接收数据（或者不接收），它将保持 SDA 线高电平，表示 NACK（非应答）。</li>
</ul>
</li>
<li><strong>读操作</strong>：<ul>
<li>主设备向从设备发送一个读请求，并在准备接收数据时将 SDA 线拉高，进入接收模式。</li>
<li>从设备在每个数据字节的发送后，会将 SDA 线拉低或保持低电平来表示 ACK。</li>
<li>当从设备不再有数据发送时，它将保持 SDA 线高电平，表示 NACK。</li>
</ul>
</li>
</ol>
<p>在 I2C 中，ACK 和 NACK 的区别是在 SDA 线上的电平状态。ACK 是 SDA 线被拉低一段时间（通常是一个时钟周期），而 NACK 是 SDA 线保持高电平。</p>
<p>这种应答机制确保了数据的正确传输，并且主设备和从设备之间能够进行有效的通信。</p>
</blockquote>
<h2 id="IIC如何判断是否已经传输好了一个字节？否则会误判ACK信号吧"><a href="#IIC如何判断是否已经传输好了一个字节？否则会误判ACK信号吧" class="headerlink" title="IIC如何判断是否已经传输好了一个字节？否则会误判ACK信号吧"></a>IIC如何判断是否已经传输好了一个字节？否则会误判ACK信号吧</h2><blockquote>
<p>在 I2C 通信中，确实有一个机制来确保每个字节都被正确传输，以避免误判 ACK 信号。这个机制称为“时钟拉伸”（Clock Stretching）。</p>
<p>时钟拉伸是从设备（通常是从设备）可以通过拉低时钟线（SCL）来暂停主设备的时钟来延长传输时间的能力。当从设备需要更多时间来处理数据或准备发送应答时，它可以拉低 SCL 线来暂停时钟，从而保证数据传输的准确性。</p>
<p>在每个数据字节的传输中，主设备发送一个字节，并在每个时钟周期结束时等待从设备的应答。如果从设备需要额外时间，则可以拉伸时钟线。一旦从设备准备好应答，它就释放 SCL 线，使时钟继续，主设备就可以继续传输下一个字节或完成传输。</p>
<p>这种时钟拉伸的机制确保了主设备和从设备之间的同步，并且确保了每个字节都能够被正确传输。如果从设备在时钟拉伸期间没有完成数据的处理或准备应答，主设备会在检测到应答信号之前继续等待。</p>
<p>因此，在 I2C 通信中，即使有时钟拉伸，主设备仍能够正确判断 ACK 信号。</p>
</blockquote>
<h2 id="IIC如何判断是否已经传输好了一个字节？"><a href="#IIC如何判断是否已经传输好了一个字节？" class="headerlink" title="IIC如何判断是否已经传输好了一个字节？"></a>IIC如何判断是否已经传输好了一个字节？</h2><blockquote>
<p>在 I2C 中，主设备在发送每个字节时都会产生一个时钟脉冲（CLK）。这些时钟脉冲用于同步数据传输，并且在每个字节的传输之后，主设备需要知道何时应该停止发送数据并等待从设备的应答。</p>
<p>判断是否已经传输好了一个字节主要依赖于主设备的计数。主设备通常会发送8个时钟脉冲（对应一个字节的8位数据），然后等待从设备的应答。</p>
<p>具体的步骤如下：</p>
<ol>
<li>主设备发送一个字节的数据。</li>
<li>主设备在发送每个位时都会产生一个时钟脉冲（CLK），总共8个脉冲。</li>
<li>在发送完最后一个位后，主设备停止产生时钟脉冲，并等待从设备的应答。</li>
</ol>
<p>等待应答时，主设备可以通过检测SDA线上的电平来判断是否收到应答信号。如果从设备接收到了数据并正确处理，它会拉低SDA线（ACK），表示接收到数据并准备好接收下一个字节。如果从设备没有接收到数据或者出现错误，它会保持SDA线为高电平（NACK）。</p>
<p>通过这种方式，主设备可以判断是否已经传输好了一个字节，并且根据从设备的应答来进行相应的操作。</p>
</blockquote>
<h1 id="STM32-实现"><a href="#STM32-实现" class="headerlink" title="STM32 实现"></a>STM32 实现</h1><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h2 id="hal库"><a href="#hal库" class="headerlink" title="hal库"></a>hal库</h2>]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>STM32</tag>
        <tag>project</tag>
        <tag>notes</tag>
        <tag>IIC</tag>
        <tag>OLED</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32_Menu_frameV1.0</title>
    <url>/2024/05/09/STM32-Menu-frameV1-0/</url>
    <content><![CDATA[<p>Record project  <strong>STM32_Menu_frame</strong></p>
<p>[STM32_Menu_frame](to be added)</p>
<h1 id="Requirement-Analysis"><a href="#Requirement-Analysis" class="headerlink" title="Requirement Analysis"></a>Requirement Analysis</h1><h2 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h2><ol>
<li>实现单级菜单</li>
<li>按键选择</li>
<li>SPI或IIC的oled屏显示</li>
</ol>
<h2 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h2><p>based on Version 1</p>
<ol>
<li>多级菜单</li>
<li>UI美化</li>
</ol>
]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>STM32</tag>
        <tag>project</tag>
        <tag>notes</tag>
        <tag>IIC</tag>
        <tag>OLED</tag>
        <tag>spi</tag>
        <tag>UI</tag>
        <tag>stdlib</tag>
      </tags>
  </entry>
  <entry>
    <title>大创项目《自动化农业无人机》记录</title>
    <url>/2024/05/09/%E5%A4%A7%E5%88%9B%E9%A1%B9%E7%9B%AE%E3%80%8A%E8%87%AA%E5%8A%A8%E5%8C%96%E5%86%9C%E4%B8%9A%E6%97%A0%E4%BA%BA%E6%9C%BA%E3%80%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>​	记录一下大创项目《自动化农业无人机》。实现项目转化知识成果</p>
<h1 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h1><p><img src="/images/dachaung/1.png" alt="硬件选型"></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><h3 id="三轴陀螺仪的使用（以mpu6050为例）"><a href="#三轴陀螺仪的使用（以mpu6050为例）" class="headerlink" title="三轴陀螺仪的使用（以mpu6050为例）"></a>三轴陀螺仪的使用（以mpu6050为例）</h3><p>[MPU6050 basic  with Arduino](link to be added)</p>
<h3 id="PID算法-1"><a href="#PID算法-1" class="headerlink" title="PID算法"></a>PID算法</h3><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="mqtt协议简介"><a href="#mqtt协议简介" class="headerlink" title="mqtt协议简介"></a>mqtt协议简介</h3><p><a href="https://regenm.github.io/2024/02/09/esp8266%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9F%BA%E4%BA%8Emosquitto%E7%9A%84mqtt-server%EF%BC%89/">esp8266连接服务器（基于mosquitto的mqtt server） | Regen (regenm.github.io)</a></p>
<h3 id="mqtt服务器搭建"><a href="#mqtt服务器搭建" class="headerlink" title="mqtt服务器搭建"></a>mqtt服务器搭建</h3><p><a href="https://regenm.github.io/2024/02/09/MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88mosquitto%EF%BC%89/">MQTT服务器搭建（mosquitto） | Regen (regenm.github.io)</a></p>
<h3 id="传输系统"><a href="#传输系统" class="headerlink" title="传输系统"></a>传输系统</h3><h4 id="1-数据传输"><a href="#1-数据传输" class="headerlink" title="1. 数据传输"></a>1. 数据传输</h4><p>mqtt协议基于代理，订阅和发布。</p>
<p>因此在服务器里创建一个频道<code>/topic/dataFromSensors</code>用于各类传感器的数据传输</p>
<ol>
<li>高度传感器</li>
<li>二氧化碳传感器</li>
<li>温湿度传感器</li>
<li>电池消耗</li>
</ol>
<h4 id="2-命令传输"><a href="#2-命令传输" class="headerlink" title="2. 命令传输"></a>2. 命令传输</h4><p>在服务器里创建一个频道<code>/topic/commandToDrone</code>用于各类命令的传输</p>
<ol>
<li>UP</li>
<li>DOWM</li>
<li>LEFT</li>
<li>RIGHT</li>
<li>SPIN</li>
</ol>
<p>因为基于mqtt协议，因此自动化控制很简单，上位机很好写，也可以不用上位机，在服务器上写的shell脚本就能很好的完成自动化功能。</p>
<p><a href="https://regenm.github.io/2024/04/27/mqttSender/">mqttSender | Regen (regenm.github.io)</a></p>
<h2 id="外扩系统"><a href="#外扩系统" class="headerlink" title="外扩系统"></a>外扩系统</h2><h3 id="3D打印"><a href="#3D打印" class="headerlink" title="3D打印"></a>3D打印</h3><h3 id="外扩系统构成"><a href="#外扩系统构成" class="headerlink" title="外扩系统构成"></a>外扩系统构成</h3><h4 id="1-独立MCU"><a href="#1-独立MCU" class="headerlink" title="1. 独立MCU"></a>1. 独立MCU</h4><h4 id="2-模块化设计"><a href="#2-模块化设计" class="headerlink" title="2. 模块化设计"></a>2. 模块化设计</h4>]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
        <tag>esp8266</tag>
        <tag>物联网</tag>
        <tag>大创</tag>
        <tag>项目</tag>
        <tag>无人机</tag>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++大型项目编程注意事项</title>
    <url>/2024/05/13/C-C-%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p><strong>C&#x2F;C++大型项目编程规范</strong></p>
<p>​	最近在参与（或者说使用）某些项目的代码时，感觉其代码之简洁精炼，语言习惯之规范，外观之整洁，可读性之高令人赏心悦目。</p>
<p>​	在其基础上进行增删改查后总是觉得自己的代码不够优雅，就好像一篇书法作品中掺杂几行我写的字。</p>
<p>​	于是打算学习C&#x2F;C++项目编程规范，不求优雅，只求规整可读，结构合理。</p>
<p>​	基于华为C语言编程规范 <a href="https://ilcc.gitbooks.io/wiki/content/StyleGuide/Huawei-C/index.html">在线wiki文档</a></p>
<h1 id="代码总体原则"><a href="#代码总体原则" class="headerlink" title="代码总体原则"></a>代码总体原则</h1><h2 id="1、清晰第一"><a href="#1、清晰第一" class="headerlink" title="1、清晰第一"></a>1、清晰第一</h2><p><strong>代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化</strong></p>
<ul>
<li><p>优秀的代码可以自我解释（以我的水平可能做到比较难）</p>
</li>
<li><p>常写注释，并且注释写的清晰</p>
</li>
</ul>
<h2 id="2、简洁为美"><a href="#2、简洁为美" class="headerlink" title="2、简洁为美"></a>2、简洁为美</h2><p><strong>写的代码越多，意味着出错的地方越多，也就意味着代码的可靠性越低。</strong></p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><blockquote>
<p>原则：编程时必须坚持的指导思想。</p>
<p>规则：编程时强制必须遵守的约定。</p>
<p>建议：编程时必须加以考虑的约定。</p>
<p>说明：对此原则&#x2F;规则&#x2F;建议进行必要的解释。</p>
<p>示例：对此原则&#x2F;规则&#x2F;建议从正、反两个方面给出例子。</p>
<p>延伸阅读材料：建议进一步阅读的参考材料。</p>
</blockquote>
<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p><strong>不合理的头文件布局是编译时间过长的根因，不合理的头文件实际上不合理的设计。</strong></p>
<p>如果引入了新的依赖，则一旦被依赖的头文件修改，任何直接和间接依赖其头文件的代码都会被重新编译。</p>
<h3 id="原则1-1-头文件中适合放置接口的声明，不适合放置实现"><a href="#原则1-1-头文件中适合放置接口的声明，不适合放置实现" class="headerlink" title="原则1.1 头文件中适合放置接口的声明，不适合放置实现"></a>原则1.1 头文件中适合放置接口的声明，不适合放置实现</h3><p>头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。</p>
<ul>
<li>内部使用的函数（相当于类的私有方法）声明不应放在头文件中</li>
<li>内部使用的宏、枚举、结构定义不应放入头文件中。</li>
<li>变量定义不应放在头文件中，应放在.c文件中。</li>
</ul>
<p>否则多次依赖会重复定义</p>
<ul>
<li>变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。即使必须使用全局变量，也只应当在.c中定义全局变量，在.h中仅声明变量为全局的。</li>
</ul>
<h3 id="原则1-2-头文件应当职责单一。"><a href="#原则1-2-头文件应当职责单一。" class="headerlink" title="原则1.2 头文件应当职责单一。"></a>原则1.2 头文件应当职责单一。</h3><h3 id="原则1-3-头文件应向稳定的方向包含。"><a href="#原则1-3-头文件应向稳定的方向包含。" class="headerlink" title="原则1.3 头文件应向稳定的方向包含。"></a>原则1.3 头文件应向稳定的方向包含。</h3><p>说明：头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="规则1-1-每一个-c文件应有一个同名-h文件，用于声明需要对外公开的接口。"><a href="#规则1-1-每一个-c文件应有一个同名-h文件，用于声明需要对外公开的接口。" class="headerlink" title="规则1.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。"></a>规则1.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。</h3><p>说明：如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。</p>
<h3 id="规则1-2-禁止头文件循环依赖"><a href="#规则1-2-禁止头文件循环依赖" class="headerlink" title="规则1.2 禁止头文件循环依赖"></a>规则1.2 禁止头文件循环依赖</h3><p>​	任何一个头文件的改变都会使得循环中的所有头文件重新编译</p>
<h3 id="规则1-3-c-h文件禁止包含用不到的头文件。"><a href="#规则1-3-c-h文件禁止包含用不到的头文件。" class="headerlink" title="规则1.3 .c&#x2F;.h文件禁止包含用不到的头文件。"></a>规则1.3 .c&#x2F;.h文件禁止包含用不到的头文件。</h3><h3 id="规则1-4-头文件应当自包含。"><a href="#规则1-4-头文件应当自包含。" class="headerlink" title="规则1.4 头文件应当自包含。"></a>规则1.4 头文件应当自包含。</h3><blockquote>
<p>“头文件应当自包含”是指头文件应该包含自身所需的所有内容，而不依赖于其他头文件。这样的头文件通常被称为”自包含头文件”。下面解释一下这个概念的意义：</p>
<ol>
<li><strong>独立性和可移植性</strong>：自包含头文件使得头文件本身更加独立，不依赖于其他头文件。这样做有助于提高代码的可移植性，因为当你在其他项目或环境中使用这个头文件时，不需要担心它依赖的其他头文件是否可用。</li>
<li><strong>简化依赖关系</strong>：自包含头文件可以简化代码的依赖关系。如果一个头文件依赖于另一个头文件，而后者又依赖于其他头文件，这会形成复杂的依赖链。通过自包含头文件，可以减少这种依赖链，提高代码的可维护性。</li>
<li><strong>避免重复包含</strong>：自包含头文件通常会包含预处理器指令来避免重复包含。这样可以确保在包含相同头文件多次时不会导致重复定义的问题。</li>
<li><strong>提高效率</strong>：自包含头文件可以减少预处理器的工作量，因为它们不需要解析其他头文件的内容。这有助于提高编译效率。</li>
</ol>
</blockquote>
<h3 id="规则1-5-总是编写内部-include保护符（-define-保护）。"><a href="#规则1-5-总是编写内部-include保护符（-define-保护）。" class="headerlink" title="规则1.5 总是编写内部#include保护符（#define 保护）。"></a>规则1.5 总是编写内部#include保护符（#define 保护）。</h3><p>所有头文件都应当使用#define 防止头文件被多重包含，命名格式为<code>FILENAME_H</code>，为了保证唯一性，更好的命名是<code>PROJECTNAME_PATH_FILENAME_H</code>。</p>
<h3 id="规则1-6-禁止在头文件中定义变量。"><a href="#规则1-6-禁止在头文件中定义变量。" class="headerlink" title="规则1.6 禁止在头文件中定义变量。"></a>规则1.6 禁止在头文件中定义变量。</h3><p>说明：在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。</p>
<h3 id="规则1-7-只能通过包含头文件的方式使用其他-c提供的接口，禁止在-c中通过extern的方式使用外部函数接口、变量。"><a href="#规则1-7-只能通过包含头文件的方式使用其他-c提供的接口，禁止在-c中通过extern的方式使用外部函数接口、变量。" class="headerlink" title="规则1.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。"></a>规则1.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。</h3><h3 id="规则1-8-禁止在extern-“C”中包含头文件。"><a href="#规则1-8-禁止在extern-“C”中包含头文件。" class="headerlink" title="规则1.8 禁止在extern “C”中包含头文件。"></a>规则1.8 禁止在extern “C”中包含头文件。</h3><blockquote>
<p><code>extern &quot;C&quot;</code> 是用于在 C++ 中声明 C 函数时的一种语法。它告诉编译器这些函数按照 C 语言的约定进行链接。</p>
<p>在 C++ 中，函数名的重载、名称修饰（name mangling）等特性会导致函数名在编译后被修改，这样的函数名在链接时可能无法与 C 代码中的函数名匹配。为了解决这个问题，C++ 提供了 <code>extern &quot;C&quot;</code>，它告诉编译器不要对函数名进行 C++ 风格的名称修饰，而是按照 C 语言的规则进行链接。</p>
</blockquote>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数设计的精髓：编写整洁函数，同时把代码有效组织起来。</p>
<p>整洁函数要求：代码简单直接、不隐藏设计者的意图、用干净利落的抽象和直截了当的控制语句将函数有机组织起来。</p>
<p>代码的有效组织包括：逻辑层组织和物理层组织两个方面。逻辑层，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。物理层，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。</p>
<h2 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h2><h3 id="原则2-1-一个函数仅完成一件功能。"><a href="#原则2-1-一个函数仅完成一件功能。" class="headerlink" title="原则2.1 一个函数仅完成一件功能。"></a>原则2.1 一个函数仅完成一件功能。</h3><p>说明：一个函数实现多个功能给开发、使用、维护都带来很大的困难。</p>
<p>将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。</p>
<h3 id="原则2-2-重复代码应该尽可能提炼成函数"><a href="#原则2-2-重复代码应该尽可能提炼成函数" class="headerlink" title="原则2.2 重复代码应该尽可能提炼成函数"></a>原则2.2 重复代码应该尽可能提炼成函数</h3><p>说明：重复代码提炼成函数可以带来维护成本的降低。</p>
<p>可以使用代码重复度检查工具</p>
<h2 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h2><h3 id="规则2-1-避免函数过长，新增函数不超过50行（非空非注释行）。"><a href="#规则2-1-避免函数过长，新增函数不超过50行（非空非注释行）。" class="headerlink" title="规则2.1 避免函数过长，新增函数不超过50行（非空非注释行）。"></a>规则2.1 避免函数过长，新增函数不超过50行（非空非注释行）。</h3><h3 id="规则2-2-避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。"><a href="#规则2-2-避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。" class="headerlink" title="规则2.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。"></a>规则2.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。</h3><h4 id="减少代码嵌套层数的方法"><a href="#减少代码嵌套层数的方法" class="headerlink" title="减少代码嵌套层数的方法"></a>减少代码嵌套层数的方法</h4><blockquote>
<ol>
<li><strong>使用函数抽象</strong>：将嵌套的代码块提取成独立的函数，以便于重用和理解。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;python复制代码def main_function():</span><br><span class="line">   if condition:</span><br><span class="line">       process_items(items)</span><br><span class="line">   else:</span><br><span class="line">       handle_condition_not_met()</span><br><span class="line"></span><br><span class="line">&gt;def process_items(items):</span><br><span class="line">   for item in items:</span><br><span class="line">       if item_valid(item):</span><br><span class="line">           process_item(item)</span><br><span class="line">       else:</span><br><span class="line">           handle_invalid_item(item)</span><br><span class="line"></span><br><span class="line">&gt;def item_valid(item):</span><br><span class="line">   return item.condition</span><br><span class="line"></span><br><span class="line">&gt;def process_item(item):</span><br><span class="line">   # 处理item</span><br><span class="line">   pass</span><br><span class="line"></span><br><span class="line">&gt;def handle_invalid_item(item):</span><br><span class="line">   # 处理无效item</span><br><span class="line">   pass</span><br><span class="line"></span><br><span class="line">&gt;def handle_condition_not_met():</span><br><span class="line">   # 处理条件未满足情况</span><br><span class="line">   pass</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用早期返回</strong>：在函数内部，尽早返回结果，而不是在多层嵌套中处理。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">main_function</span>():</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> condition:</span><br><span class="line">       handle_condition_not_met()</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> item_valid(item):</span><br><span class="line">           handle_invalid_item(item)</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">       process_item(item)</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">item_valid</span>(<span class="params">item</span>):</span><br><span class="line">   <span class="keyword">return</span> item.condition</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">item</span>):</span><br><span class="line">   <span class="comment"># 处理item</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">handle_invalid_item</span>(<span class="params">item</span>):</span><br><span class="line">   <span class="comment"># 处理无效item</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">handle_condition_not_met</span>():</span><br><span class="line">   <span class="comment"># 处理条件未满足情况</span></span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用异常处理</strong>：适用于处理特殊情况或错误的情况。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">main_function</span>():</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       <span class="keyword">if</span> condition:</span><br><span class="line">           <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">               process_item(item)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">raise</span> ConditionNotMetError</span><br><span class="line">   <span class="keyword">except</span> ConditionNotMetError:</span><br><span class="line">       handle_condition_not_met()</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">item</span>):</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> item_valid(item):</span><br><span class="line">       <span class="keyword">raise</span> InvalidItemError</span><br><span class="line">   <span class="comment"># 处理item</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">item_valid</span>(<span class="params">item</span>):</span><br><span class="line">   <span class="keyword">return</span> item.condition</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">handle_condition_not_met</span>():</span><br><span class="line">   <span class="comment"># 处理条件未满足情况</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">ConditionNotMetError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">InvalidItemError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这些方法可以帮助将嵌套降低到合理的水平，使代码更易读、更易维护。</p>
</blockquote>
<h3 id="规则2-3-可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。"><a href="#规则2-3-可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。" class="headerlink" title="规则2.3 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。"></a>规则2.3 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。</h3><p>可能用不到。</p>
<p>说明：可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。共享变量指的全局变量和static变量。</p>
<h3 id="规则2-4-对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组-模块内应统一规定。缺省由调用者负责。"><a href="#规则2-4-对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组-模块内应统一规定。缺省由调用者负责。" class="headerlink" title="规则2.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组&#x2F;模块内应统一规定。缺省由调用者负责。"></a>规则2.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组&#x2F;模块内应统一规定。缺省由调用者负责。</h3><h3 id="规则2-5-对函数的错误返回码要全面处理。"><a href="#规则2-5-对函数的错误返回码要全面处理。" class="headerlink" title="规则2.5 对函数的错误返回码要全面处理。"></a>规则2.5 对函数的错误返回码要全面处理。</h3><h3 id="规则2-6-设计高扇入，合理扇出（小于7）的函数。"><a href="#规则2-6-设计高扇入，合理扇出（小于7）的函数。" class="headerlink" title="规则2.6 设计高扇入，合理扇出（小于7）的函数。"></a>规则2.6 设计高扇入，合理扇出（小于7）的函数。</h3><p>说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。</p>
<p>建议2.1 函数不变参数使用const。</p>
<p>建议2.2 函数应避免使用全局变量、静态局部变量和I&#x2F;O操作，不可避免的地方应集中使用。</p>
<p>建议2.4 函数的参数个数不超过5个。</p>
<p>建议2.5 除打印类函数外，不要使用可变长参函数。</p>
<h1 id="3标识符命名与定义"><a href="#3标识符命名与定义" class="headerlink" title="3标识符命名与定义"></a>3标识符命名与定义</h1><h2 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h2><ol>
<li><p>unix like风格</p>
<p> 单词用小写字母，每个单词直接用下划线‘_’分割，例如text_mutex，kernel_text_address。</p>
</li>
<li><p>Windows风格</p>
<p> 大小写字母混用，单词连在一起，每个单词首字母大写</p>
</li>
<li><p>匈牙利命名法</p>
<p> 匈牙利命名主要包括三个部分：基本类型、一个或更多的前缀、一个限定词。</p>
</li>
</ol>
<h3 id="原则-2"><a href="#原则-2" class="headerlink" title="原则"></a>原则</h3><h4 id="原则3-1标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。"><a href="#原则3-1标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。" class="headerlink" title="原则3.1标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。"></a>原则3.1标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。</h4><h4 id="原则3-2-除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音。"><a href="#原则3-2-除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音。" class="headerlink" title="原则3.2 除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音。"></a>原则3.2 除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音。</h4><p>示例：一些常见可以缩写的例子：</p>
<ul>
<li>argument 可缩写为 arg</li>
<li>buffer 可缩写为 buff</li>
<li>clock 可缩写为 clk</li>
<li>command 可缩写为 cmd</li>
<li>compare 可缩写为 cmp</li>
<li>configuration 可缩写为 cfg</li>
<li>device 可缩写为 dev</li>
<li>error 可缩写为 err</li>
<li>hexadecimal 可缩写为 hex</li>
<li>increment 可缩写为 inc、</li>
<li>initialize 可缩写为 init</li>
<li>maximum 可缩写为 max</li>
<li>message 可缩写为 msg</li>
<li>minimum 可缩写为 min</li>
<li>parameter 可缩写为 para</li>
<li>previous 可缩写为 prev</li>
<li>register 可缩写为 reg</li>
<li>semaphore 可缩写为 sem</li>
<li>statistic 可缩写为 stat</li>
<li>synchronize 可缩写为 sync</li>
<li>temp 可缩写为 tmp</li>
</ul>
<h3 id="规则-2"><a href="#规则-2" class="headerlink" title="规则"></a>规则</h3><h4 id="规则3-1-产品-项目组内部应保持统一的命名风格。"><a href="#规则3-1-产品-项目组内部应保持统一的命名风格。" class="headerlink" title="规则3.1 产品&#x2F;项目组内部应保持统一的命名风格。"></a>规则3.1 产品&#x2F;项目组内部应保持统一的命名风格。</h4><blockquote>
<p>示例：</p>
<p>add&#x2F;remove begin&#x2F;end create&#x2F;destroy insert&#x2F;delete first&#x2F;last get&#x2F;release increment&#x2F;decrement put&#x2F;get add&#x2F;delete lock&#x2F;unlock open&#x2F;close min&#x2F;max old&#x2F;new start&#x2F;stop next&#x2F;previous source&#x2F;target show&#x2F;hide send&#x2F;receive source&#x2F;destination copy&#x2F;paste up&#x2F;down</p>
</blockquote>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><h4 id="建议3-2-尽量避免名字中出现数字编号，除非逻辑上的确需要编号。"><a href="#建议3-2-尽量避免名字中出现数字编号，除非逻辑上的确需要编号。" class="headerlink" title="建议3.2 尽量避免名字中出现数字编号，除非逻辑上的确需要编号。"></a>建议3.2 尽量避免名字中出现数字编号，除非逻辑上的确需要编号。</h4><h4 id="建议3-3-标识符前不应添加模块、项目、产品、部门的名称作为前缀。"><a href="#建议3-3-标识符前不应添加模块、项目、产品、部门的名称作为前缀。" class="headerlink" title="建议3.3 标识符前不应添加模块、项目、产品、部门的名称作为前缀。"></a>建议3.3 标识符前不应添加模块、项目、产品、部门的名称作为前缀。</h4><h4 id="建议3-4-平台-驱动等适配代码的标识符命名风格保持和平台-驱动一致。"><a href="#建议3-4-平台-驱动等适配代码的标识符命名风格保持和平台-驱动一致。" class="headerlink" title="建议3.4 平台&#x2F;驱动等适配代码的标识符命名风格保持和平台&#x2F;驱动一致。"></a>建议3.4 平台&#x2F;驱动等适配代码的标识符命名风格保持和平台&#x2F;驱动一致。</h4><h2 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h2><h3 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h3><h4 id="建议3-6-文件命名统一采用小写字符。"><a href="#建议3-6-文件命名统一采用小写字符。" class="headerlink" title="建议3.6 文件命名统一采用小写字符。"></a>建议3.6 文件命名统一采用小写字符。</h4><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><h3 id="规则-3"><a href="#规则-3" class="headerlink" title="规则"></a>规则</h3><h4 id="规则3-2-全局变量应增加“g-”前缀。"><a href="#规则3-2-全局变量应增加“g-”前缀。" class="headerlink" title="规则3.2 全局变量应增加“g_”前缀。"></a>规则3.2 全局变量应增加“g_”前缀。</h4><h4 id="规则3-3-静态变量应增加“s-”前缀。"><a href="#规则3-3-静态变量应增加“s-”前缀。" class="headerlink" title="规则3.3 静态变量应增加“s_”前缀。"></a>规则3.3 静态变量应增加“s_”前缀。</h4><h4 id="规则3-4-禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量。"><a href="#规则3-4-禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量。" class="headerlink" title="规则3.4 禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量。"></a>规则3.4 禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量。</h4><h3 id="建议-2"><a href="#建议-2" class="headerlink" title="建议"></a>建议</h3><h4 id="建议3-7-不建议使用匈牙利命名法。"><a href="#建议3-7-不建议使用匈牙利命名法。" class="headerlink" title="建议3.7 不建议使用匈牙利命名法。"></a>建议3.7 不建议使用匈牙利命名法。</h4><h4 id="建议3-8-使用名词或者形容词＋名词方式命名变量。"><a href="#建议3-8-使用名词或者形容词＋名词方式命名变量。" class="headerlink" title="建议3.8 使用名词或者形容词＋名词方式命名变量。"></a>建议3.8 使用名词或者形容词＋名词方式命名变量。</h4><h2 id="函数命名规则"><a href="#函数命名规则" class="headerlink" title="函数命名规则"></a>函数命名规则</h2><h3 id="建议-3"><a href="#建议-3" class="headerlink" title="建议"></a>建议</h3><h4 id="建议3-9-函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。"><a href="#建议3-9-函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。" class="headerlink" title="建议3.9 函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。"></a>建议3.9 函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。</h4><h2 id="宏的命名规则"><a href="#宏的命名规则" class="headerlink" title="宏的命名规则"></a>宏的命名规则</h2><h3 id="规则-4"><a href="#规则-4" class="headerlink" title="规则"></a>规则</h3><h4 id="规则3-5对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线‘-’的方式命名（枚举同样建议使用此方式定义）。"><a href="#规则3-5对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线‘-’的方式命名（枚举同样建议使用此方式定义）。" class="headerlink" title="规则3.5对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线‘_’的方式命名（枚举同样建议使用此方式定义）。"></a>规则3.5对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线‘_’的方式命名（枚举同样建议使用此方式定义）。</h4><h4 id="规则3-6-除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线‘-’开头和结尾。"><a href="#规则3-6-除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线‘-’开头和结尾。" class="headerlink" title="规则3.6 除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线‘_’开头和结尾。"></a>规则3.6 除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线‘_’开头和结尾。</h4><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="原则-3"><a href="#原则-3" class="headerlink" title="原则"></a>原则</h2><h3 id="原则4-1-一个变量只有一个功能，不能把一个变量用作多种用途。"><a href="#原则4-1-一个变量只有一个功能，不能把一个变量用作多种用途。" class="headerlink" title="原则4.1 一个变量只有一个功能，不能把一个变量用作多种用途。"></a>原则4.1 一个变量只有一个功能，不能把一个变量用作多种用途。</h3><blockquote>
<p>我怎么感觉在某些情况下无妨啊，开多了变量会占用性能吧？</p>
<p>也就是说：重要性：代码的可读性、可维护性和减少错误&gt;性能消耗</p>
<p>下列答案基于<strong>chatGPT</strong></p>
<p>遵循“一个变量只有一个功能”的原则确实会增加一些变量的数量，但这通常不会显著增加系统开销，特别是在现代编程环境和硬件条件下。这是因为：</p>
<ol>
<li><p><strong>内存开销相对较小</strong>：</p>
<ul>
<li>现代计算机的内存容量通常非常大，增加几个变量所占用的内存是非常小的。这种内存开销在绝大多数应用场景下可以忽略不计。</li>
</ul>
</li>
<li><p><strong>编译器优化</strong>：</p>
<ul>
<li>现代编译器和解释器非常智能，它们可以优化代码，将不必要的变量删除或者合并，从而减少内存开销。例如，在优化编译过程中，编译器会尝试最小化变量的存储空间，并进行变量复用等优化操作。</li>
</ul>
</li>
<li><p><strong>代码可读性和维护性优先</strong>：</p>
<ul>
<li>代码的可读性和可维护性在实际开发中比微小的性能优化更重要。可读性好的代码更容易被团队中的其他开发人员理解和维护，从而降低了开发和维护的成本。</li>
</ul>
</li>
<li><p><strong>开发效率和错误减少</strong>：</p>
<ul>
<li>使用单一功能变量可以减少代码中的错误，使开发过程更加顺利。这种减少错误和提升开发效率的好处往往远远超过因为增加变量数量而带来的微小性能损失。</li>
</ul>
</li>
</ol>
<p><strong>示例分析</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加系统开销的担忧</span></span><br><span class="line">total_items = <span class="number">10</span></span><br><span class="line">price = <span class="number">5.99</span></span><br><span class="line">total_cost = total_items * price</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不好的做法：减少变量数量</span></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">x = <span class="number">5.99</span></span><br><span class="line">x = x * x  <span class="comment"># 这样做容易引入错误，也降低了代码的可读性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确做法：使用多个变量，增加代码可读性</span></span><br><span class="line">total_items = <span class="number">10</span></span><br><span class="line">price_per_item = <span class="number">5.99</span></span><br><span class="line">total_cost = total_items * price_per_item</span><br></pre></td></tr></table></figure>

<p>在这个示例中，尽管引入了多个变量，但它们使代码更容易理解和维护。变量名清晰地表达了它们的用途，减少了开发和调试中的潜在错误。</p>
<p><strong>总结</strong>：</p>
<p>遵循“一个变量只有一个功能”的原则，不仅不会显著增加系统开销，反而可以通过提升代码质量和开发效率，降低长远的开发和维护成本。因此，在大多数情况下，这种做法是非常值得的。实际开发中，尤其是在团队协作和大型项目中，应优先考虑代码的可读性和可维护性。</p>
</blockquote>
<h3 id="原则4-2-结构功能单一；不要设计面面俱到的数据结构。"><a href="#原则4-2-结构功能单一；不要设计面面俱到的数据结构。" class="headerlink" title="原则4.2 结构功能单一；不要设计面面俱到的数据结构。"></a>原则4.2 结构功能单一；不要设计面面俱到的数据结构。</h3><h3 id="原则4-3-不用或者少用全局变量。"><a href="#原则4-3-不用或者少用全局变量。" class="headerlink" title="原则4.3 不用或者少用全局变量。"></a>原则4.3 不用或者少用全局变量。</h3><h2 id="规则-5"><a href="#规则-5" class="headerlink" title="规则"></a>规则</h2><h3 id="规则4-1-防止局部变量与全局变量同名。"><a href="#规则4-1-防止局部变量与全局变量同名。" class="headerlink" title="规则4.1 防止局部变量与全局变量同名。"></a>规则4.1 防止局部变量与全局变量同名。</h3><h3 id="规则4-2-通讯过程中使用的结构，必须注意字节序。"><a href="#规则4-2-通讯过程中使用的结构，必须注意字节序。" class="headerlink" title="规则4.2 通讯过程中使用的结构，必须注意字节序。"></a>规则4.2 通讯过程中使用的结构，必须注意字节序。</h3><blockquote>
<p>字节序的解释（基于chatGPT）</p>
<p>字节序（Byte Order）是指在计算机内存中存储多字节数据时，字节的排列顺序。不同计算机系统可能采用不同的字节序，主要有两种类型：大端序（Big-Endian）和小端序（Little-Endian）。</p>
<h3 id="大端序（Big-Endian）"><a href="#大端序（Big-Endian）" class="headerlink" title="大端序（Big-Endian）"></a>大端序（Big-Endian）</h3><ul>
<li><p><strong>定义</strong>：高位字节存储在低地址，低位字节存储在高地址。</p>
</li>
<li><p>示例</p>
<p>  ：假设有一个4字节（32位）的数值</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x12345678</span><br></pre></td></tr></table></figure>

<p>  。在大端序系统中，它的存储顺序如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">makefile复制代码地址:   0x00  0x01  0x02  0x03</span><br><span class="line">值:     0x12  0x34  0x56  0x78</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="小端序（Little-Endian）"><a href="#小端序（Little-Endian）" class="headerlink" title="小端序（Little-Endian）"></a>小端序（Little-Endian）</h3><ul>
<li><p><strong>定义</strong>：低位字节存储在低地址，高位字节存储在高地址。</p>
</li>
<li><p>示例</p>
<p>  ：同样的数值</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x12345678</span><br></pre></td></tr></table></figure>

<p>  在小端序系统中的存储顺序如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">makefile复制代码地址:   0x00  0x01  0x02  0x03</span><br><span class="line">值:     0x78  0x56  0x34  0x12</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为什么字节序很重要"><a href="#为什么字节序很重要" class="headerlink" title="为什么字节序很重要"></a>为什么字节序很重要</h3><p>在多字节数据传输或跨平台交互时，字节序的不同可能导致数据解释错误。例如，一个大端序系统发送数据到一个小端序系统，如果不做任何处理，小端序系统可能会错误地解读数据内容。</p>
<h3 id="字节序的处理"><a href="#字节序的处理" class="headerlink" title="字节序的处理"></a>字节序的处理</h3><ol>
<li><strong>网络字节序</strong>：网络协议（如TCP&#x2F;IP）通常规定使用大端序，这被称为网络字节序（Network Byte Order）。</li>
<li><strong>字节序转换函数</strong>：大多数编程语言提供了用于字节序转换的函数。例如，在C语言中，<code>htons</code>（Host TO Network Short）、<code>htonl</code>（Host TO Network Long）、<code>ntohs</code>（Network TO Host Short）、<code>ntohl</code>（Network TO Host Long）等函数用于在主机字节序和网络字节序之间进行转换。</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p><strong>C语言中的字节序处理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c复制代码#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">void print_bytes(uint32_t value) &#123;</span><br><span class="line">    uint8_t *bytes = (uint8_t *)&amp;value;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        printf(&quot;%02x &quot;, bytes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    uint32_t host_value = 0x12345678; // 主机字节序</span><br><span class="line">    uint32_t network_value = htonl(host_value); // 转换为网络字节序（大端序）</span><br><span class="line"></span><br><span class="line">    printf(&quot;Host byte order: &quot;);</span><br><span class="line">    print_bytes(host_value); // 打印主机字节序</span><br><span class="line"></span><br><span class="line">    printf(&quot;Network byte order: &quot;);</span><br><span class="line">    print_bytes(network_value); // 打印网络字节序</span><br><span class="line"></span><br><span class="line">    uint32_t converted_back = ntohl(network_value); // 转换回主机字节序</span><br><span class="line">    printf(&quot;Converted back to host byte order: &quot;);</span><br><span class="line">    print_bytes(converted_back); // 打印转换回的主机字节序</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vbnet复制代码Host byte order: 78 56 34 12 </span><br><span class="line">Network byte order: 12 34 56 78 </span><br><span class="line">Converted back to host byte order: 78 56 34 12 </span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>字节序在计算机内存中存储多字节数据时非常重要。理解和处理字节序问题，特别是在跨平台或网络通信中，确保数据正确传输和解释是至关重要的。通过明确协议中的字节序和使用合适的字节序转换函数，可以避免数据传输中的错误。</p>
</blockquote>
<h3 id="规则4-3-严禁使用未经初始化的变量作为右值。"><a href="#规则4-3-严禁使用未经初始化的变量作为右值。" class="headerlink" title="规则4.3 严禁使用未经初始化的变量作为右值。"></a>规则4.3 严禁使用未经初始化的变量作为右值。</h3><h2 id="建议-4"><a href="#建议-4" class="headerlink" title="建议"></a>建议</h2><h3 id="建议4-1-构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。"><a href="#建议4-1-构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。" class="headerlink" title="建议4.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。"></a>建议4.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。</h3><h3 id="建议4-2-使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。"><a href="#建议4-2-使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。" class="headerlink" title="建议4.2 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。"></a>建议4.2 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。</h3><h3 id="建议4-3-在首次使用前初始化变量，初始化的地方离使用的地方越近越好。建议4-3-在首次使用前初始化变量，初始化的地方离使用的地方越近越好。"><a href="#建议4-3-在首次使用前初始化变量，初始化的地方离使用的地方越近越好。建议4-3-在首次使用前初始化变量，初始化的地方离使用的地方越近越好。" class="headerlink" title="建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。"></a>建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。</h3><h3 id="建议4-4-明确全局变量的初始化顺序，避免跨模块的初始化依赖。"><a href="#建议4-4-明确全局变量的初始化顺序，避免跨模块的初始化依赖。" class="headerlink" title="建议4.4 明确全局变量的初始化顺序，避免跨模块的初始化依赖。"></a>建议4.4 明确全局变量的初始化顺序，避免跨模块的初始化依赖。</h3><h3 id="建议4-5-尽量减少没有必要的数据类型默认转换与强制转换。"><a href="#建议4-5-尽量减少没有必要的数据类型默认转换与强制转换。" class="headerlink" title="建议4.5 尽量减少没有必要的数据类型默认转换与强制转换。"></a>建议4.5 尽量减少没有必要的数据类型默认转换与强制转换。</h3><h1 id="宏、常量"><a href="#宏、常量" class="headerlink" title="宏、常量"></a>宏、常量</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="规则-6"><a href="#规则-6" class="headerlink" title="规则"></a>规则</h2><h3 id="规则5-1-用宏定义表达式时，要使用完备的括号。"><a href="#规则5-1-用宏定义表达式时，要使用完备的括号。" class="headerlink" title="规则5.1 用宏定义表达式时，要使用完备的括号。"></a>规则5.1 用宏定义表达式时，要使用完备的括号。</h3><h3 id="规则5-2-将宏所定义的多条表达式放在大括号中。"><a href="#规则5-2-将宏所定义的多条表达式放在大括号中。" class="headerlink" title="规则5.2 将宏所定义的多条表达式放在大括号中。"></a>规则5.2 将宏所定义的多条表达式放在大括号中。</h3><h3 id="规则5-3-使用宏时，不允许参数发生变化。"><a href="#规则5-3-使用宏时，不允许参数发生变化。" class="headerlink" title="规则5.3 使用宏时，不允许参数发生变化。"></a>规则5.3 使用宏时，不允许参数发生变化。</h3><h3 id="规则5-4-不允许直接使用魔鬼数字。"><a href="#规则5-4-不允许直接使用魔鬼数字。" class="headerlink" title="规则5.4 不允许直接使用魔鬼数字。"></a>规则5.4 不允许直接使用魔鬼数字。</h3><p>说明：使用魔鬼数字的弊端：代码难以理解；如果一个有含义的数字多处使用，一旦需要修改这个数值，代价惨重。</p>
<h2 id="建议-5"><a href="#建议-5" class="headerlink" title="建议"></a>建议</h2><h3 id="建议5-1-除非必要，应尽可能使用函数代替宏。"><a href="#建议5-1-除非必要，应尽可能使用函数代替宏。" class="headerlink" title="建议5.1 除非必要，应尽可能使用函数代替宏。"></a>建议5.1 除非必要，应尽可能使用函数代替宏。</h3><h3 id="建议5-2-常量建议使用const定义代替宏。"><a href="#建议5-2-常量建议使用const定义代替宏。" class="headerlink" title="建议5.2 常量建议使用const定义代替宏。"></a>建议5.2 常量建议使用const定义代替宏。</h3><h3 id="建议5-3-宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。"><a href="#建议5-3-宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。" class="headerlink" title="建议5.3 宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。"></a>建议5.3 宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。</h3><h1 id="质量保证"><a href="#质量保证" class="headerlink" title="质量保证"></a>质量保证</h1><p><strong>to be continued</strong></p>
<h1 id="程序效率"><a href="#程序效率" class="headerlink" title="程序效率"></a>程序效率</h1><p><strong>to be continued</strong></p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><strong>to be continued</strong></p>
<h1 id="排版与格式"><a href="#排版与格式" class="headerlink" title="排版与格式"></a>排版与格式</h1><p><strong>to be continued</strong></p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>C/C++</tag>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title>0.96OLED玩法</title>
    <url>/2024/05/14/0-96OLED%E7%8E%A9%E6%B3%95/</url>
    <content><![CDATA[<p>基于0.96寸OLED，主控ssd1306</p>
<h1 id="显示原理"><a href="#显示原理" class="headerlink" title="显示原理"></a>显示原理</h1><p>基于数据手册</p>
<h2 id="硬件特性"><a href="#硬件特性" class="headerlink" title="硬件特性"></a>硬件特性</h2><p>每个像素点独立控制，通过写入现存的二进制数据进行每个像素的熄灭和点亮</p>
<ul>
<li><p>像素</p>
<p>  <strong>128*64</strong></p>
</li>
</ul>
<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0.96 OLED</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">|********************************|</span></span><br><span class="line"><span class="string">|********************************|</span></span><br><span class="line"><span class="string">|********************************|</span></span><br><span class="line"><span class="string">|********************************|</span></span><br><span class="line"><span class="string">|********************************|</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 模拟图</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SEG</li>
</ul>
<p>相当于一列：一列<strong>64</strong>个像素</p>
<ul>
<li>COLOMN</li>
</ul>
<p>相当于一行：一行<strong>128</strong>个像素</p>
<ul>
<li>COMMON</li>
</ul>
<p>相当于一行：一行<strong>128</strong>个像素</p>
<ul>
<li>PAGE</li>
</ul>
<p>相当于8行：<strong>128*8</strong>个像素</p>
<h2 id="显示方式（ssd1306）"><a href="#显示方式（ssd1306）" class="headerlink" title="显示方式（ssd1306）"></a>显示方式（ssd1306）</h2><blockquote>
<p>There are 3 different memory addressing mode in SSD1306: page addressing mode, horizontal addressing mode and vertical addressing mode. </p>
</blockquote>
<h3 id="1-page-addressing-mode-页地址模式"><a href="#1-page-addressing-mode-页地址模式" class="headerlink" title="1. page addressing mode(页地址模式)"></a>1. page addressing mode(页地址模式)</h3><blockquote>
<p>Page addressing mode (A[1:0]&#x3D;10xb) </p>
<p>In page addressing mode, after the display RAM is read&#x2F;written, the column address pointer is increased automatically by 1. </p>
<p>If the column address pointer reaches column end address, the column address pointer is reset to column start address and &#x3D;&#x3D;page address pointer is not changed.&#x3D;&#x3D; </p>
<p>Users have to set the new page and column addresses in order to access the next page RAM content The sequence of movement of the PAGE and column address point for page addressing mode is shown in Figure 10-1. </p>
</blockquote>
<p><img src="/images/OLED/1.png" alt="page addressing mode"></p>
<p>一次写<code>1Byte(8位)</code>，与<code>horizontal addressing mode</code>的区别只是<strong>PAGE是否自动改变</strong></p>
<h3 id="2-horizontal-addressing-mode-水平地址模式"><a href="#2-horizontal-addressing-mode-水平地址模式" class="headerlink" title="2.horizontal addressing mode(水平地址模式)"></a>2.horizontal addressing mode(水平地址模式)</h3><blockquote>
<p>Horizontal addressing mode (A[1:0]&#x3D;00b)</p>
<p>In horizontal addressing mode, after the display RAM is read&#x2F;written, the column address pointer is increased automatically by 1. </p>
<p>If the column address pointer reaches column end address, the column address pointer is reset to column start address and &#x3D;&#x3D;page address pointer is increased by 1&#x3D;&#x3D;. </p>
<p>The sequence of movement of the page and column address point for horizontal addressing mode is shown in Figure 10-3. </p>
<p>When both column and page address pointers reach the end address, the pointers are reset to column start address and page start address (Dotted line in Figure 10-3.) </p>
</blockquote>
<p><img src="/images/OLED/2.png" alt="horizontal addressing mode"></p>
<p>一次写<code>1Byte(8位)</code></p>
<h3 id="3-vertical-addressing-mode-垂直地址模式"><a href="#3-vertical-addressing-mode-垂直地址模式" class="headerlink" title="3.vertical addressing mode(垂直地址模式)"></a>3.vertical addressing mode(垂直地址模式)</h3><blockquote>
<p>Vertical addressing mode: (A[1:0]&#x3D;01b)</p>
<p>In vertical addressing mode, after the display RAM is read&#x2F;written, the page address pointer is increased automatically by 1. </p>
<p>If the page address pointer reaches the page end address, &#x3D;&#x3D;the page address pointer is reset&#x3D;&#x3D; to page start address and column address pointer is increased by 1. </p>
<p>The sequence of movement of the page and column address point for vertical addressing mode is shown in Figure 10-4. </p>
<p>When both column and page address pointers reach the end address, the pointers are reset to column start address and page start address </p>
<p>(Dotted line in Figure 10-4.) </p>
</blockquote>
<p><img src="/images/OLED/3.png" alt="vertical addressing mode"></p>
<h3 id="总结-我的理解"><a href="#总结-我的理解" class="headerlink" title="总结(我的理解)"></a>总结(我的理解)</h3><p>三种模式都是一次竖着写<code>1Byte(8位)</code>，</p>
<ol>
<li>第一种向右延伸，到终点不回来</li>
<li>第二种向右延伸，到终点自动回来并+1到下一行</li>
<li>第三种向下延伸，到终点COL自动+1到下一列</li>
</ol>
<h1 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h1><h2 id="1-显示基本ASCII"><a href="#1-显示基本ASCII" class="headerlink" title="1.显示基本ASCII"></a>1.显示基本ASCII</h2><h2 id="2-显示中文"><a href="#2-显示中文" class="headerlink" title="2.显示中文"></a>2.显示中文</h2><h2 id="3-显示BMP位图"><a href="#3-显示BMP位图" class="headerlink" title="3.显示BMP位图"></a>3.显示BMP位图</h2>]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>STM32</tag>
        <tag>project</tag>
        <tag>notes</tag>
        <tag>IIC</tag>
        <tag>OLED</tag>
      </tags>
  </entry>
  <entry>
    <title>一行代码搭建私有云（基于docker NextCloud）</title>
    <url>/2024/05/15/%E7%A7%81%E6%9C%89%E4%BA%91%E6%90%AD%E5%BB%BA_NextCloud/</url>
    <content><![CDATA[<h1 id="一行代码搭建私有云（基于docker-NextCloud）"><a href="#一行代码搭建私有云（基于docker-NextCloud）" class="headerlink" title="一行代码搭建私有云（基于docker NextCloud）"></a>一行代码搭建私有云（基于docker NextCloud）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​	老早以前就很想有一朵属于自己的云了，机缘巧合发现了<strong>NextCloud</strong>	这个项目，使用Docker一键部署简直不要太简单！    </p>
<p>​	项目地址：	<a href="https://github.com/nextcloud/docker">NextCloud repo on github</a><br>​	搭完以后再也没有用过文件传输助手，多平台文件传输秒传。太厉害了。<br>​	开源不易，感谢大佬</p>
<h2 id="一行代码"><a href="#一行代码" class="headerlink" title="一行代码"></a>一行代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:80 nextcloud</span><br></pre></td></tr></table></figure>

<p>然后直接<code>IP:8080</code>就访问到了</p>
<p><img src="/images/nc/1.png" alt="1"></p>
<p><img src="/images/nc/2.png" alt="2"></p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>docker</tag>
        <tag>私有云</tag>
        <tag>Linux</tag>
        <tag>NextCloud</tag>
        <tag>云盘</tag>
        <tag>跨平台</tag>
        <tag>github项目</tag>
      </tags>
  </entry>
  <entry>
    <title>MPU6050 basic (based on arduino)</title>
    <url>/2024/05/19/MPU6050-basic-based-on-arduino/</url>
    <content><![CDATA[<h1 id="MPU6050简介"><a href="#MPU6050简介" class="headerlink" title="MPU6050简介"></a>MPU6050简介</h1><p>The MPU-6050 is the world’s first and only 6-axis motion tracking devices designed for the low power, low cost, and high performance requirements of smartphones, tablets and wearable sensors.</p>
<h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><ul>
<li>BlurFree™ technology (for Video&#x2F;Still Image Stabilization)</li>
<li>AirSign™ technology (for Security&#x2F;Authentication)</li>
<li>TouchAnywhere™ technology (for “no touch” UI Application Control&#x2F;Navigation) </li>
<li>MotionCommand™ technology (for Gesture Short-cuts) </li>
<li>Motion-enabled game and application framework </li>
<li>InstantGesture™ iG™ gesture recognition </li>
<li>Location based services, points of interest, and dead reckoning </li>
<li>Handset and portable gaming </li>
<li>Motion-based game controllers </li>
<li>3D remote controls for Internet connected DTVs and set top boxes, 3D mice </li>
<li>Wearable sensors for health, fitness and sports  </li>
<li>Toys</li>
</ul>
<h1 id="Arduino案例"><a href="#Arduino案例" class="headerlink" title="Arduino案例"></a>Arduino案例</h1><p>​	Arduino使用现成的库很容易上手。</p>
<h2 id="使用Arduino进行获取数据"><a href="#使用Arduino进行获取数据" class="headerlink" title="使用Arduino进行获取数据"></a>使用Arduino进行获取数据</h2><ol>
<li>使用IIC进行通信</li>
<li>使用Wire库</li>
</ol>
<p><img src="/images/MPU6050/1.png" alt="row data"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mpuAddress= <span class="number">0x68</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> accelX, accelY, accelZ;<span class="comment">//xyz方向的加速度</span></span><br><span class="line"><span class="type">float</span> gForceX, gForceY, gForceZ;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> gyroX, gyroY, gyroZ;</span><br><span class="line"><span class="type">float</span> rotX, rotY, rotZ;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> tmpDataX, tmpDataY, tmpDataZ;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Wire.begin();</span><br><span class="line">  setupMPU();</span><br><span class="line">  pinMode(<span class="number">3</span>, OUTPUT);</span><br><span class="line">  pinMode(<span class="number">5</span>, OUTPUT);</span><br><span class="line">  pinMode(<span class="number">6</span>, OUTPUT);</span><br><span class="line">  pinMode(<span class="number">9</span>, OUTPUT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//testOfThefourPins();//okay</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  recordAccelRegisters();</span><br><span class="line">  recordGyroRegisters();</span><br><span class="line">  printData();</span><br><span class="line">  connecMPU6050WithLed();</span><br><span class="line">  <span class="comment">//printTmpData();</span></span><br><span class="line">  delay(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">connecMPU6050WithLed</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(rotX&gt;<span class="number">0</span>) analogWrite(<span class="number">3</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="keyword">else</span> analogWrite(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(rotY&gt;<span class="number">0</span>) analogWrite(<span class="number">5</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="keyword">else</span> analogWrite(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(rotZ&gt;<span class="number">0</span>) analogWrite(<span class="number">6</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="keyword">else</span> analogWrite(<span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testOfThefourPins</span><span class="params">()</span> &#123;</span><br><span class="line">  analogWrite(<span class="number">3</span>, <span class="number">255</span>);</span><br><span class="line">  analogWrite(<span class="number">5</span>, <span class="number">255</span>);</span><br><span class="line">  analogWrite(<span class="number">6</span>, <span class="number">255</span>);</span><br><span class="line">  analogWrite(<span class="number">9</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setupMPU</span><span class="params">()</span> &#123;</span><br><span class="line">  Wire.beginTransmission(mpuAddress);  <span class="comment">//This is the I2C address of the MPU (b1101000/b1101001 for AC0 low/high datasheet sec. 9.2)</span></span><br><span class="line">  Wire.write(<span class="number">0x6B</span>);                   <span class="comment">//Accessing the register 6B - Power Management (Sec. 4.28)</span></span><br><span class="line">  Wire.write(<span class="number">0b00000000</span>);             <span class="comment">//Setting SLEEP register to 0. (Required; see Note on p. 9)</span></span><br><span class="line">  Wire.endTransmission();</span><br><span class="line">  Wire.beginTransmission(mpuAddress);  <span class="comment">//I2C address of the MPU</span></span><br><span class="line">  Wire.write(<span class="number">0x1B</span>);                   <span class="comment">//Accessing the register 1B - Gyroscope Configuration (Sec. 4.4)</span></span><br><span class="line">  Wire.write(<span class="number">0x00000000</span>);             <span class="comment">//Setting the gyro to full scale +/- 250deg./s</span></span><br><span class="line">  Wire.endTransmission();</span><br><span class="line">  Wire.beginTransmission(mpuAddress);  <span class="comment">//I2C address of the MPU</span></span><br><span class="line">  Wire.write(<span class="number">0x1C</span>);                   <span class="comment">//Accessing the register 1C - Acccelerometer Configuration (Sec. 4.5)</span></span><br><span class="line">  Wire.write(<span class="number">0b00000000</span>);             <span class="comment">//Setting the accel to +/- 2g</span></span><br><span class="line">  Wire.endTransmission();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recordAccelRegisters</span><span class="params">()</span> &#123;</span><br><span class="line">  Wire.beginTransmission(mpuAddress);  <span class="comment">//I2C address of the MPU</span></span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);                   <span class="comment">//Starting register for Accel Readings</span></span><br><span class="line">  Wire.endTransmission();</span><br><span class="line">  Wire.requestFrom(mpuAddress, <span class="number">6</span>);  <span class="comment">//Request Accel Registers (3B - 40)</span></span><br><span class="line">  <span class="keyword">while</span> (Wire.available() &lt; <span class="number">6</span>)</span><br><span class="line">    ;</span><br><span class="line">  accelX = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();  <span class="comment">//Store first two bytes into accelX</span></span><br><span class="line">  accelY = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();  <span class="comment">//Store middle two bytes into accelY</span></span><br><span class="line">  accelZ = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();  <span class="comment">//Store last two bytes into accelZ</span></span><br><span class="line">  tmpDataX = accelX;</span><br><span class="line">  tmpDataY = accelY;</span><br><span class="line">  tmpDataZ = accelZ;</span><br><span class="line">  processAccelData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">processAccelData</span><span class="params">()</span> &#123;</span><br><span class="line">  gForceX = accelX / <span class="number">16384.0</span>;</span><br><span class="line">  gForceY = accelY / <span class="number">16384.0</span>;</span><br><span class="line">  gForceZ = accelZ / <span class="number">16384.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recordGyroRegisters</span><span class="params">()</span> &#123;</span><br><span class="line">  Wire.beginTransmission(mpuAddress);  <span class="comment">//I2C address of the MPU</span></span><br><span class="line">  Wire.write(<span class="number">0x43</span>);                   <span class="comment">//Starting register for Gyro Readings</span></span><br><span class="line">  Wire.endTransmission();</span><br><span class="line">  Wire.requestFrom(mpuAddress, <span class="number">6</span>);  <span class="comment">//Request Gyro Registers (43 - 48)</span></span><br><span class="line">  <span class="keyword">while</span> (Wire.available() &lt; <span class="number">6</span>)</span><br><span class="line">    ;</span><br><span class="line">  gyroX = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();  <span class="comment">//Store first two bytes into accelX</span></span><br><span class="line">  gyroY = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();  <span class="comment">//Store middle two bytes into accelY</span></span><br><span class="line">  gyroZ = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();  <span class="comment">//Store last two bytes into accelZ</span></span><br><span class="line">  processGyroData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">processGyroData</span><span class="params">()</span> &#123;</span><br><span class="line">  rotX = gyroX / <span class="number">131.0</span>;</span><br><span class="line">  rotY = gyroY / <span class="number">131.0</span>;</span><br><span class="line">  rotZ = gyroZ / <span class="number">131.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printData</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.print(<span class="string">&quot;Gyro (deg)&quot;</span>);</span><br><span class="line">  Serial.print(<span class="string">&quot; X=&quot;</span>);</span><br><span class="line">  Serial.print(rotX);</span><br><span class="line">  Serial.print(<span class="string">&quot; Y=&quot;</span>);</span><br><span class="line">  Serial.print(rotY);</span><br><span class="line">  Serial.print(<span class="string">&quot; Z=&quot;</span>);</span><br><span class="line">  Serial.print(rotZ);</span><br><span class="line">  Serial.print(<span class="string">&quot; Accel (g)&quot;</span>);</span><br><span class="line">  Serial.print(<span class="string">&quot; X=&quot;</span>);</span><br><span class="line">  Serial.print(gForceX);</span><br><span class="line">  Serial.print(<span class="string">&quot; Y=&quot;</span>);</span><br><span class="line">  Serial.print(gForceY);</span><br><span class="line">  Serial.print(<span class="string">&quot; Z=&quot;</span>);</span><br><span class="line">  Serial.println(gForceZ);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printTmpData</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.print(tmpDataX);</span><br><span class="line">  Serial.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">  Serial.print(tmpDataY);</span><br><span class="line">  Serial.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">  Serial.print(tmpDataZ);</span><br><span class="line">  Serial.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="使用Arduino进行姿态解算"><a href="#使用Arduino进行姿态解算" class="headerlink" title="使用Arduino进行姿态解算"></a>使用Arduino进行姿态解算</h2><ol>
<li><p>使用卡尔曼滤波进行提高数据精准度</p>
</li>
<li><p>需要进行一些数学计算</p>
<p> <img src="/images/MPU6050/2.png" alt="pitch Roll "></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Kalman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> fRad2Deg = <span class="number">57.295779513f</span>; <span class="comment">//将弧度转为角度的乘数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">//MPU-6050的I2C地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nValCnt = <span class="number">7</span>; <span class="comment">//一次读取寄存器的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nCalibTimes = <span class="number">1000</span>; <span class="comment">//校准时读数的次数</span></span><br><span class="line"><span class="type">int</span> calibData[nValCnt]; <span class="comment">//校准数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nLastTime = <span class="number">0</span>; <span class="comment">//上一次读数的时间</span></span><br><span class="line"><span class="type">float</span> fLastRoll = <span class="number">0.0f</span>; <span class="comment">//上一次滤波得到的Roll角</span></span><br><span class="line"><span class="type">float</span> fLastPitch = <span class="number">0.0f</span>; <span class="comment">//上一次滤波得到的Pitch角</span></span><br><span class="line">Kalman kalmanRoll; <span class="comment">//Roll角滤波器</span></span><br><span class="line">Kalman kalmanPitch; <span class="comment">//Pitch角滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>); <span class="comment">//初始化串口，指定波特率</span></span><br><span class="line">  Wire.begin(); <span class="comment">//初始化Wire库</span></span><br><span class="line">  WriteMPUReg(<span class="number">0x6B</span>, <span class="number">0</span>); <span class="comment">//启动MPU6050设备</span></span><br><span class="line"></span><br><span class="line">  Calibration(); <span class="comment">//执行校准</span></span><br><span class="line">  nLastTime = micros(); <span class="comment">//记录当前时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> readouts[nValCnt];</span><br><span class="line">  ReadAccGyr(readouts); <span class="comment">//读出测量值</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">float</span> realVals[<span class="number">7</span>];</span><br><span class="line">  Rectify(readouts, realVals); <span class="comment">//根据校准的偏移量进行纠正</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算加速度向量的模长，均以g为单位</span></span><br><span class="line">  <span class="type">float</span> fNorm = <span class="built_in">sqrt</span>(realVals[<span class="number">0</span>] * realVals[<span class="number">0</span>] + realVals[<span class="number">1</span>] * realVals[<span class="number">1</span>] + realVals[<span class="number">2</span>] * realVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fRoll = GetRoll(realVals, fNorm); <span class="comment">//计算Roll角</span></span><br><span class="line">  <span class="keyword">if</span> (realVals[<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    fRoll = -fRoll;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">float</span> fPitch = GetPitch(realVals, fNorm); <span class="comment">//计算Pitch角</span></span><br><span class="line">  <span class="keyword">if</span> (realVals[<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    fPitch = -fPitch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算两次测量的时间间隔dt，以秒为单位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nCurTime = micros();</span><br><span class="line">  <span class="type">float</span> dt = (<span class="type">double</span>)(nCurTime - nLastTime) / <span class="number">1000000.0</span>;</span><br><span class="line">  <span class="comment">//对Roll角和Pitch角进行卡尔曼滤波</span></span><br><span class="line">  <span class="type">float</span> fNewRoll = kalmanRoll.getAngle(fRoll, realVals[<span class="number">4</span>], dt);</span><br><span class="line">  <span class="type">float</span> fNewPitch = kalmanPitch.getAngle(fPitch, realVals[<span class="number">5</span>], dt);</span><br><span class="line">  <span class="comment">//跟据滤波值计算角度速</span></span><br><span class="line">  <span class="type">float</span> fRollRate = (fNewRoll - fLastRoll) / dt;</span><br><span class="line">  <span class="type">float</span> fPitchRate = (fNewPitch - fLastPitch) / dt;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//更新Roll角和Pitch角</span></span><br><span class="line">  fLastRoll = fNewRoll;</span><br><span class="line">  fLastPitch = fNewPitch;</span><br><span class="line">  <span class="comment">//更新本次测的时间</span></span><br><span class="line">  nLastTime = nCurTime;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向串口打印输出Roll角和Pitch角，运行时在Arduino的串口监视器中查看</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Roll:&quot;</span>);</span><br><span class="line">  Serial.print(fNewRoll); Serial.print(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">  Serial.print(fRollRate); Serial.print(<span class="string">&quot;),\tPitch:&quot;</span>);</span><br><span class="line">  Serial.print(fNewPitch); Serial.print(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">  Serial.print(fPitchRate); Serial.print(<span class="string">&quot;)\n&quot;</span>);</span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MPU6050写入一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址与一个字节的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteMPUReg</span><span class="params">(<span class="type">int</span> nReg, <span class="type">unsigned</span> <span class="type">char</span> nVal)</span> &#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.write(nVal);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址，返回读出的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ReadMPUReg</span><span class="params">(<span class="type">int</span> nReg)</span> &#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出加速度计三个分量、温度和三个角速度计</span></span><br><span class="line"><span class="comment">//保存在指定的数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadAccGyr</span><span class="params">(<span class="type">int</span> *pVals)</span> &#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.requestFrom(MPU, nValCnt * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i) &#123;</span><br><span class="line">    pVals[i] = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对大量读数进行统计，校准平均偏移量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Calibration</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> valSums[<span class="number">7</span>] = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">  <span class="comment">//先求和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCalibTimes; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> mpuVals[nValCnt];</span><br><span class="line">    ReadAccGyr(mpuVals);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nValCnt; ++j) &#123;</span><br><span class="line">      valSums[j] += mpuVals[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//再求平均</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i) &#123;</span><br><span class="line">    calibData[i] = <span class="type">int</span>(valSums[i] / nCalibTimes);</span><br><span class="line">  &#125;</span><br><span class="line">  calibData[<span class="number">2</span>] += <span class="number">16384</span>; <span class="comment">//设芯片Z轴竖直向下，设定静态工作点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算得Roll角。算法见文档。</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetRoll</span><span class="params">(<span class="type">float</span> *pRealVals, <span class="type">float</span> fNorm)</span> &#123;</span><br><span class="line">  <span class="type">float</span> fNormXZ = <span class="built_in">sqrt</span>(pRealVals[<span class="number">0</span>] * pRealVals[<span class="number">0</span>] + pRealVals[<span class="number">2</span>] * pRealVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fCos = fNormXZ / fNorm;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">acos</span>(fCos) * fRad2Deg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算得Pitch角。算法见文档。</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetPitch</span><span class="params">(<span class="type">float</span> *pRealVals, <span class="type">float</span> fNorm)</span> &#123;</span><br><span class="line">  <span class="type">float</span> fNormYZ = <span class="built_in">sqrt</span>(pRealVals[<span class="number">1</span>] * pRealVals[<span class="number">1</span>] + pRealVals[<span class="number">2</span>] * pRealVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fCos = fNormYZ / fNorm;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">acos</span>(fCos) * fRad2Deg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读数进行纠正，消除偏移，并转换为物理量。公式见文档。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rectify</span><span class="params">(<span class="type">int</span> *pReadout, <span class="type">float</span> *pRealVals)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">16384.0f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pRealVals[<span class="number">3</span>] = pReadout[<span class="number">3</span>] / <span class="number">340.0f</span> + <span class="number">36.53</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">131.0f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>project</tag>
        <tag>notes</tag>
        <tag>IIC</tag>
        <tag>arduino</tag>
        <tag>MPU6050</tag>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 SPI with 0.96 OLED</title>
    <url>/2024/05/19/STM32-SPI-with-0-96-OLED/</url>
    <content><![CDATA[<h1 id="SPI协议"><a href="#SPI协议" class="headerlink" title="SPI协议"></a>SPI协议</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://regenm.github.io/2024/01/29/%E5%B8%B8%E8%A7%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/">点击跳转</a></p>
<p>​	SPI有主、从两种模式，通常由一个主模块和一个或多个从模块组成（SPI不支持多主机），主模块选择一个从模块进行同步通信，从而完成数据的交换。<strong>提供时钟的为主设备</strong>（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起，当存在多个从设备时，通过各自的片选信号进行管理。</p>
<h3 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h3><ol>
<li><strong>MISO</strong>（ Master Input Slave Output）：主设备数据输入，从设备数据输出；</li>
<li><strong>MOSI</strong>（Master Output Slave Input）：主设备数据输出，从设备数据输入；</li>
<li><strong>SCLK</strong>（Serial Clock）：时钟信号，由主设备产生；</li>
<li><strong>CS&#x2F;SS</strong>（Chip Select&#x2F;Slave Select）：从设备使能信号，由主设备控制，一主多从时，CS&#x2F;SS是从芯片是否被主芯片选中的控制信号，只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。</li>
</ol>
<h2 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h2><p>SPI主设备和从设备都有一个串行移位寄存器，一次传输为8位。</p>
<h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><ol>
<li>主设备发起信号，将CS&#x2F;SS拉低，启动通信。</li>
<li>主设备通过发送时钟信号，来告诉从设备进行写数据或者读数据操作（采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低）），它将立即读取数据线上的信号，这样就得到了一位数据（1bit）。</li>
<li>主机（Master）将要发送的数据写到发送数据缓存区（Menory），缓存区经过移位寄存器（缓存长度不一定，看单片机配置），串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。</li>
<li>从机（Slave）也将自己的串行移位寄存器（缓存长度不一定，看单片机配置）中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。</li>
</ol>
<h2 id="STM32实现（使用0-96Oled）"><a href="#STM32实现（使用0-96Oled）" class="headerlink" title="STM32实现（使用0.96Oled）"></a>STM32实现（使用0.96Oled）</h2><h3 id="0-96Oled引脚介绍"><a href="#0-96Oled引脚介绍" class="headerlink" title="0.96Oled引脚介绍"></a>0.96Oled引脚介绍</h3><ol>
<li>GND	 &lt;—&gt;    电源地</li>
<li>VCC      &lt;—&gt;   电源正（3～5.5V）</li>
<li>D0(SCL) &lt;—&gt;  SCK管脚</li>
<li>D1(SDA) &lt;—&gt;   MOSI管脚</li>
<li>RES(RST) &lt;—&gt;用来复位（低电平复位）</li>
<li>DC(D&#x2F;C) &lt;—&gt;   数据和命令控制管脚 1表示数据 0表示命令</li>
<li>CS(NSS) &lt;—&gt;  片选管脚</li>
</ol>
]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>STM32</tag>
        <tag>project</tag>
        <tag>notes</tag>
        <tag>OLED</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>塘下公路片</title>
    <url>/2024/05/19/%E5%A1%98%E4%B8%8B%E5%85%AC%E8%B7%AF%E7%89%87/</url>
    <content><![CDATA[<p>​	比起繁华的钢铁丛林，我还是性本爱丘山。在塘下公路骑行是一种很奇妙的体验，就好步入桃花源记，在一群群高楼大厦中站立的两排密集的大树，让长久受到屏幕自己的眼镜也得到了放松。</p>
<p><img src="/images/tangxia_road/Nikon2023_5_3_332023_6_1360.jpg" alt="boring screens"></p>
<p><img src="/images/tangxia_road/Nikon2023_5_3_332023_6_1361.jpg" alt="Green Road"></p>
<p><img src="/images/tangxia_road/Nikon2023_5_3_332023_6_1362.jpg" alt="Green Road"></p>
<p><img src="/images/tangxia_road/Nikon2023_5_3_332023_6_1363.jpg" alt="Green Road"></p>
<p>​	自从知道了塘下公路以后，我再没去过别的地方骑行。每次骑行都很兴奋，有时感觉回到了家乡，有时感觉在国外一般。真的很喜欢这条路两边的树。恰到好处的遮了大半边天空，只留下一条光路延伸到远方。</p>
<p><img src="/images/tangxia_road/Nikon2023_5_3_332023_6_1366.jpg" alt="Trees"></p>
<p><img src="/images/tangxia_road/Nikon2023_5_3_332023_6_1368.jpg" alt="Trees"></p>
<p>​	在路边发现了一只孤独的椅子，白色的墙与周围有稍许违和感，有一种很清新的感觉，同时还有一种苔痕上阶绿，草色入帘青的感觉。</p>
<p><img src="/images/tangxia_road/Nikon2023_5_3_332023_6_1364.jpg" alt="lonely chair"></p>
<p><img src="/images/tangxia_road/Nikon2023_5_3_332023_6_1365.jpg" alt="lonely chair"></p>
<p>这应该就是治愈内耗的良药了吧。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>摄影</tag>
        <tag>photo</tag>
        <tag>公路旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>苏州行</title>
    <url>/2024/05/19/%E8%8B%8F%E5%B7%9E%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="平江路"><a href="#平江路" class="headerlink" title="平江路"></a>平江路</h1><p>苏州-＞平江路。<br>     初见时是辰时，庆幸自己通宵到五点后直奔平江路。若是晚一两个时辰则是截然不同的人山人海。<br>     此时摇船还未开始 河面平静,水波不兴.阳光刚开始洒入这条小街.江南古街的倒影跃然水面，沿着主街直走,我的眼光全在黑白灰的建筑与绿色的树木和蓝色的天空和水面之间游走.这时的平江路尚未被外人所打搅,几对老翁坐在河旁的藤椅上,借着尚不刺眼的阳光看报,一切都显得与背景和谐。<br>     一个时辰不到这条小街就变得喧闹与繁忙.越来越多的女性穿着汉服，涌入这条小巷,或摆拍撒骄,或漫步于河边桥头.刚开始紧闭大门的店铺也逐渐开张,宁静典雅的小巷也就逐渐消失。<br>     我庆幸自己看到了平江路的本原面貌,也看到了她浓妆粉饰后的面貌.但我总觉得少了些东西,可能是恋人或朋友吧.下次带本散文书好了。</p>
<p><img src="/images/suzhou_trip/1.jpg" alt="lonely chair"><img src="/images/suzhou_trip/2.jpg" alt="lonely chair"><img src="/images/suzhou_trip/3.jpg" alt="lonely chair"><img src="/images/suzhou_trip/4.jpg" alt="lonely chair"><img src="/images/suzhou_trip/5.jpg" alt="lonely chair"><img src="/images/suzhou_trip/6.jpg" alt="lonely chair"><img src="/images/suzhou_trip/7.jpg" alt="lonely chair"><img src="/images/suzhou_trip/8.jpg" alt="lonely chair"><img src="/images/suzhou_trip/9.jpg" alt="lonely chair"><img src="/images/suzhou_trip/10.jpg" alt="lonely chair"></p>
]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>摄影</tag>
        <tag>photo</tag>
        <tag>苏州</tag>
      </tags>
  </entry>
  <entry>
    <title>M.2 STC89C52</title>
    <url>/2024/05/25/M-2-STC89C52/</url>
    <content><![CDATA[<p>​	最近在学画PCB的时候突发奇想，想利用M.2接口的易插拔特性来画一片51最小系统板，同时还引出了大部分引脚，外形类似于Arduino。第一版有点丑。</p>
<p><img src="/images/m251/1.png" alt="Schematic"></p>
<p><img src="/images/m251/2.png" alt="Pcb"></p>
<p><img src="/images/m251/3.png" alt="Pcb_3D"></p>
]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>51</tag>
        <tag>PCB</tag>
        <tag>项目</tag>
        <tag>最小系统</tag>
        <tag>M.2接口</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习笔记</title>
    <url>/2023/12/22/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>​	</p>
<p>CSS：Cascading Style Sheet 层叠样式表，是一组样式设置的规则，用于控制页面的外观样式。</p>
<p>广泛用于页面外观美化，布局和定位。</p>
</blockquote>
<h2 id="CSS如何使用"><a href="#CSS如何使用" class="headerlink" title="CSS如何使用"></a>CSS如何使用</h2><ul>
<li>嵌入HTML或者JSP</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-<span class="number">8</span>&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    <span class="selector-tag">p</span>&#123;</span><br><span class="line">      <span class="attribute">color</span>:blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>外部导入（常用，更加方便，便于复制黏贴 :D）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/eg<span class="selector-class">.css</span>&quot;&gt; </span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li>选择器：要修饰的对象，例如HTML的各类标签</li>
<li>属性名：属于修饰对象的属性</li>
<li>属性值：修饰对象的属性的样式取值</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    选择器&#123;</span><br><span class="line">      属性名：属性值;</span><br><span class="line">      属性名：属性值;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2>]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot+vue+mysql项目实训</title>
    <url>/2024/07/03/SpringBoot-vue-mysql%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD/</url>
    <content><![CDATA[<h2 id="常见的项目类型以及优缺点和应用范围"><a href="#常见的项目类型以及优缺点和应用范围" class="headerlink" title="常见的项目类型以及优缺点和应用范围"></a>常见的项目类型以及优缺点和应用范围</h2><ol>
<li><p><strong>Spring Boot + Vue + MySQL</strong></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>强大的后端支持</strong>：<ul>
<li><strong>Spring Boot</strong> 提供了成熟的后端框架和丰富的生态系统，包括依赖注入、数据访问、事务管理等功能，适合构建复杂的企业级应用。</li>
</ul>
</li>
<li><strong>灵活的前端开发</strong>：<ul>
<li><strong>Vue</strong> 是一个轻量级的前端框架，易于学习和上手，具有响应式数据绑定和组件化开发的优势，适合构建动态且高效的用户界面。</li>
</ul>
</li>
<li><strong>可靠的数据库</strong>：<ul>
<li><strong>MySQL</strong> 是一个广泛使用的开源关系型数据库管理系统，具有稳定性高、性能优越、支持大规模并发访问等特点，适合各种规模的应用。</li>
</ul>
</li>
<li><strong>全栈开发一体化</strong>：<ul>
<li>Spring Boot + Vue 的组合使得开发人员可以使用相似的语言和工具栈进行全栈开发，提高了开发效率和团队协作。</li>
</ul>
</li>
<li><strong>社区支持和文档丰富</strong>：<ul>
<li>Spring Boot 和 Vue 都拥有庞大的社区和丰富的文档资源，开发过程中能够快速获取到解决方案和技术支持。</li>
</ul>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>复杂的配置和学习曲线</strong>：<ul>
<li>Spring Boot 的配置和依赖管理相对复杂，需要一定的学习成本和经验来优化和调整项目。</li>
<li>Vue 虽然易于上手，但在复杂的单页应用中，需要深入理解其组件通信和状态管理等高级特性。</li>
</ul>
</li>
<li><strong>前后端分离的管理挑战</strong>：<ul>
<li>前后端分离架构需要额外的工作来管理跨团队和跨技术栈的协作，需要定义清晰的接口和数据传输方案。</li>
</ul>
</li>
<li><strong>数据库扩展性限制</strong>：<ul>
<li>虽然 MySQL 适合大多数应用场景，但在需要处理非结构化数据或需要高度扩展性的大规模应用中，可能需要考虑其他数据库解决方案。</li>
</ul>
</li>
</ol>
<h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><ul>
<li><strong>企业级应用</strong>：适用于需要高性能、高可扩展性和稳定性的企业级应用开发，如ERP系统、电子商务平台等。</li>
<li><strong>信息管理系统</strong>：能够处理大量结构化数据的信息管理系统，如客户关系管理（CRM）、人力资源管理（HRM）等。</li>
<li><strong>数据驱动型应用</strong>：适用于需要大量数据处理和复杂查询的应用，如数据分析平台、报表生成系统等。</li>
<li><strong>中小型项目</strong>：对于中小型项目来说，Spring Boot + Vue 提供了良好的开发体验和成本效益，能够快速构建并部署应用。</li>
</ul>
</li>
<li><p>Spring Boot + Angular + PostgreSQL</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>强大的后端框架</strong>：Spring Boot 提供了成熟且强大的企业级开发支持，尤其适用于大型项目。</li>
<li><strong>全面的前端框架</strong>：Angular 提供了完整的解决方案，适合构建复杂的单页应用，具有双向数据绑定和依赖注入等特性。</li>
<li><strong>强大的数据库</strong>：PostgreSQL 是一个功能强大的开源关系型数据库，支持复杂的查询和大数据处理。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>学习曲线</strong>：Angular 相比其他前端框架更为复杂，学习和掌握需要较长时间。</li>
<li><strong>配置复杂</strong>：Spring Boot 和 PostgreSQL 的配置和优化需要一定的经验和技术。</li>
</ul>
<h4 id="应用范围-1"><a href="#应用范围-1" class="headerlink" title="应用范围"></a>应用范围</h4><ul>
<li>适用于需要高性能和高可扩展性的企业级应用。</li>
<li>适用于需要复杂业务逻辑和数据处理的后台系统。</li>
<li>适用于需要构建复杂单页应用（SPA）的项目。</li>
</ul>
</li>
<li><p>Node.js + React + MongoDB</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>高性能的后端</strong>：Node.js 基于事件驱动和非阻塞I&#x2F;O模型，适合高并发和实时应用。</li>
<li><strong>灵活的前端框架</strong>：React 具有组件化开发模式和虚拟DOM，适合构建复杂和高性能的用户界面。</li>
<li><strong>灵活的数据库</strong>：MongoDB 是一种NoSQL数据库，适合处理大规模数据和快速开发。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>回调地狱</strong>：Node.js 的异步编程模型可能导致“回调地狱”，需要使用Promise或async&#x2F;await进行优化。</li>
<li><strong>数据一致性问题</strong>：MongoDB 在某些情况下可能会遇到数据一致性问题，需要注意数据的管理和维护。</li>
</ul>
<h4 id="应用范围-2"><a href="#应用范围-2" class="headerlink" title="应用范围"></a>应用范围</h4><ul>
<li>适用于需要高并发和实时性要求的应用，如聊天系统和实时通知。</li>
<li>适用于需要快速迭代和开发的Web应用和移动应用后端。</li>
<li>适用于处理大规模数据和非结构化数据的应用。</li>
</ul>
</li>
<li><p>Django + Angular + PostgreSQL</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>成熟的后端框架</strong>：Django 提供了快速开发和高效管理的优势，内置了管理后台、ORM等功能，适合快速构建Web应用。</li>
<li><strong>全面的前端框架</strong>：Angular 提供了完整的解决方案，适合构建复杂的单页应用，具有双向数据绑定和依赖注入等特性。</li>
<li><strong>强大的数据库</strong>：PostgreSQL 是一个功能强大的开源关系型数据库，支持复杂的查询和大数据处理。</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>学习曲线</strong>：Angular 相比其他前端框架更为复杂，学习和掌握需要较长时间。</li>
<li><strong>配置复杂</strong>：Django 的配置和优化需要一定的经验和技术。</li>
</ul>
<h4 id="应用范围-3"><a href="#应用范围-3" class="headerlink" title="应用范围"></a>应用范围</h4><ul>
<li>适用于需要快速开发和部署的Web应用。</li>
<li>适用于需要复杂业务逻辑和数据处理的后台系统。</li>
<li>适用于需要构建复杂单页应用（SPA）的项目。</li>
</ul>
</li>
<li><p>Flask + Vue + SQLite</p>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>轻量级后端框架</strong>：Flask 是一个轻量级的Web框架，灵活且易于上手，适合小型项目和原型开发。</li>
<li><strong>灵活的前端框架</strong>：Vue.js 易于上手，具有灵活的组件化开发模式，适合快速开发和构建响应式用户界面。</li>
<li><strong>轻量级数据库</strong>：SQLite 是一个嵌入式数据库，适合小型应用和测试环境。</li>
</ul>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>功能有限</strong>：Flask 相比Django等框架功能较少，适合简单和中小型项目。</li>
<li><strong>数据库限制</strong>：SQLite 不适合大规模和高并发的应用，性能和功能相对有限。</li>
</ul>
<h4 id="应用范围-4"><a href="#应用范围-4" class="headerlink" title="应用范围"></a>应用范围</h4><ul>
<li>适用于小型Web应用和原型开发。</li>
<li>适用于需要快速迭代和开发的项目。</li>
<li>适用于资源有限的应用和测试环境。</li>
</ul>
</li>
</ol>
<blockquote>
<h3 id="1-Angular"><a href="#1-Angular" class="headerlink" title="1. Angular"></a>1. Angular</h3><p><strong>Angular</strong> 是由Google开发和维护的一款前端框架，用于构建单页应用（SPA）和动态Web应用。它采用了TypeScript语言进行开发，提供了强大的组件化架构、数据绑定、依赖注入等功能，帮助开发人员更高效地构建复杂的用户界面和交互逻辑。</p>
<h3 id="2-PostgreSQL"><a href="#2-PostgreSQL" class="headerlink" title="2. PostgreSQL"></a>2. PostgreSQL</h3><p><strong>PostgreSQL</strong> 是一个强大的开源关系型数据库管理系统（RDBMS），具有高度的可扩展性、可靠性和丰富的功能集。它支持复杂的SQL查询、事务处理、触发器、视图等数据库特性，适合于处理大规模数据和复杂的数据操作。</p>
<h3 id="3-Node-js"><a href="#3-Node-js" class="headerlink" title="3. Node.js"></a>3. Node.js</h3><p><strong>Node.js</strong> 是一个基于Chrome V8引擎的JavaScript运行时环境，用于构建快速、可扩展的网络应用。Node.js采用事件驱动、非阻塞I&#x2F;O模型，适合于处理大量并发请求和实时应用，如Web服务器、API服务器等。</p>
<h3 id="4-React"><a href="#4-React" class="headerlink" title="4. React"></a>4. React</h3><p><strong>React</strong> 是由Facebook开发和维护的一款用于构建用户界面的JavaScript库。它采用组件化开发模式和虚拟DOM技术，使得开发人员能够高效地构建复杂的用户界面，实现数据与视图的高效同步更新。</p>
<h3 id="5-MongoDB"><a href="#5-MongoDB" class="headerlink" title="5. MongoDB"></a>5. MongoDB</h3><p><strong>MongoDB</strong> 是一个基于分布式文件存储的开源NoSQL数据库，采用文档存储方式，适合处理非结构化和大数据量的数据。它具有高性能、高可用性和易扩展等特点，常用于Web应用和大数据处理中。</p>
<h3 id="6-Flask"><a href="#6-Flask" class="headerlink" title="6. Flask"></a>6. Flask</h3><p><strong>Flask</strong> 是一个轻量级的Python Web框架，设计简单且易于扩展，适合快速开发原型和小型Web应用。Flask提供了基本的路由、模板引擎和WSGI支持，同时允许开发者根据需求选择扩展和库，以便构建特定需求的应用。</p>
<h3 id="7-Django"><a href="#7-Django" class="headerlink" title="7. Django"></a>7. Django</h3><p><strong>Django</strong> 是一个由Python编写的开源Web应用框架，设计用于快速开发和复杂的Web应用。Django提供了完整的开发工具集，包括ORM、管理界面、表单处理、认证系统等，使得开发人员能够快速构建安全、可维护的Web应用。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>Angular</strong> 和 <strong>React</strong> 适合构建复杂的单页应用和动态用户界面，具有较高的交互性和可扩展性。</li>
<li><strong>PostgreSQL</strong> 和 <strong>MongoDB</strong> 分别适合处理关系型和非关系型数据存储，根据数据模型和应用需求选择合适的数据库系统。</li>
<li><strong>Node.js</strong> 和 <strong>Django</strong> &#x2F; <strong>Flask</strong> 可以用于构建服务器端应用，提供API服务或渲染动态内容，具有不同的开发风格和适用场景。</li>
</ul>
</blockquote>
<h2 id="快速搭建项目的选择"><a href="#快速搭建项目的选择" class="headerlink" title="快速搭建项目的选择"></a>快速搭建项目的选择</h2><p>​	对Java和Spring技术栈比较熟悉，并且项目需要稳定性和扩展性，Spring Boot + Vue + MySQL 是一个很好的选择。如果项目需求相对简单且对响应速度要求较高，Flask + Vue + SQLite 可能更适合快速完成项目。</p>
<h1 id="SpringBoot-后端部分"><a href="#SpringBoot-后端部分" class="headerlink" title="SpringBoot( 后端部分 )"></a>SpringBoot( 后端部分 )</h1><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p><code>src/main/java/com/example/project/Application.java</code>：Spring Boot 启动类。</p>
<p><code>src/main/java/com/example/project/controller</code>：控制器层，处理 HTTP 请求。</p>
<p>​	是一个用于处理用户请求并返回响应的关键组件。</p>
<blockquote>
<p><strong>处理HTTP请求</strong>：</p>
<ul>
<li>控制器负责接收来自客户端的HTTP请求，通过映射的URL路径（如<code>/home</code>）或者其他标识符来确定具体要调用的处理方法。</li>
</ul>
<p><strong>处理业务逻辑</strong>：</p>
<ul>
<li>控制器包含了应用程序的业务逻辑，它可以调用Service层或者其他组件来完成数据处理、业务计算等操作。</li>
</ul>
<p><strong>返回响应</strong>：</p>
<ul>
<li>一旦业务逻辑处理完成，控制器负责将结果打包成响应对象（如JSON数据、HTML页面等）并返回给客户端。</li>
</ul>
</blockquote>
<p><code>src/main/java/com/example/project/service</code>：服务层，包含业务逻辑。</p>
<p>用于实现业务逻辑的组件，它通常位于应用的服务层，负责处理业务逻辑、数据处理和协调不同的数据访问对象（DAO）来完成特定的业务需求。</p>
<blockquote>
<p><strong>实现业务逻辑</strong>：</p>
<ul>
<li>Service层负责实现应用程序的业务逻辑，例如计算、数据处理、数据校验等。它包含了应用程序的核心功能，与具体的数据存取逻辑（如数据库操作）分离。</li>
</ul>
<p><strong>事务管理</strong>：</p>
<ul>
<li>Service层通常是事务的边界，负责管理事务的开始和结束。在Spring中，可以通过注解（如 <code>@Transactional</code>）来声明事务边界，确保业务方法执行的一致性和完整性。</li>
</ul>
<p><strong>协调DAO</strong>：</p>
<ul>
<li>Service层通常会调用一个或多个DAO（数据访问对象）来访问数据存储（如数据库）。它负责协调多个DAO的操作，将数据访问的细节隐藏在业务逻辑之后。</li>
</ul>
<p><strong>业务逻辑的组织</strong>：</p>
<ul>
<li>Service层帮助组织应用程序的业务逻辑，使得控制器（Controller）层可以专注于处理用户请求和响应，而不必处理复杂的业务逻辑。</li>
</ul>
<p><strong>解耦和重用</strong>：</p>
<ul>
<li>将业务逻辑封装在Service层中有助于解耦，使得不同的模块可以独立开发和测试。Service层中的方法也可以被多个控制器复用，提高了代码的重用性。</li>
</ul>
</blockquote>
<p><code>src/main/java/com/example/project/dao</code>：数据访问层，包含与数据库交互的代码。</p>
<p>在传统的Java EE 或者 Spring 中，通常将数据访问层（DAO，Data Access Object）的实现与配置与数据库交互的语句分开。在这种情况下，DAO 层的实现可能是直接使用 SQL 语句（通常存储在 XML 文件中）与数据库进行交互。在 MyBatis 框架中，这些 SQL 语句存储在 XML 文件中，并且可以使用一组规则来映射 Java 对象和数据库记录</p>
<p><code>src/main/java/com/example/project/entity</code>：数据模型，包含实体类。</p>
<p>指代表应用程序中的数据模型或持久化数据的类</p>
<blockquote>
<p><strong>数据模型定义</strong>：</p>
<ul>
<li>Entity 在应用程序中用于定义数据模型的结构。它们通常反映了数据库中表的结构，包括表的字段、关联关系等。</li>
</ul>
<p><strong>持久化</strong>：</p>
<ul>
<li>Entity 对象与数据库中的表（或文档、集合等）进行映射，使得应用程序能够方便地读取和存储数据。通过持久化操作，Entity 可以保存到数据库中，并能够从数据库中检索数据。</li>
</ul>
<p><strong>使用注解标识</strong>：</p>
<ul>
<li>在Spring中，可以使用注解（如 <code>@Entity</code>、<code>@Table</code>、<code>@Id</code>、<code>@Column</code> 等）来标识一个类为Entity，并指定与之关联的数据库表、主键等信息。</li>
</ul>
<p><strong>ORM框架支持</strong>：</p>
<ul>
<li>Spring框架通常与ORM（对象关系映射）框架（如 Hibernate、Spring Data JPA 等）集成使用。ORM框架负责将Entity对象与数据库记录进行映射，简化了数据访问和操作的过程。</li>
</ul>
<p><strong>业务逻辑的基础</strong>：</p>
<ul>
<li>Entity对象作为应用程序中的基本数据单位，它们通常与业务逻辑紧密相关。通过操作Entity对象，可以实现应用程序的各种业务逻辑需求。</li>
</ul>
</blockquote>
<p><code>src/main/resources/application.properties</code>：配置文件，包含应用程序的配置项。</p>
<p>例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">his</span></span><br><span class="line"><span class="attr">server.servlet.contextPath</span>=<span class="string">/his</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://192.168.98.130:3306/his?serverTimezone=GMT%2B8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis.typeAliasesPackage</span>=<span class="string">com.sample.his.entity</span></span><br><span class="line"><span class="attr">mybatis.mapperLocations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="attr">mybatis.configuration.logImpl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging.level.com.sample.his</span>=<span class="string">debug</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#spring.resources.staticLocations=file:C:/temp/</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.maxFileSize</span>=<span class="string">9MB</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.maxRequestSize</span>=<span class="string">18MB</span></span><br></pre></td></tr></table></figure>







<h1 id="VUE（-前端部分-）"><a href="#VUE（-前端部分-）" class="headerlink" title="VUE（ 前端部分 ）"></a>VUE（ 前端部分 ）</h1><h2 id="框架介绍-1"><a href="#框架介绍-1" class="headerlink" title="框架介绍"></a>框架介绍</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p><strong>渐进式</strong>：</p>
<ul>
<li>Vue.js 被称为渐进式框架，可以逐步应用到项目中。你可以只将 Vue.js 用作某个页面的一部分，也可以完整地构建整个单页面应用。</li>
</ul>
<p><strong>响应式数据绑定</strong>：</p>
<ul>
<li>Vue.js 提供了简单而强大的响应式数据绑定系统。通过使用指令（Directives）和双向数据绑定机制，可以使页面上的数据和DOM保持同步。</li>
</ul>
<p><strong>组件化开发</strong>：</p>
<ul>
<li>Vue.js 支持组件化开发，将页面划分为独立的、可复用的组件。每个组件都有自己的模板、逻辑和样式，可以相互嵌套和组合，使得代码更加模块化和可维护。</li>
</ul>
<p><strong>轻量和高效</strong>：</p>
<ul>
<li>Vue.js 的核心库很轻量，文件体积小，加载速度快。同时，它的性能优化也很好，对复杂页面和大型应用也能够提供良好的性能表现。</li>
</ul>
<p><strong>生态系统丰富</strong>：</p>
<ul>
<li>Vue.js 拥有一个活跃的生态系统，包括官方维护的路由器（Vue Router）、状态管理库（Vuex）、测试工具等，以及大量的第三方库和组件，能够满足各种复杂应用的需求。</li>
</ul>
<h3 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">my-vue-app/</span><br><span class="line">├── <span class="keyword">public</span>/               <span class="meta"># 公共资源目录</span></span><br><span class="line">│   ├── index.html        <span class="meta"># 入口 HTML 文件</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── src/                  <span class="meta"># 源代码目录</span></span><br><span class="line">│   ├── assets/           <span class="meta"># 静态资源文件夹（如图片、字体等）</span></span><br><span class="line">│   ├── components/       <span class="meta"># 组件文件夹</span></span><br><span class="line">│   │   ├── HelloWorld.vue    <span class="meta"># 示例组件</span></span><br><span class="line">│   │   └── ...</span><br><span class="line">│   ├── views/            <span class="meta"># 视图组件文件夹</span></span><br><span class="line">│   │   ├── Home.vue      <span class="meta"># 示例视图组件</span></span><br><span class="line">│   │   └── ...</span><br><span class="line">│   ├── App.vue           <span class="meta"># 根组件 所有组件的父级容器。</span></span><br><span class="line">│   └── main.js           <span class="meta"># 主入口文件</span></span><br><span class="line">├── node_modules/         <span class="meta"># npm依赖模块</span></span><br><span class="line">├── package.json          <span class="meta"># 项目配置文件</span></span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>



<h2 id="视图与组件"><a href="#视图与组件" class="headerlink" title="视图与组件"></a>视图与组件</h2><h3 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h3><p>视图是用户界面的一部分，通常指的是用户直接看到和交互的页面或页面的一部分。在Vue.js中，视图可以是一个单独的组件，也可以是多个组件的组合。</p>
<ul>
<li><p>特点</p>
<p>  ：</p>
<ul>
<li>视图通常对应应用程序中的一个路由，例如在单页面应用（SPA）中，不同的视图对应不同的URL路径。</li>
<li>视图可以包含多个组件，通过组合不同的组件来构建复杂的用户界面。</li>
<li>视图负责组织和展示数据，响应用户的操作，并与用户交互。</li>
</ul>
</li>
</ul>
<h3 id="组件（Component）"><a href="#组件（Component）" class="headerlink" title="组件（Component）"></a>组件（Component）</h3><p>组件是Vue.js中可复用的、独立的UI单元，它封装了特定的功能和样式，并可以在应用中多次使用。</p>
<ul>
<li><p>特点</p>
<p>  ：</p>
<ul>
<li>组件是Vue.js应用的基本构建块，它们可以包含自己的模板、脚本和样式，通常以 <code>.vue</code> 文件的形式组织。</li>
<li>组件具有自己的状态和行为，可以接收数据作为输入，并且可以通过事件来与父组件或其他组件通信。</li>
<li>组件之间可以相互嵌套和组合，形成复杂的界面结构，同时保持代码的模块化和可维护性。</li>
</ul>
</li>
</ul>
<p>在Vue.js应用中，通常一个视图对应一个或多个组件。视图负责页面的结构和布局，通过引入和组合多个组件来构建完整的页面。</p>
<h1 id="VUE和后端的连接"><a href="#VUE和后端的连接" class="headerlink" title="VUE和后端的连接"></a>VUE和后端的连接</h1><ol>
<li><p><strong>HTTP请求</strong>：</p>
<ul>
<li>Vue.js通过内置的<code>axios</code>、<code>fetch</code>或者<code>Vue Resource</code>等HTTP库，向后端发送HTTP请求。这些请求可以是GET、POST、PUT或DELETE等，用来获取数据、提交表单或执行其他操作。</li>
</ul>
</li>
<li><p><strong>异步数据获取</strong>：</p>
<ul>
<li>在Vue组件中，使用<code>axios</code>或其他HTTP库，发起异步请求获取数据。例如，在<code>mounted</code>生命周期钩子中发送请求，或者在点击事件中处理。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">users</span>: []</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/users&#x27;</span>)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">users</span> = response.<span class="property">data</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching users&#x27;</span>, error);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理响应</strong>：</p>
<ul>
<li>前端接收后端返回的JSON数据（或其他格式），并在页面上展示或进一步处理。可以在Vue组件中通过数据绑定、列表渲染等技术，将数据动态显示在页面上。</li>
</ul>
</li>
</ol>
<h3 id="后端（Spring-Boot）"><a href="#后端（Spring-Boot）" class="headerlink" title="后端（Spring Boot）"></a>后端（Spring Boot）</h3><ol>
<li><p><strong>RESTful API</strong>：</p>
<ul>
<li>Spring Boot通过Controller类来处理前端的请求，返回JSON或其他格式的数据。通常使用<code>@RestController</code>注解标记Controller类，并使用<code>@RequestMapping</code>或其他注解映射URL路径。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他操作如更新和删除等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据库交互</strong>：</p>
<ul>
<li>使用Spring Boot的数据访问技术（如Spring Data JPA），通过Repository类访问MySQL数据库。Repository类提供了CRUD操作的方法，简化了数据访问层的开发。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 可以定义自定义的查询方法，Spring Data JPA 会根据方法名自动生成查询语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理请求和响应</strong>：</p>
<ul>
<li>后端接收前端的请求，处理业务逻辑并访问数据库，将查询结果或操作结果封装为JSON格式返回给前端。Spring Boot提供了强大的注解和类库来简化RESTful API的开发和数据交互过程。</li>
</ul>
</li>
</ol>
<p>通过这种方式，Vue.js前端通过HTTP请求与Spring Boot后端进行通信，实现数据的获取、提交和展示，完成了前后端的分离和协作。这种架构不仅能够提高开发效率，还能够使得前端和后端团队能够独立开发、测试和部署各自的功能模块。</p>
<h1 id="MySql-数据库部分"><a href="#MySql-数据库部分" class="headerlink" title="MySql( 数据库部分 )"></a>MySql( 数据库部分 )</h1>]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>mysql</tag>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springboot</tag>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>后端</tag>
        <tag>javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask+Vue+MySQL 小型项目实战</title>
    <url>/2024/07/08/Flask-Vue-MySQL-%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><h2 id="项目内容简介"><a href="#项目内容简介" class="headerlink" title="项目内容简介"></a>项目内容简介</h2><ol>
<li><p>搭建一个博客管理平台。</p>
</li>
<li><p>部署到我的服务器。以便将来我不再需要在本地进行一系列操作例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull </span><br><span class="line">git push </span><br><span class="line">hexo new <span class="string">&quot; pages&quot;</span> </span><br><span class="line">hexo generate </span><br><span class="line">hexo s </span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>同时还有博客文件备份的作用，预防电脑出事后的一系列恢复操作。</p>
</li>
<li><p>以及一些数据查询操作。</p>
</li>
<li><p>登录界面</p>
</li>
<li><p>管理界面</p>
</li>
</ol>
<h2 id="技术简介"><a href="#技术简介" class="headerlink" title="技术简介"></a>技术简介</h2><p><a href="https://regenm.github.io/2024/07/03/SpringBoot-vue-mysql%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD/">SpringBoot+vue+mysql项目实训</a>结束后想试试别的web框架，发现有个轻量级的框架<code>Flask+Vue+SQLite</code>，我这里没安装SQLlite，于是使用<strong>MySQL</strong>进行替代。</p>
<ul>
<li><strong>MySQL和SQLite的区别</strong></li>
</ul>
<blockquote>
<p><strong>类型</strong>:</p>
<ul>
<li><strong>MySQL</strong>: 是一个<strong>完整的客户端&#x2F;服务器</strong>数据库管理系统，支持多用户访问，适用于大型和中型应用程序，具有高性能和可扩展性。</li>
<li><strong>SQLite</strong>: 是一个<strong>轻量级的嵌入式</strong>数据库引擎，它不需要一个独立的服务器进程或配置，可以直接访问普通的数据库文件。</li>
</ul>
<p><strong>部署和配置</strong>:</p>
<ul>
<li><strong>MySQL</strong>: 需要独立的服务器进程，可以在不同的操作系统上安装，需要配置和管理。</li>
<li><strong>SQLite</strong>: 作为库直接链接到应用程序，不需要配置服务器，部署非常简单，适合于轻量级的应用和嵌入式系统。</li>
</ul>
<p><strong>性能和适用场景</strong>:</p>
<ul>
<li><strong>MySQL</strong>: 由于其客户端&#x2F;服务器架构，适合需要处理大量数据和复杂查询的应用，具有较高的性能和并发处理能力。</li>
<li><strong>SQLite</strong>: 适合单用户或少量用户的本地应用，处理小型数据集和简单查询，性能通常比MySQL略低，但足够满足轻量级应用的需求。</li>
</ul>
<p><strong>特性和功能</strong>:</p>
<ul>
<li><strong>MySQL</strong>: 支持丰富的功能集，包括存储过程、触发器、复制和高级安全特性等，适合于复杂的数据处理需求。</li>
<li><strong>SQLite</strong>: 功能相对简单，不支持存储过程和触发器，但支持主键、索引和事务处理，满足基本的数据管理需求。</li>
</ul>
</blockquote>
<ul>
<li><strong>python虚拟环境</strong></li>
</ul>
<blockquote>
<p>Python 虚拟环境（virtual environment）是一个独立的、隔离的 Python 运行环境。它允许你在同一个系统上运行多个项目，而这些项目可以依赖于不同的包版本或不同的 Python 解释器版本。虚拟环境可以避免包版本冲突，并且提供一个干净的环境来开发和部署 Python 应用程序。</p>
</blockquote>
<ul>
<li><strong>Flask</strong></li>
</ul>
<blockquote>
<h3 id="Flask-简介"><a href="#Flask-简介" class="headerlink" title="Flask 简介"></a>Flask 简介</h3><p>Flask 是一个轻量级的 Python Web 框架，通常用于构建 web 应用程序。它是基于 WSGI（Web Server Gateway Interface）协议的，并且是微框架的一种，这意味着它提供了核心功能并且保持简洁，但允许开发者根据需要添加扩展或库来实现更复杂的功能。</p>
<h3 id="Flask-的特点"><a href="#Flask-的特点" class="headerlink" title="Flask 的特点"></a>Flask 的特点</h3><ol>
<li><strong>轻量级</strong>：Flask 被设计为一个微框架，提供最小的基础架构。它不包含 ORM（对象关系映射）或表单验证等功能，但允许开发者根据需要选择添加第三方扩展。</li>
<li><strong>灵活性</strong>：由于 Flask 是轻量级的，它提供了高度的灵活性。开发者可以根据项目需求进行配置，而不是被框架限制。</li>
<li><strong>易于使用</strong>：Flask 具有简单的学习曲线，非常适合快速开发原型。它的 API 设计非常直观，且有丰富的文档支持。</li>
<li><strong>扩展性</strong>：尽管 Flask 本身是一个微框架，但它有一个强大的扩展生态系统，允许你添加数据库集成、表单处理、用户认证等功能。</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>小型 Web 应用程序</strong>：由于其轻量级特性，Flask 非常适合构建小型和中型的 Web 应用程序。</li>
<li><strong>API 开发</strong>：Flask 被广泛用于开发 RESTful API 服务。</li>
<li><strong>快速原型设计</strong>：Flask 的简洁和灵活性使其非常适合快速开发应用程序原型。</li>
</ul>
</blockquote>
<blockquote>
<h3 id="WSGI-简介"><a href="#WSGI-简介" class="headerlink" title="WSGI 简介"></a>WSGI 简介</h3><p><strong>WSGI</strong>（Web Server Gateway Interface）是Python中一个用于Web应用程序和Web服务器之间的标准接口。它的全称是 <strong>Web Server Gateway Interface</strong>，这个标准定义了Web服务器如何与Web应用程序进行通信，并如何处理Web请求。</p>
<h3 id="WSGI-的作用"><a href="#WSGI-的作用" class="headerlink" title="WSGI 的作用"></a>WSGI 的作用</h3><ol>
<li><strong>标准化接口</strong>：WSGI 是一个规范，它定义了Python Web应用程序与Web服务器之间的接口。这意味着无论你使用什么样的Web服务器（如 Gunicorn、uWSGI）或Web框架（如 Flask、Django），只要它们遵循WSGI规范，它们就可以互相配合工作。</li>
<li><strong>应用和服务器的分离</strong>：WSGI 将Web应用程序与Web服务器分离，允许开发者选择不同的服务器和框架。这种灵活性意味着你可以轻松切换服务器或升级应用程序而不影响另一方。</li>
</ol>
<h3 id="WSGI-的工作原理"><a href="#WSGI-的工作原理" class="headerlink" title="WSGI 的工作原理"></a>WSGI 的工作原理</h3><p>WSGI 的工作流程如下：</p>
<ol>
<li><strong>请求传递</strong>：当Web服务器接收到HTTP请求时，它会通过WSGI将请求信息传递给Python的Web应用程序。请求的信息通常包括环境变量（如请求的URL、HTTP方法等）和请求体。</li>
<li><strong>响应生成</strong>：Web应用程序处理请求并生成一个响应。这个响应通常包括状态码、响应头和响应体。</li>
<li><strong>响应返回</strong>：Web应用程序将响应返回给Web服务器，Web服务器随后将响应传递给客户端（如浏览器）。</li>
</ol>
</blockquote>
<h1 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>登录界面<ol>
<li>一个密码框</li>
</ol>
</li>
<li>管理界面<ol>
<li>可视化显示数据</li>
<li>执行命令</li>
<li>执行脚本</li>
</ol>
</li>
</ol>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/../images/flaskVueMysql/xmind.png" alt="xmind"></p>
<h1 id="前端设计"><a href="#前端设计" class="headerlink" title="前端设计"></a>前端设计</h1><h3 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h3><p><img src="/../images/flaskVueMysql/1.png" alt="login"></p>
<h3 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h3><p><img src="/../images/flaskVueMysql/2.png" alt="Main"></p>
<h1 id="难点解决-测试阶段"><a href="#难点解决-测试阶段" class="headerlink" title="难点解决( 测试阶段)"></a>难点解决( 测试阶段)</h1><h2 id="1-获取MySQL数据"><a href="#1-获取MySQL数据" class="headerlink" title="1. 获取MySQL数据"></a>1. 获取MySQL数据</h2><ul>
<li><p><strong>获取流程</strong></p>
<ol>
<li><p>前端发送get请求</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import axios from &#x27;axios&#x27;;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        data: null,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      axios.get(&#x27;http://127.0.0.1:5000/api/data&#x27;)</span><br><span class="line">        .then(response =&gt; &#123;</span><br><span class="line">          this.data = response.data;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(error =&gt; &#123;</span><br><span class="line">          console.error(error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
<li><p>后端响应请求，执行sql语句，返回结果</p>
</li>
</ol>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CORS(app, origins=[<span class="string">&#x27;http://localhost:5173&#x27;</span>]) <span class="comment"># 允许前端的请求</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/data&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)     </span><span class="comment"># get方式 返回测试数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line">    cur = mysql.connection.cursor()</span><br><span class="line">    cur.execute(<span class="string">&#x27;SELECT * FROM test_data&#x27;</span>)</span><br><span class="line">    results = cur.fetchall()</span><br><span class="line">    cur.close()</span><br><span class="line">    <span class="keyword">return</span> jsonify(results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>前端显示结果</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;h1&gt; This is a test View&lt;/h1&gt;</span><br><span class="line">  &lt;h1&gt; use Flask as backend&lt;/h1&gt;</span><br><span class="line">  &lt;h1&gt; get data from mysql&lt;/h1&gt;</span><br><span class="line">    &lt;div v-if=&quot;data&quot;&gt;</span><br><span class="line">      &lt;!-- 使用数据 --&gt;</span><br><span class="line">      &#123;&#123; data &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-else&gt;</span><br><span class="line">      Loading...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果：</p>
</li>
</ol>
<p>  <img src="/../images/flaskVueMysql/3.png" alt="GET"></p>
</li>
</ul>
<h2 id="2-前端-文件上传"><a href="#2-前端-文件上传" class="headerlink" title="2. 前端 文件上传"></a>2. 前端 文件上传</h2><ul>
<li>上传之前检查依赖：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install Werkzeug</span><br></pre></td></tr></table></figure>



<ul>
<li><p>文件上传流程</p>
<ol>
<li><p>前端选择本地文件，点击上传，发送post请求</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;form @submit.prevent=&quot;uploadFile&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;file&quot; @change=&quot;handleFileUpload&quot;&gt;</span><br><span class="line">        &lt;button type=&quot;submit&quot;&gt;Upload&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">      &lt;!-- 文件上传按钮以及选框 --&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  import axios from &#x27;axios&#x27;;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleFileUpload(event) &#123;</span><br><span class="line">        this.file = event.target.files[0];</span><br><span class="line">      &#125;,</span><br><span class="line">      uploadFile() &#123;</span><br><span class="line">        const formData = new FormData();</span><br><span class="line">        formData.append(&#x27;file&#x27;, this.file);</span><br><span class="line">        //向后端发送POST</span><br><span class="line">        axios.post(&#x27;http://127.0.0.1:5000/upload&#x27;, formData, &#123;</span><br><span class="line">          headers: &#123;</span><br><span class="line">            &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(response =&gt; &#123;</span><br><span class="line">          console.log(response.data);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(error =&gt; &#123;</span><br><span class="line">          console.error(error);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

</li>
<li><p>后端响应请求，保存到特定文件夹</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UPLOAD_FOLDER = <span class="string">&#x27;uploads&#x27;</span></span><br><span class="line">app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>] = UPLOAD_FOLDER</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/upload&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_file</span>():</span><br><span class="line">    <span class="comment"># 检查请求中是否包含文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;file&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> request.files:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;No file part&#x27;</span>&#125;), <span class="number">400</span></span><br><span class="line">    </span><br><span class="line">    file = request.files[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查文件是否有名字</span></span><br><span class="line">    <span class="keyword">if</span> file.filename == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;No selected file&#x27;</span>&#125;), <span class="number">400</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存文件</span></span><br><span class="line">    filename = file.filename</span><br><span class="line">    file.save(os.path.join(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>], filename))</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;File successfully uploaded&#x27;</span>&#125;), <span class="number">200</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
</li>
</ol>
<p>  注：修改后端代码需要重启flask应用</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CTRL+C</span><br><span class="line">flask run</span><br></pre></td></tr></table></figure>

<p>  <img src="/../images/flaskVueMysql/4.png" alt="GET"></p>
</li>
</ul>
<p><img src="/../images/flaskVueMysql/5.png" alt="GET"></p>
<h2 id="3-后端-执行脚本"><a href="#3-后端-执行脚本" class="headerlink" title="3. 后端 执行脚本"></a>3. 后端 执行脚本</h2><ul>
<li><p>执行流程</p>
<ol>
<li><p>前端点击按钮</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button @click=&quot;runScript&quot;&gt;Run Script&lt;/button&gt;</span><br><span class="line">      &lt;div v-if=&quot;output&quot;&gt;</span><br><span class="line">        &lt;h3&gt;Script Output:&lt;/h3&gt;</span><br><span class="line">        &lt;pre&gt;&#123;&#123; output &#125;&#125;&lt;/pre&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div v-if=&quot;error&quot;&gt;</span><br><span class="line">        &lt;h3&gt;Script Error:&lt;/h3&gt;</span><br><span class="line">        &lt;pre&gt;&#123;&#123; error &#125;&#125;&lt;/pre&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  import axios from &#x27;axios&#x27;;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        output: &#x27;&#x27;,</span><br><span class="line">        error: &#x27;&#x27;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      runScript() &#123;</span><br><span class="line">        axios.post(&#x27;http://127.0.0.1:5000/run-script&#x27;)</span><br><span class="line">          .then(response =&gt; &#123;</span><br><span class="line">            this.output = response.data.output;</span><br><span class="line">            this.error = response.data.error;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(error =&gt; &#123;</span><br><span class="line">            this.error = error.message;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
<li><p>后端执行脚本</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/run-script&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_script</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        </span><br><span class="line">        result = subprocess.run([<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;test.py&#x27;</span>], capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;</span><br><span class="line">            <span class="string">&#x27;output&#x27;</span>: result.stdout,</span><br><span class="line">            <span class="string">&#x27;error&#x27;</span>: result.stderr,</span><br><span class="line">            <span class="string">&#x27;returncode&#x27;</span>: result.returncode</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;error&#x27;</span>: <span class="built_in">str</span>(e)&#125;), <span class="number">500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>subprocess</p>
<blockquote>
<p>The <code>subprocess</code> module in Python is used to spawn new processes, connect to their input&#x2F;output&#x2F;error pipes, and obtain their return codes. It replaces older modules like <code>os.system</code> and provides more powerful functionality.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>结果</p>
</li>
</ol>
<p>  你别管一片红，你就说跑没跑起来吧。</p>
</li>
</ul>
<p><img src="/../images/flaskVueMysql/6.png" alt="Script"></p>
<h1 id="最终整合"><a href="#最终整合" class="headerlink" title="最终整合"></a>最终整合</h1><p>​	除了显示数据这个难点以外，其他难点都大差不差的解决了。</p>
<p>​	显示的数据其实也就只是文本（文件名字，博客文章名字等等），初步打算：</p>
<ol>
<li><p>后端：</p>
</li>
<li><p>制作一个脚本(python或者shell都可以)，然后直接调用执行脚本即可。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls &gt; tmp</span><br><span class="line">cat tmp</span><br></pre></td></tr></table></figure>
</li>
<li><p>前端：</p>
<ol>
<li>前端主要就是表单美化等操作了。</li>
</ol>
</li>
</ol>
<p>整合完之后再放github。</p>
<h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1><p>​	不得不说小web项目用用Flask还是挺方便的，虽然报错还有很多，但是能跑就行。后续打算扩展一下功能，</p>
<ol>
<li>可以加上我的物联网想法，实现一个智能物联网云平台，走mqtt协议控制一些小东西，比如家里的服务器以及电源开关，空调遥控等等。</li>
<li>实际上这个平台只有我一个人用，也只能让我一个人用，总感觉安全性不高。打算去看看有关网站登录安全性，以及针对小用户群的web网站技术。<ol>
<li>可以试试加上动态验证，邮箱只设置我的。</li>
<li>代增加。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>mysql</tag>
        <tag>python</tag>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>后端</tag>
        <tag>javascript</tag>
        <tag>html</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>《西线无战事》</title>
    <url>/2024/07/09/%E3%80%8A%E8%A5%BF%E7%BA%BF%E6%97%A0%E6%88%98%E4%BA%8B%E3%80%8B/</url>
    <content><![CDATA[<h1 id="《西线无战事》"><a href="#《西线无战事》" class="headerlink" title="《西线无战事》"></a>《西线无战事》</h1><ul>
<li>written by 埃里希·玛丽亚·雷马克</li>
</ul>
<blockquote>
<p>“ 这本书既不是指控也不是忏悔，</p>
<p>更不是一次冒险 ，</p>
<p>因为对于那些面对死亡的人来说，</p>
<p>死亡不是一次冒险。</p>
<p>他试图讲述这样一代人—-</p>
<p>尽管他们逃过了炮弹，</p>
<p>却还是被战争摧毁了。”</p>
</blockquote>
<p>​	这本书是在今年暑假回家前在图书馆借的。在回家的路上就读了一大半，读时有一种奇妙的感受。彼时彼刻我坐在有空调的高速列车上，世界上的其他地方还正发生着战乱。一想到我正读到保罗·博伊默在战壕中穿梭，执行侦查任务时，世界的另一端正发生着同样的事时心里就多了一些悲伤。</p>
<blockquote>
<p>“我们才刚开始热爱生活，却不得不对这一切开炮。”</p>
</blockquote>
<blockquote>
<p>“他们仍在继续写文章，发表演说，而我们却已经看到了野战医院和死亡；他们依旧在说对国家的责任是头等大事，而我们却已经知道死亡的剧痛比以前更为强烈了。尽管这样，我们绝不做叛乱者，绝不做逃兵，也绝不做懦夫——这些词，他们原是随便使用的——我们跟他们一样热爱我们的祖国，我们英勇地参加每一次进攻，但我们还会辨别是非，我们一下子学会了观察问题。于是，我们看到，他们的那个世界已经荡然无存。我们突然觉得孤独得可怕，而又必须一直孤独下去。”</p>
</blockquote>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>读书是一件有温度的事</title>
    <url>/2024/07/09/%E8%AF%BB%E4%B9%A6%E6%98%AF%E4%B8%80%E4%BB%B6%E6%9C%89%E6%B8%A9%E5%BA%A6%E7%9A%84%E4%BA%8B/</url>
    <content><![CDATA[<p>​	突然发现很多书，在读的时候不写写画画，读完以后很容易就忘记了。还是得有点输出才行啊。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>《卡拉马佐夫兄弟》</title>
    <url>/2024/07/19/%E3%80%8A%E5%8D%A1%E6%8B%89%E9%A9%AC%E4%BD%90%E5%A4%AB%E5%85%84%E5%BC%9F%E3%80%8B/</url>
    <content><![CDATA[<h1 id="《卡拉马佐夫兄弟》"><a href="#《卡拉马佐夫兄弟》" class="headerlink" title="《卡拉马佐夫兄弟》"></a>《卡拉马佐夫兄弟》</h1><p>​	初次阅读时是在高中借的同学的书，是上册。那时的理解能力，哲学素养还不够，那时看的时候只能些许感受到其中的魅力和震撼。但也足以吸引我看下去，可惜由于学业，课桌里的书籍也逐渐被试卷替代。</p>
<p>​	直到现在，才有时间来慢慢欣赏那些大家的作品。第二次见面是在图书馆里，两册大大的方方正正的，我单手勉强才能拿起一册，外观就足以解释这是一部厚重的经典了。</p>
<p>​	说实话看到这样两本厚厚的书籍，我有点没信心看完。可能是之前看到一半就弃了的《魔山》和《悲惨世界》留给我的后遗症吧。前者是每次看一会就会打瞌睡，后者能看下去主要情节但是觉得废话太多，于是有点对这种厚厚的书产生畏惧心理，害怕里面的那些大段的哲学发言。</p>
<p>​	但是《卡拉马佐夫》帮我打破了这个魔咒。只是可惜这部作品还未写完<a href="https://zh.wikipedia.org/wiki/%E9%99%80%E6%80%9D%E5%A6%A5%E8%80%B6%E5%A4%AB%E6%96%AF%E5%9F%BA">陀思妥耶夫斯基</a>就先去世了。每次都能从德米特里，阿列克塞，伊万这些人物中找到自己的影子。那些描写如此真实，让我突然就对那些轻小说，那些清汤寡水失去了兴趣。</p>
<p>​	《卡拉马佐夫》和《罪与罚》真的太震撼了，为什么可以将人的复杂性写得这么真实！很多情况下别的小说的主角都是性格鲜明，但是妥氏笔下的人物就截然不同，更具有人类的拧巴纠结，复杂易变的特点。无论是哪个角色我好像都能找到自己的影子。</p>
<p>​	庆幸自己接触到了这些经典，真的很感谢带我接触这些经典的人们。下一本就是《罪与罚》了。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>verilog HDL basics</title>
    <url>/2024/07/22/verilog-HDL-basics/</url>
    <content><![CDATA[<h1 id="Verilog-Language"><a href="#Verilog-Language" class="headerlink" title="Verilog Language"></a>Verilog Language</h1><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><ul>
<li><p><strong>bitwise</strong> and <strong>logical</strong></p>
<ul>
<li><p>bitwise-NOT (<code>~</code>) and logical-NOT (<code>!</code>)</p>
<blockquote>
<h3 id="Bitwise-NOT"><a href="#Bitwise-NOT" class="headerlink" title="Bitwise-NOT (~)"></a>Bitwise-NOT (<code>~</code>)</h3><ul>
<li><strong>Operation</strong>: The bitwise-NOT operator performs a bitwise inversion on its operand. This means that each bit of the operand is flipped; <code>0</code> becomes <code>1</code> and <code>1</code> becomes <code>0</code>.</li>
<li><strong>Usage</strong>: It is used when you need to invert the bits of a binary number or a vector.</li>
</ul>
<h3 id="Logical-NOT"><a href="#Logical-NOT" class="headerlink" title="Logical-NOT (!)"></a>Logical-NOT (<code>!</code>)</h3><ul>
<li><strong>Operation</strong>: The logical-NOT operator evaluates the logical value of its operand. It converts <code>0</code> to <code>1</code> and any non-zero value to <code>0</code>.</li>
<li><strong>Usage</strong>: It is used when you want to negate a condition or expression. This is typically used in control flow statements like <code>if</code> or <code>while</code>.</li>
</ul>
</blockquote>
</li>
<li><p>bitwise-AND (<code>&amp;</code>) and logical-AND (<code>&amp;&amp;</code>)</p>
</li>
</ul>
</li>
</ul>
<h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h2><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><h2 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h2><h2 id="Other-features"><a href="#Other-features" class="headerlink" title="Other features"></a>Other features</h2>]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>FPGA</tag>
        <tag>verilog</tag>
        <tag>HDL</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网协议扫盲</title>
    <url>/2024/08/25/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E6%89%AB%E7%9B%B2/</url>
    <content><![CDATA[<h1 id="MQTT（消息队列遥测传输协议）"><a href="#MQTT（消息队列遥测传输协议）" class="headerlink" title="MQTT（消息队列遥测传输协议）"></a>MQTT（消息队列遥测传输协议）</h1><p>​	MQTT是轻量级的消息发布&#x2F;订阅协议，设计用于资源受限的设备和低带宽、高延迟的网络环境。它已成为物联网领域的事实标准，广泛应用于智能家居、工业自动化等领域。</p>
<p>​	mqtt比较简单，算是我入门物联网使用的第一种方式（协议）。从搭建mqtt服务器，协议原理，连接方式以及mqtt上位机编写，通过实操都有了一定了解了。</p>
<p>​	<a href="https://regenm.github.io/2024/02/09/MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88mosquitto%EF%BC%89/">MQTT服务器搭建（mosquitto） | Regen (regenm.github.io)</a></p>
<p>​	<a href="https://regenm.github.io/2024/02/09/esp8266%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9F%BA%E4%BA%8Emosquitto%E7%9A%84mqtt-server%EF%BC%89/">esp8266连接服务器（基于mosquitto的mqtt server） | Regen (regenm.github.io)</a></p>
<p>​	<a href="https://regenm.github.io/2024/04/27/mqttSender/">mqttSender | Regen (regenm.github.io)</a></p>
<h1 id="CoAP（受限应用协议）"><a href="#CoAP（受限应用协议）" class="headerlink" title="CoAP（受限应用协议）"></a>CoAP（受限应用协议）</h1><ul>
<li>Coap（Constrained Application Protocol）</li>
</ul>
<blockquote>
<p>使用在资源受限的物联网设备上，</p>
<p><strong>Coap协议特点</strong></p>
<ol>
<li>COAP协议网络传输层由TCP改为UDP。</li>
<li>它基于REST，server的资源地址和互联网一样也有类似url的格式，客户端同样有POST，GET,PUT,DELETE方法来访问server，HTTP做了简化。</li>
<li>COAP是二进制格式的，HTTP是文本格式的，COAP比HTTP更加紧凑。</li>
<li>轻量化，COAP最小长度仅仅4B，一个HTTP的头都几十个B了。</li>
<li>支持可靠传输，数据重传，块传输。确保数据可靠到达。</li>
<li>支持IP多播，即可以同时向多个设备发送请求。</li>
<li>非长连接通信，适用于低功耗物联网场景</li>
</ol>
</blockquote>
<p>CoAP是为物联网设备设计的轻量级协议，基于REST架构，与HTTP类似，但更加节能和高效，适用于低功耗、受限网络的物联网设备。</p>
<p><a href="">to be continued</a></p>
<h1 id="LoRaWAN"><a href="#LoRaWAN" class="headerlink" title="LoRaWAN"></a>LoRaWAN</h1><ul>
<li><h3 id="LoRa和LoRaWAN的区别"><a href="#LoRa和LoRaWAN的区别" class="headerlink" title="LoRa和LoRaWAN的区别"></a>LoRa和LoRaWAN的区别</h3><ul>
<li><strong>LoRa</strong>：LoRa是一种物理层的调制技术，用于在设备之间传输无线电信号。它能够在不消耗大量电力的情况下，实现设备之间的长距离数据传输。LoRa的通信通常是点对点的，或者在某些场景下是点对多点的。</li>
<li><strong>LoRaWAN</strong>：LoRaWAN是LoRa的网络层协议，用于管理LoRa设备如何在广域网中进行通信。它定义了设备如何与集中式网络服务器（通常通过网关）通信，从而实现设备数据的收集和处理。</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="1-LoRa："><a href="#1-LoRa：" class="headerlink" title="1. LoRa："></a>1. <strong>LoRa</strong>：</h3><ul>
<li><strong>定义</strong>：LoRa（Long Range）是一种调制技术，用于无线数据传输。它属于物理层（PHY），负责将数据编码成无线电信号，以便设备在长距离内进行低功耗通信。</li>
<li><strong>作用</strong>：LoRa技术的主要优势是支持低功耗、长距离的通信，通常可以在几公里到几十公里的范围内工作，具体取决于环境和地理条件。</li>
<li><strong>用途</strong>：LoRa用于设备之间的直接无线通信，它不涉及设备如何联网或管理通信的高级功能。</li>
</ul>
<h3 id="2-LoRaWAN："><a href="#2-LoRaWAN：" class="headerlink" title="2. LoRaWAN："></a>2. <strong>LoRaWAN</strong>：</h3><ul>
<li><strong>定义</strong>：LoRaWAN（LoRa Wide Area Network）是基于LoRa技术的网络层协议，定义了设备如何在广域网中进行通信。它包括了数据传输的管理、设备与网络的互联，以及如何实现数据的加密、认证等高级功能。</li>
<li><strong>作用</strong>：LoRaWAN管理LoRa设备与网关、服务器之间的通信，确保数据能够从设备安全地传输到网络服务器，并从服务器发送指令到设备。它定义了星型拓扑结构、设备的通信模式、数据传输的时间窗口等。</li>
<li><strong>用途</strong>：LoRaWAN使得LoRa设备能够连接到互联网，实现大规模物联网应用中的设备管理和数据处理。</li>
</ul>
</blockquote>
<p>LoRaWAN协议用于LoRa设备之间的通信，支持长距离、低功耗的无线通信。它在智能城市、农业监控和远程传感应用中得到广泛采用。</p>
<p><a href="">to be continued</a></p>
<h1 id="IPv6和6LoWPAN"><a href="#IPv6和6LoWPAN" class="headerlink" title="IPv6和6LoWPAN"></a>IPv6和6LoWPAN</h1><p>IPv6的普及为每个物联网设备提供了一个唯一的IP地址，解决了地址匮乏问题。6LoWPAN（IPv6 over Low-Power Wireless Personal Area Networks）使得IPv6能够在低功耗、低速率的无线网络中使用，支持大规模物联网部署。</p>
<p><a href="">to be continued</a></p>
<h1 id="Thread："><a href="#Thread：" class="headerlink" title="Thread："></a><strong>Thread</strong>：</h1><p>Thread是一种为智能家居和建筑自动化设计的低功耗无线协议，基于IPv6，提供了更好的安全性、可靠性和可扩展性。它兼容现有的IP网络，并支持数百个设备的互联。</p>
<p><a href="">to be continued</a></p>
<h1 id="Zigbee"><a href="#Zigbee" class="headerlink" title="Zigbee"></a>Zigbee</h1><ul>
<li><strong>特点</strong>：低功耗、短距离、基于IEEE 802.15.4标准的无线网络协议。</li>
<li><strong>应用场景</strong>：适用于家庭自动化、楼宇控制、传感器网络等应用。</li>
<li><strong>优点</strong>：低功耗，支持网状网络（Mesh Network），具有较强的自愈能力和扩展性。</li>
</ul>
<p><a href="">to be continued</a></p>
<h1 id="Z-Wave"><a href="#Z-Wave" class="headerlink" title="Z-Wave"></a>Z-Wave</h1><ul>
<li><strong>特点</strong>：低功耗、短距离、专为智能家居设计的无线通信协议。</li>
<li><strong>应用场景</strong>：广泛应用于家庭自动化系统，如灯光控制、门锁、安全系统。</li>
<li><strong>优点</strong>：低功耗，良好的互操作性，支持家庭网络的点对点通信。</li>
</ul>
<p><a href="">to be continued</a></p>
<h1 id="Bluetooth-Low-Energy（BLE）"><a href="#Bluetooth-Low-Energy（BLE）" class="headerlink" title="Bluetooth Low Energy（BLE）"></a>Bluetooth Low Energy（BLE）</h1><ul>
<li><strong>特点</strong>：低功耗、短距离、蓝牙4.0及以上版本的特性。</li>
<li><strong>应用场景</strong>：适用于短距离、低功耗的设备，如可穿戴设备、医疗设备、智能家居。</li>
<li><strong>优点</strong>：低功耗，广泛支持，适合需要定期传输小数据量的设备。</li>
</ul>
<p><a href="">to be continued</a></p>
<h1 id="NB-IoT（Narrowband-IoT）"><a href="#NB-IoT（Narrowband-IoT）" class="headerlink" title="NB-IoT（Narrowband IoT）"></a>NB-IoT（Narrowband IoT）</h1><ul>
<li><strong>特点</strong>：低功耗广域网技术，基于蜂窝网络。</li>
<li><strong>应用场景</strong>：适用于广域覆盖和低数据速率的物联网应用，如智能计量、资产追踪、智慧城市。</li>
<li><strong>优点</strong>：深度覆盖，支持海量设备连接，电池寿命长。</li>
</ul>
<p><a href="">to be continued</a></p>
<h1 id="Sigfox"><a href="#Sigfox" class="headerlink" title="Sigfox"></a>Sigfox</h1><ul>
<li><strong>特点</strong>：超窄带、低功耗广域网技术。</li>
<li><strong>应用场景</strong>：适用于低数据传输速率和低功耗的应用，如资产跟踪、环境监测、智能城市。</li>
<li><strong>优点</strong>：全球覆盖，超低功耗，成本低，适合大规模部署。</li>
</ul>
<p><a href="">to be continued</a></p>
<h1 id="6LoWPAN（IPv6-over-Low-Power-Wireless-Personal-Area-Networks）"><a href="#6LoWPAN（IPv6-over-Low-Power-Wireless-Personal-Area-Networks）" class="headerlink" title="6LoWPAN（IPv6 over Low-Power Wireless Personal Area Networks）"></a>6LoWPAN（IPv6 over Low-Power Wireless Personal Area Networks）</h1><ul>
<li><strong>特点</strong>：将IPv6引入低功耗无线网络，适用于资源受限的设备。</li>
<li><strong>应用场景</strong>：适用于需要与互联网通信的物联网设备，如智能家居、工业自动化。</li>
<li><strong>优点</strong>：支持IP地址的直接分配，便于与现有互联网基础设施集成。</li>
</ul>
<p><a href="">to be continued</a></p>
<h1 id="Wi-Fi"><a href="#Wi-Fi" class="headerlink" title="Wi-Fi"></a>Wi-Fi</h1><ul>
<li><strong>特点</strong>：基于IEEE 802.11标准，提供高速、短距离无线通信。</li>
<li><strong>应用场景</strong>：适用于需要高带宽、连续供电的物联网设备，如智能摄像头、家庭自动化设备。</li>
<li><strong>优点</strong>：高速数据传输，广泛应用，易于部署。</li>
</ul>
<p><a href="">to be continued</a></p>
<h1 id="Cellular-LTE-M-NB-IoT-5G"><a href="#Cellular-LTE-M-NB-IoT-5G" class="headerlink" title="Cellular (LTE-M, NB-IoT, 5G)"></a>Cellular (LTE-M, NB-IoT, 5G)</h1><ul>
<li><strong>特点</strong>：基于蜂窝网络的物联网通信协议，提供广域覆盖和高带宽。</li>
<li><strong>应用场景</strong>：适用于需要广域覆盖和高可靠性的应用，如车联网、远程监控、物流追踪。</li>
<li><strong>优点</strong>：广域覆盖，支持移动性，高带宽，适合大规模物联网部署。</li>
</ul>
<p><a href="">to be continued</a></p>
]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>51</tag>
        <tag>STM32</tag>
        <tag>Iot</tag>
        <tag>物联网协议</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网水控系统</title>
    <url>/2024/09/19/%E7%89%A9%E8%81%94%E7%BD%91%E6%B0%B4%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><h2 id="1-软件系统"><a href="#1-软件系统" class="headerlink" title="1. 软件系统"></a>1. 软件系统</h2><ul>
<li>Flask+VUE+MySQL</li>
<li>Python脚本使用Mqtt协议传送命令以及数据</li>
</ul>
<h2 id="2-硬件系统"><a href="#2-硬件系统" class="headerlink" title="2. 硬件系统"></a>2. 硬件系统</h2><ul>
<li>esp8266连接WIFI以及MQ服务器</li>
<li>220v水泵</li>
</ul>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="1-esp8266连接emqx服务器"><a href="#1-esp8266连接emqx服务器" class="headerlink" title="1. esp8266连接emqx服务器"></a>1. esp8266连接emqx服务器</h2><ul>
<li>CA认证关键代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// WiFi and MQTT client initialization</span></span><br><span class="line">BearSSL::WiFiClientSecure espClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">mqtt_client</span><span class="params">(espClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSL certificate for MQTT broker</span></span><br><span class="line"><span class="comment">// Load DigiCert Global Root G2, which is used by EMQX Public Broker: broker.emqx.io</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> ca_cert[]</span><br><span class="line">PROGMEM = <span class="string">R&quot;EOF(</span></span><br><span class="line"><span class="string">-----BEGIN CERTIFICATE-----</span></span><br><span class="line"><span class="string">***********ca CRT***********</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-----END CERTIFICATE-----</span></span><br><span class="line"><span class="string">)EOF&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-esp8266收发指令并进行作业"><a href="#2-esp8266收发指令并进行作业" class="headerlink" title="2. esp8266收发指令并进行作业"></a>2. esp8266收发指令并进行作业</h2><ul>
<li>将payload输出到字符数组，在进行对比后分支操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *mqtt_start = <span class="string">&quot;start&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *mqtt_stop = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mqttCallback</span><span class="params">(<span class="type">char</span> *topic, byte *payload, <span class="type">unsigned</span> <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;Message received on topic: &quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">print</span>(topic);</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;]: &quot;</span>);</span><br><span class="line">    <span class="type">char</span> judge[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">12</span>)&#123;</span><br><span class="line">            judge[i<span class="number">-12</span>]=payload[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Serial.<span class="built_in">print</span>((<span class="type">char</span>) payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">judgeEqual</span>(judge,mqtt_start,<span class="number">5</span>))&#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;ssssssssssssssssssssssssssssssssuccessful&quot;</span>);</span><br><span class="line">        <span class="built_in">digitalWrite</span>(<span class="number">16</span>, HIGH);  <span class="comment">// turn the LED on (HIGH is the voltage level)                    // wait for a second</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">judgeEqual</span>(judge,mqtt_stop,<span class="number">4</span>))&#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;ssssssssssssssssssssssssssssssssuccessful&quot;</span>);</span><br><span class="line">        <span class="built_in">digitalWrite</span>(<span class="number">16</span>, LOW);  <span class="comment">// turn the LED on (HIGH is the voltage level)                    // wait for a second</span></span><br><span class="line">    &#125;</span><br><span class="line">    Serial.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judgeEqual</span><span class="params">(<span class="type">char</span> *str1,<span class="type">const</span> <span class="type">char</span> *str2,<span class="type">int</span> length)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1[i]!=str2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-搭建服务器并部署"><a href="#3-搭建服务器并部署" class="headerlink" title="3. 搭建服务器并部署"></a>3. 搭建服务器并部署</h2><ul>
<li><p>无数据库的Flak+Vue项目部署</p>
<ol>
<li><p>服务器的准备阶段 </p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install nginx -y <span class="comment"># 安装nginx</span></span><br><span class="line">sudo aot install python3 python3-pip3 -y</span><br><span class="line">sudo pip3 install paho-mqtt Flask Flask-CORS</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包阶段</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> frontend</span><br><span class="line">scp -r dist/ root@123.456.789.000:/var/www/vue-app</span><br><span class="line">spc -r backend/ root@123.456.789.000:/var/www/flask-app</span><br></pre></td></tr></table></figure>

</li>
<li><p>启动阶段</p>
</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/sites-available/default</span><br><span class="line">code .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name _;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理 Vue 前端</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/vue-app;   <span class="comment"># Vue 静态文件的路径</span></span><br><span class="line">        try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理 Flask 后端 API 请求</span></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:5000;  <span class="comment"># Flask 应用运行在本地的 5000 端口</span></span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-编写命令发送脚本，其他功能脚本"><a href="#4-编写命令发送脚本，其他功能脚本" class="headerlink" title="4. 编写命令发送脚本，其他功能脚本"></a>4. 编写命令发送脚本，其他功能脚本</h2><p>见下</p>
<h1 id="进度追踪"><a href="#进度追踪" class="headerlink" title="进度追踪"></a>进度追踪</h1><h2 id="前端基本功能完成"><a href="#前端基本功能完成" class="headerlink" title="前端基本功能完成"></a>前端基本功能完成</h2><ul>
<li>登录</li>
</ul>
<p><img src="/../images/iotWaterPump/1.png" alt="regen"></p>
<ul>
<li>先实现基本的点灯功能（开关）</li>
</ul>
<p><img src="/../images/iotWaterPump/2.png" alt="regen"></p>
<h2 id="后端功能"><a href="#后端功能" class="headerlink" title="后端功能"></a>后端功能</h2><ul>
<li>提供密码认证</li>
</ul>
<p>​	因为是私人使用，所以只在后端检验密码</p>
<p><img src="/../images/iotWaterPump/3.png" alt="regen"></p>
<ul>
<li>获取命令信息</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/iotWaterPump/4.png" alt="regen"></h2><h2 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h2><p>前后端都做得基本大差不差了。接下来开始Mqtt基于Python的脚本。</p>
<ul>
<li>简单脚本的运行</li>
</ul>
<p><img src="/../images/iotWaterPump/5.png" alt="regen"></p>
<ul>
<li><p>最终脚本的运行</p>
</li>
<li><p>很烦mqtt的版本问题 记得选择version</p>
</li>
<li><p>mqtt脚本直接运行可以成功，但是使用<code>subprocess</code>会失败就是因为版本问题。</p>
</li>
</ul>
<p>以下是两种情况都能运行的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mqtt_publish.py</span></span><br><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mqtt_publish.py running&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connected with result code &quot;</span> + <span class="built_in">str</span>(rc))</span><br><span class="line">    message = <span class="string">&quot;&#123;\n\&quot;  msg\&quot;: \&quot;start\&quot;\n&#125;&quot;</span></span><br><span class="line">    client.publish(<span class="string">&quot;/esp8266/test&quot;</span>, message)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Published: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># Wait a second before sending the next message</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an MQTT client instance without callback_api_version</span></span><br><span class="line">client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION1,client_id=<span class="string">&quot;&quot;</span>, clean_session=<span class="literal">True</span>, userdata=<span class="literal">None</span>, protocol=mqtt.MQTTv311,)</span><br><span class="line"></span><br><span class="line">client.on_connect = on_connect</span><br><span class="line"></span><br><span class="line">client.tls_set(ca_certs=<span class="string">&quot;emqxsl-ca.crt&quot;</span>, certfile=<span class="literal">None</span>, keyfile=<span class="literal">None</span>, tls_version=ssl.PROTOCOL_TLSv1_2)</span><br><span class="line"></span><br><span class="line">broker_address = <span class="string">&quot;url&quot;</span></span><br><span class="line">broker_port = <span class="number">8883</span></span><br><span class="line">username = <span class="string">&quot;regen&quot;</span></span><br><span class="line">password = <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">client.username_pw_set(username, password)</span><br><span class="line">client.connect(broker_address, broker_port, keepalive=<span class="number">60</span>)</span><br><span class="line">client.loop_start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">6</span>)  <span class="comment"># Wait a little longer to ensure all messages are sent</span></span><br><span class="line"></span><br><span class="line">client.loop_stop()</span><br><span class="line">client.disconnect()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>成功截图</li>
</ul>
<p><img src="/../images/iotWaterPump/6.png" alt="regen"></p>
<p><img src="/../images/iotWaterPump/7.png" alt="regen"></p>
<h2 id="Final-部署到服务器"><a href="#Final-部署到服务器" class="headerlink" title="Final!!!!!!部署到服务器"></a>Final!!!!!!部署到服务器</h2><ul>
<li><p>发现一个神器<code>remote-ssh</code>，一个vscode插件，可以直接连接服务器，使用vscode进行部署和编辑。</p>
</li>
<li><p>部署flask后端</p>
<ol>
<li>只需要传源代码，一开始不小心把虚拟环境也传上去了qwq</li>
<li>使用 <code>gunicorn</code> 启动 Flask 应用</li>
</ol>
</li>
<li><p>部署前端VUE</p>
<ol>
<li>使用打包工具<code>npm run build</code></li>
<li>使用nginx进行的代理</li>
</ol>
</li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>每个人都可以访问网站 <a href="142.171.33.151">WaterPump</a>来控制水泵了！</p>
<p><img src="/../images/iotWaterPump/8.png" alt="regen"></p>
<p><img src="/../images/iotWaterPump/9.png" alt="regen"></p>
<h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><ol>
<li>VUE前端没有加入登录认证导致每个人都可以<code>IP/admin</code>进入后台，登录界面形同虚设</li>
<li>Linux(ubuntu)使用<code>subprocess</code>运行脚本需要加python版本<code>python3</code></li>
<li>mqtt库函数参数需要加<code>CallbackAPIVersion</code></li>
<li>使用emqx服务器集群的CA认证</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​	这一次没有采用自己搭建的mqtt服务器，使用的是emqx的免费服务器集群，说实话有点麻烦，需要ca认证才能连接上。早知道就用自己之前搭建的服务器了。不过学到了新的东西，也是蛮不错的。	</p>
<p>​	接下来试试加上别的传感器，再写个dashboard，方便展示数据和发送命令。</p>
<h1 id="升级—-V2-0"><a href="#升级—-V2-0" class="headerlink" title="升级—-&gt; V2.0"></a>升级—-&gt; V2.0</h1><p>​	加入数据可视化显示以及实时显示当前数据的功能。</p>
<p><img src="/../images/iotWaterPump/v2/1.png" alt="v2"></p>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="1-获取当地天气等数据"><a href="#1-获取当地天气等数据" class="headerlink" title="1. 获取当地天气等数据"></a>1. 获取当地天气等数据</h3><ul>
<li><p><strong>实现方法</strong></p>
<p>  ​	尝试使用现有的api，例如高德。</p>
</li>
</ul>
<h4 id="高德api的使用"><a href="#高德api的使用" class="headerlink" title="高德api的使用"></a>高德api的使用</h4><blockquote>
<ol>
<li>打开并注册<a href="https://lbs.amap.com/">高德开放平台</a></li>
<li>进入<a href="https://console.amap.com/dev/key/app">高德开发平台的控制台</a></li>
<li>创建<strong>web服务</strong>应用并获取 API Key</li>
</ol>
</blockquote>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://restapi.amap.com/v3/weather/weatherInfo?city=110101&amp;key=&lt;用户key&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>参数的选择</p>
<table>
<thead>
<tr>
<th><strong>参数名</strong></th>
<th><strong>含义</strong></th>
<th><strong>规则说明</strong></th>
<th><strong>是否必须</strong></th>
<th><strong>缺省值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>key</td>
<td>请求服务权限标识</td>
<td>用户在高德地图官网 <a href="https://lbs.amap.com/dev/">申请 web 服务 API 类型 KEY</a></td>
<td>必填</td>
<td>无</td>
</tr>
<tr>
<td>city</td>
<td>城市编码</td>
<td>输入城市的 adcode，adcode 信息可参考 <a href="https://lbs.amap.com/api/webservice/download">城市编码表</a></td>
<td>必填</td>
<td>无</td>
</tr>
<tr>
<td>extensions</td>
<td>气象类型</td>
<td>可选值：base&#x2F;allbase:返回实况天气all:返回预报天气</td>
<td>可选</td>
<td>无</td>
</tr>
<tr>
<td>output</td>
<td>返回格式</td>
<td>可选值：JSON,XML</td>
<td>可选</td>
<td>JSON</td>
</tr>
</tbody></table>
</li>
<li><p>返回案例结果，浦东新区为案例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;infocode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lives&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span> <span class="string">&quot;上海&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;浦东新区&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;adcode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;310115&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;weather&quot;</span><span class="punctuation">:</span> <span class="string">&quot;阴&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;temperature&quot;</span><span class="punctuation">:</span> <span class="string">&quot;19&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;winddirection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;西北&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;windpower&quot;</span><span class="punctuation">:</span> <span class="string">&quot;≤3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;humidity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;77&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;reporttime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-10-20 15:33:12&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;temperature_float&quot;</span><span class="punctuation">:</span> <span class="string">&quot;19.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;humidity_float&quot;</span><span class="punctuation">:</span> <span class="string">&quot;77.0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="前端展示"><a href="#前端展示" class="headerlink" title="前端展示"></a>前端展示</h4><p><img src="/../images/iotWaterPump/v2/2.png" alt="v2 show GD api"></p>
<h3 id="2-获取传感器数据（实时更新）"><a href="#2-获取传感器数据（实时更新）" class="headerlink" title="2. 获取传感器数据（实时更新）"></a>2. 获取传感器数据（实时更新）</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>使用Flask制作api。每次刷新即重新发送请求获取传感器数据。</li>
<li>服务器获取到的数据存进MySQL数据库，然后每次请求则返回数据库最新数据</li>
<li>使用实时通信技术<ol>
<li>WebSocket</li>
<li>ServerSentEvents</li>
</ol>
</li>
<li>前端直接使用mqtt库，获取数据。</li>
</ol>
<h3 id="3-数据可视化（折线图等方式）"><a href="#3-数据可视化（折线图等方式）" class="headerlink" title="3. 数据可视化（折线图等方式）"></a>3. 数据可视化（折线图等方式）</h3>]]></content>
      <categories>
        <category>软硬件结合</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>esp8266</tag>
        <tag>Iot</tag>
        <tag>物联网协议</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记</title>
    <url>/2024/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于计算机网络第八版，用于考试。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><p>1983年，ARPANET采用TCP&#x2F;IP，标志着互联网诞生</p>
</li>
<li><p><strong>ISP</strong>   互联网服务提供者 ISP (Internet Service Provider)</p>
</li>
<li><p><strong>IXP</strong>  互联网交换点，允许两个网络直接相连并快速交换分组。</p>
<ul>
<li>常采用工作在数据链路层的网络交换机。</li>
</ul>
</li>
<li><p><strong>万维网 (World Wide Web, 简称 WWW)</strong>   全球性的信息空间，人们可以通过互联网访问和共享信息</p>
</li>
</ul>
<h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><ol>
<li><p><strong>边缘部分</strong></p>
<p> ​	由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</p>
</li>
<li><p><strong>核心部分</strong></p>
<p> ​	由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</p>
</li>
</ol>
<h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><ul>
<li><strong>端系统</strong>  用户直接使用的设备和应用程序，它们包括个人电脑、手机、服务器等终端设备，用于发送或接收数据。端系统通过网络传输数据，与其他设备通信，实现互联网服务的交互。</li>
</ul>
<p>端系统中运行的程序之间的通信方式分为</p>
<ol>
<li>客户服务器方式（C&#x2F;S 方式）<ul>
<li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li>
<li>客户-服务器方式所描述的是进程之间服务和被服务的关系。</li>
<li>客户是服务的请求方，服务器是服务的提供方。</li>
<li><strong>客户端特点</strong><ol>
<li>被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。</li>
<li>不需要特殊的硬件和很复杂的操作系统</li>
</ol>
</li>
<li><strong>服务端特点</strong><ol>
<li>可同时处理多个远地或本地客户的请求。</li>
<li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</li>
<li>需要强大的硬件和高级的操作系统支持</li>
</ol>
</li>
</ul>
</li>
<li>对等方式（P2P 方式）   即 Peer-to-Peer方式  <ul>
<li><strong>特点</strong><ol>
<li>对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又是服务器。</li>
<li>对等连接工作方式可支持大量对等用户（如上百万个）同时工作。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p><strong>特点</strong></p>
<ul>
<li>是互联网中最复杂的部分</li>
<li>要向网络边缘中的大量主机提供连通性</li>
<li>在网络核心部分起特殊作用的是：路由器(router)</li>
<li>路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</li>
</ul>
<h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>​		<strong>面向连接，利用率很低</strong></p>
<p>电路交换分为三个阶段：</p>
<ol>
<li>建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；</li>
<li>通信：主叫和被叫双方就能互相通电话；</li>
<li>释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源）。</li>
</ol>
<h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p><strong>以分组为单位传输，采用存储转发技术。</strong></p>
<ol>
<li>在发送端，先把较长的报文划分成较短的、固定长度的数据段。</li>
<li>每一个数据段前面添加上首部构成分组(packet)。</li>
<li>每一个分组的首部都含有地址（诸如目的地址和源地址）等控制信息。</li>
<li>分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。</li>
<li>每个分组在互联网中独立地选择传输路径。</li>
<li>用这样的存储转发方式，最后分组就能到达最终目的地。</li>
</ol>
<p><strong>路由器处理分组的过程</strong></p>
<ol>
<li>把收到的分组先放入缓存（暂时存储）；</li>
<li>查找转发表，找出到某个目的地址应从哪个端口转发；</li>
<li>把分组送到适当的端口转发出去。</li>
</ol>
<p><strong>优点</strong></p>
<table>
<thead>
<tr>
<th><strong>高效</strong></th>
<th align="left">在分组传输的过程中<strong>动态分配</strong>传输带宽，对通信链路是逐段占用。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>灵活</strong></td>
<td align="left">为每一个分组<strong>独立</strong>地选择最合适的转发路由**<strong>。</strong></td>
</tr>
<tr>
<td><strong>迅速</strong></td>
<td align="left">以分组作为传送单位，可以<strong>不先建立连接</strong>就能向其他主机发送分组。</td>
</tr>
<tr>
<td><strong>可靠</strong></td>
<td align="left">保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</td>
</tr>
</tbody></table>
<p><strong>问题</strong></p>
<ol>
<li><p>分组在各结点存储转发时需要排队，这就会造成一定的时延。 </p>
</li>
<li><p>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。</p>
</li>
</ol>
<p>若要连续传送大量的数据，且其<strong>传送时间远大于连接建立时间，则电路交换的传输速率较快</strong>。报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。由于一个分组的长度往往远小于整个报文的长度，因此<strong>分组交换比报文交换的时延小，同时也具有更好的灵活性。</strong></p>
<h2 id="计算机网络类别"><a href="#计算机网络类别" class="headerlink" title="计算机网络类别"></a>计算机网络类别</h2><ul>
<li>个域网PAN（ Personal Area Network ）<ul>
<li>能在便携式消费电器与通信设备之间进行短距离通信的网络</li>
<li>覆盖范围一般在10米半径以内，如蓝牙耳机等</li>
</ul>
</li>
<li>局域网LAN（Local Area Network）<ul>
<li>局部地区形成的区域网络，如企业网络</li>
<li>分布地区范围有限，可大可小，大到一栋建筑、小到办公室内的组网电脑WLAN接入，打印机共享等等</li>
</ul>
</li>
<li>城域网MAN（Metropolitan Area Network ）<ul>
<li>范围覆盖一个城市的网络</li>
</ul>
</li>
<li>广域网WAN（Wide Area Network）<ul>
<li>覆盖很大地理区域，乃至覆盖地区和国家</li>
</ul>
</li>
</ul>
<h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><ol>
<li><p>速率</p>
<ol>
<li>数据的传送速率，它也称为数据率 (data rate)或比特率 (bit rate)。速率的单位是 bit&#x2F;s，或 kbit&#x2F;s、Mbit&#x2F;s、 Gbit&#x2F;s 等。例如 4  1010 bit&#x2F;s 的数据率就记为 40 Gbit&#x2F;s。</li>
<li>速率往往是指额定速率或标称速率，非实际运行速率。</li>
</ol>
</li>
<li><p>带宽</p>
<ol>
<li>在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit&#x2F;s ，即 “比特每秒”。</li>
</ol>
</li>
<li><p>吞吐率</p>
<ol>
<li>单位时间内通过某个网络（或信道、接口）的数据量。</li>
<li>吞吐量受网络的带宽或网络的额定速率的限制。</li>
</ol>
</li>
<li><p>时延</p>
<ol>
<li><p>数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p>
</li>
<li><p>组成部分</p>
<ol>
<li><p>发送时延</p>
<ol>
<li>从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</li>
<li><img src="/../images/computerNetwork/1.png" alt="formula"></li>
</ol>
</li>
<li><p>传播时延</p>
<p> <img src="/../images/computerNetwork/2.png" alt="formula"></p>
</li>
<li><p>处理时延</p>
<ol>
<li>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</li>
</ol>
</li>
<li><p>排队时延</p>
<ol>
<li>分组在路由器输入输出队列中排队等待处理所经历的时延。</li>
<li>排队时延的长短往往取决于网络中当时的通信量。</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>总时延</strong>  &#x3D; 	   发送时延  		+ 传播时延  		+ 处理时延  		+ 排队时延</p>
</li>
</ol>
</li>
<li><p>时延带宽积</p>
<ol>
<li><img src="/../images/computerNetwork/3.png" alt="formula"></li>
</ol>
</li>
<li><p>9 往返时间 RTT</p>
<ol>
<li>从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。</li>
<li>包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。</li>
</ol>
</li>
<li><p>利用率</p>
<ol>
<li>信道利用率<ol>
<li>某信道有百分之几的时间是被利用的（有数据通过）。</li>
<li>当某信道的利用率增大时，该信道引起的时延也就迅速增加。</li>
</ol>
</li>
<li>网络利用率<ol>
<li>全网络的信道利用率的加权平均值。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h3 id="计算机网络的分层"><a href="#计算机网络的分层" class="headerlink" title="计算机网络的分层"></a>计算机网络的分层</h3><ul>
<li><p>优点</p>
<ol>
<li>各层之间是独立的。</li>
<li>灵活性好。</li>
<li>结构上可分割开。</li>
<li>易于实现和维护。</li>
<li>能促进标准化工作。</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>降低效率。</li>
<li>有些功能会在不同的层次中重复出现，因而产生了额外开销。</li>
</ol>
</li>
</ul>
<h3 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h3><ol>
<li>应用层</li>
<li>运输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ol>
<ul>
<li><p><strong>对等层</strong>  任何两个同样的层次把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“对等层”(peer layers)之间的通信。</p>
</li>
<li><p><strong>协议数据单元 PDU</strong>   对等层次之间传送的数据单位</p>
</li>
<li><p><strong>实体</strong>  表示任何可发送或接收信息的硬件或软件进程。</p>
</li>
<li><p><strong>协议</strong>  是控制两个对等实体进行通信的规则的集合。</p>
</li>
<li><p><strong>服务访问点 SAP</strong>  同一系统相邻两层的实体进行交互的地方</p>
</li>
</ul>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>​	物理层考虑的是<strong>怎样才能在连接</strong>各种计算机的传输媒体上传输<strong>比特流数据</strong>，而不是指具体的传输媒体。尽可能地屏蔽掉不同传输媒体和通信手段的差异。</p>
<h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="数据通信系统模型"><a href="#数据通信系统模型" class="headerlink" title="数据通信系统模型"></a>数据通信系统模型</h3><ul>
<li><strong>数据通信系统包括三大部分：</strong><ol>
<li>源系统（或发送端、发送方）</li>
<li>传输系统（或传输网络）</li>
<li>目的系统（或接收端、接收方）</li>
</ol>
</li>
</ul>
<h3 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h3><blockquote>
<ol>
<li><strong>数据 (data)</strong> —— 运送消息的实体。</li>
<li><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。 </li>
<li><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。 </li>
<li><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。 </li>
<li><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li>
<li><strong>单向通信</strong>（单工通信）——只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>双向交替通信</strong>（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li><strong>双向同时通信</strong>（全双工通信）——通信的双方可以同时发送和接收信息。 </li>
<li><strong>基带信号（即基本频带信号）</strong>—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</li>
<li>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制 (modulation)。</li>
</ol>
<ul>
<li><strong>调制</strong><ol>
<li><strong>基带调制</strong>：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。</li>
<li><strong>带通调制</strong>：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。<strong>带通信号 ：</strong>经过载波调制后的信号。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>常用编码方式</strong></p>
<blockquote>
<ol>
<li><strong>不归零制：</strong>正电平代表 1，负电平代表 0。</li>
<li><strong>归零制：</strong>正脉冲代表 1，负脉冲代表 0。</li>
<li><strong>曼彻斯特编码：</strong>位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。<strong>具有自同步能力</strong></li>
<li><strong>差分曼彻斯特编码：</strong>在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 。<strong>具有自同步能力</strong></li>
</ol>
</blockquote>
<p><strong>基本的带通调制方法</strong></p>
<ul>
<li>最基本的二元制调制方法<ol>
<li>调幅(AM)：载波的振幅随基带数字信号而变化。 </li>
<li>调频(FM)：载波的频率随基带数字信号而变化。</li>
<li>调相(PM) ：载波的初始相位随基带数字信号而变化。</li>
</ol>
</li>
</ul>
<h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><p>​	码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。 </p>
<ul>
<li><p><strong>限制码元在信道上的传输速率的因素有以下两个：</strong></p>
<ol>
<li><p>信道能够通过的频率范围</p>
<ol>
<li><p><strong>奈氏准则</strong></p>
<p> <img src="/../images/computerNetwork/4.png" alt="formula"></p>
<p> 理想低通信道”即指理想的能让部分低频率信号通过的信道。W是理想低通信道的带宽,单位为赫(Hz);Baud是波特,是码元传输速率的单位,1波特为每秒传送1个码元.</p>
</li>
</ol>
</li>
<li><p>信噪比</p>
<ol>
<li>信噪比就是信号的平均功率和噪声的平均功率之比。</li>
<li><img src="/../images/computerNetwork/5.png" alt="formula"></li>
<li><strong>香农公式</strong>  带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率</li>
<li><img src="/../images/computerNetwork/6.png" alt="formula"><ol>
<li>信噪比越大，则信息的极限传输速率就越高。 	</li>
<li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><p>​	传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。</p>
<h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><p>​	电磁波被导引沿着固体媒体（铜线或光纤）传播。</p>
<p><strong>案例</strong></p>
<ol>
<li>双绞线<ol>
<li>模拟传输和数字传输</li>
<li>通信距离一般为几到十几公里</li>
<li>分为屏蔽双绞线 STP (Shielded Twisted Pair)和非屏蔽双绞线 UTP (Unshielded Twisted Pair)</li>
</ol>
</li>
<li>同轴电缆<ol>
<li>抗干扰特性，传输较高速率的数据。</li>
</ol>
</li>
<li>光缆<ol>
<li>多模光纤	可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤。</li>
<li>单模光纤    若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤。</li>
<li>通信容量非常大。</li>
<li>传输损耗小，中继距离长。</li>
<li>抗雷电和电磁干扰性能好。</li>
<li>无串音干扰，保密性好。</li>
<li>体积小，重量轻。</li>
</ol>
</li>
</ol>
<h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><p>​	电磁波的传输常称为无线传输，自由空间称为“非导引型传输媒体”。</p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>​	复用 (multiplexing) 是通信技术中的基本概念。它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p>
<h3 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h3><h4 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用  FDM"></a>频分复用  FDM</h4><pre><code>1. 将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。
1. 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）
</code></pre>
<h4 id="时分复用-TDM"><a href="#时分复用-TDM" class="headerlink" title="时分复用  TDM"></a>时分复用  TDM</h4><pre><code>1. 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。
1. 每一个用户所占用的时隙是周期性地出现（其周期就是 TDM  帧的长度）
1. 时分复用的所有用户是在不同的时间占用同样的频带宽度。 
</code></pre>
<ul>
<li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li>
</ul>
<h4 id="统计时分复用-STDM"><a href="#统计时分复用-STDM" class="headerlink" title="统计时分复用  STDM"></a>统计时分复用  STDM</h4><p>STDM 帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。</p>
<h3 id="波分复用-WDM"><a href="#波分复用-WDM" class="headerlink" title="波分复用  WDM"></a>波分复用  WDM</h3><pre><code> 波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号。
</code></pre>
<h3 id="码分复用-CDM"><a href="#码分复用-CDM" class="headerlink" title="码分复用  CDM"></a>码分复用  CDM</h3><p>​	常用的名词是码分多址 CDMA     (Code Division Multiple Access)。</p>
<p>​	各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</p>
<p>​	这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 </p>
<p>​	<strong>码片序列</strong></p>
<ul>
<li>每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。</li>
<li>码片序列实现了扩频</li>
</ul>
<h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><p>​	与模拟通信相比，数字通信在抗干扰性，保密性方面有明显的优势。</p>
<ul>
<li><strong>脉冲编码调制PCM</strong></li>
</ul>
<p>终端用户（如电话的语音信号）的模拟数据转换成数字数据，以适合主干线的传输。</p>
<h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><h3 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h3><ul>
<li><p><strong>非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line)</strong> </p>
</li>
<li><p>ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</p>
</li>
<li><p>DSL 的传输距离取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大）。</p>
</li>
<li><p><strong>特点</strong></p>
<ul>
<li>上行和下行带宽做成不对称的。</li>
<li>ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。</li>
</ul>
</li>
</ul>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>数据链路层使用的信道主要有以下两种类型：</p>
<ol>
<li><strong>点对点信道。</strong>这种信道使用一对一的点对点通信方式。</li>
<li><strong>广播信道。</strong>这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li>
</ol>
<h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><ul>
<li><p><strong>链路 (link)</strong> 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</p>
</li>
<li><p><strong>数据链路 (data link)</strong> 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
</li>
</ul>
<h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>​	在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</p>
<p>​	首部和尾部的一个重要作用就是进行<strong>帧定界。</strong></p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>​	如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。</p>
<ul>
<li><strong>解决透明传输问题</strong><ul>
<li><strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)。</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>​	在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。</p>
<ul>
<li><p><strong>误码率 BER (Bit Error Rate)。</strong> 在一段时间内，传输错误的比特占所传输比特总数的比率</p>
</li>
<li><p><strong>循环冗余检验</strong></p>
<ul>
<li>原理<ul>
<li>在发送端，先把数据划分为组。假定每组 k 个比特。 </li>
<li>设待传送的一组数据 M &#x3D; 101001（现在 k &#x3D; 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。</li>
<li>用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。</li>
<li>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。 </li>
<li>将余数 R 作为冗余码拼接在数据 M 后面发送出去。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1>]]></content>
      <categories>
        <category>软硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>英文演讲</title>
    <url>/2024/10/03/%E8%8B%B1%E6%96%87%E6%BC%94%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="便于随时阅读"><a href="#便于随时阅读" class="headerlink" title="便于随时阅读"></a><strong>便于随时阅读</strong></h1><p>Today is my 40th birthday.<br>0:02<br>And if I could go back to talk to my younger 20 year old self<br>0:06<br>and give him some advice, here are 40 things that I would say.<br>Make sure you are climbing the right mountain<br>0:10<br>Number one, make sure you are climbing the right mountain.<br>0:14<br>Too many of us are exhausted<br>0:17<br>because we are doing too little of the things that bring us joy<br>0:20<br>and are chasing someone else’s definition of success.<br>0:23<br>This is why it is far better to be climbing slowly<br>0:26<br>up the right mountain than it is to be climbing fast up the wrong mountain.<br>0:30<br>When you focus on direction over speed,<br>0:33<br>you will find greater enjoyment in the journey.<br>Stop making your health a side hustle<br>0:36<br>Number two.<br>0:37<br>Stop making your health a side hustle.<br>0:39<br>moment that you sacrifice your health<br>0:42<br>is the moment that your overall well-being begins to deteriorate.<br>0:45<br>Your health is the most valuable asset you have.<br>0:49<br>Without it, nothing else matters.<br>0:51<br>Life is hard enough as it is.<br>0:54<br>Don’t make it harder by not looking after yourself.<br>0:56<br>Energy, you see, is earned and not given.<br>1:00<br>And it is earned by sleeping more,<br>1:03<br>eating better and exercising on a daily basis.<br>1:06<br>So work with your body, not against it.<br>1:09<br>If not, you will eventually be faced with no choice<br>1:13<br>but to spend a lot of time dealing with illness later in life.<br>Designing your life begins with designing your days<br>1:16<br>Number three, how you spend your days is how you spend your life.<br>1:21<br>If you are not prioritizing the daily actions necessary to achieve<br>1:25<br>your goals, you will never arrive at where you would like to be.<br>1:29<br>I mean, how can tomorrow be any better than today<br>1:32<br>if you don’t do anything different today.<br>1:34<br>You will never change your life for the better<br>1:37<br>unless you change something you do daily.<br>1:40<br>So care less<br>1:41<br>about results and more about your daily habits.<br>1:45<br>Because world class results automatically follow world class habits.<br>1:51<br>And this leads me on to Number four,<br>Take responsibility for your life<br>1:53<br>take responsibility for your life.<br>1:56<br>No one is coming to save you.<br>1:59<br>And this is why you must step up and become the hero of your own life.<br>2:03<br>Taking full ownership of your life is the most empowering thing<br>2:07<br>that you can do Because the pain of doing nothing with your life<br>2:11<br>will always be worse than the pain of doing something with your life.<br>2:15<br>Most people, unfortunately, are allergic to personal responsibility,<br>2:19<br>preferring instead to complain and blame.<br>2:23<br>Don’t be most people.<br>Have a bias to action<br>2:24<br>Number five have a bias to action.<br>2:27<br>The only real failure in life<br>2:30<br>is never trying or taking action on the things that matter most to you.<br>2:35<br>The average human life is short (right now globally,<br>2:38<br>it is at 73 years) and so you only have one shot at this.<br>2:43<br>We all know deep down that life is short<br>2:47<br>and we will face death eventually.<br>2:49<br>But few of us appreciate this.<br>2:52<br>If we did, we would make very different decisions.<br>2:56<br>Losing my mom at just 17 years old taught me the fragility of life.<br>3:01<br>The future is never guaranteed, and the loss<br>3:04<br>taught me the importance of living in the present.<br>3:07<br>Time is something we can’t make more of.<br>3:10<br>So we must be careful about what we decide to give up a day of our life for.<br>3:15<br>Because once it is gone, it is gone forever.<br>3:18<br>And this leads nicely onto number six.<br>Extraordinary results come from repeating ordinary actions over an unordinary amount of time<br>3:21<br>Extraordinary results come from repeating<br>3:24<br>ordinary actions over an unordinary amount of time.<br>3:28<br>Much of success in life, you see, is built by consistently doing the work<br>3:32<br>that most are not willing to do.<br>3:34<br>And if you can’t do something consistently over a long period of time,<br>3:39<br>you probably won’t succeed at it.<br>3:40<br>There is no such thing as an overnight success,<br>3:44<br>only over time success.<br>3:46<br>So be patient with the process and impatient with taking action.<br>Choose your life partner wisely<br>3:50<br>Number seven, choose your life partner wisely.<br>3:53<br>Ryan Holiday wrote an article in 2015 called “The Perfect Spouse is the Best<br>3:59<br>Life Hack No One Told You About.” And I would have to agree with his thoughts<br>4:03<br>because without having my wife, Laurie by my side,<br>4:06<br>I would not be enjoying many of the things that I get to experience today.<br>4:09<br>We have been together for nearly two decades.<br>4:12<br>My success is our success.<br>4:14<br>Her success is our success.<br>4:18<br>And when faced with challenges and setbacks,<br>4:21<br>we look to overcome and learn from them as a team.<br>4:23<br>When choosing a life partner, therefore, be with someone who shares the same values<br>4:28<br>as you and who is also focused on being better than who they were yesterday.<br>The hardest times in life equip you with the wisdom to create the best moments of your life<br>4:33<br>Number eight, the hardest times in life equip<br>4:36<br>you with the wisdom to create the best moments of your life.<br>4:39<br>Just because your past was hard does not mean your future cannot be amazing.<br>4:44<br>It is from life’s inevitable challenges that you enjoy<br>4:47<br>your greatest personal growth, and discover more about who you truly are.<br>4:52<br>And the tougher the times, the more clarity you get<br>4:57<br>about what really matters and what doesn’t.<br>Public speaking is one of the most powerful skills you can develop<br>5:00<br>Number nine,<br>5:00<br>public speaking is one of the most powerful skills that you can develop.<br>5:04<br>Your ability to touch people’s hearts and minds by educating<br>5:09<br>and inspiring them will open you up to a world of opportunities.<br>5:13<br>So develop your storytelling skills and watch your career blossom.<br>Speak to yourself in the same way you would to someone you deeply care about<br>5:17<br>Number ten.<br>5:18<br>Speak to yourself in the same way you would to someone you deeply care about.<br>5:23<br>This is because the most powerful dialogue that happens<br>5:27<br>is the one within yourself each day.<br>5:30<br>Your mind can be your best friend or your worst enemy.<br>One of the best ways to advance your life is to simplify it<br>5:33<br>Number 11.<br>5:34<br>One of the best ways to advance your life is to simplify it Less clutter -<br>5:40<br>physical, mental and digital - paves the way<br>5:43<br>for clearer thinking and more focused action<br>5:47<br>because nobody performs well when pulled in a dozen different directions.<br>Be fully present when spending quality time with people, especially your loved ones<br>5:51<br>Number 12 be fully present when spending quality time with people,<br>5:56<br>especially your loved ones.<br>5:57<br>One of the greatest gifts that you can give people<br>6:01<br>is the feeling that they’ve been heard, understood, and appreciated.<br>6:05<br>This is because people do not want your time<br>6:08<br>as much as they want your presence and energy.<br>6:11<br>So wherever you are, be there.<br>6:14<br>Whether that is having dinner with a friend, playing<br>6:17<br>with your children, or spending quality time with your partner.<br>The only competition that matters in life is with yourself<br>6:20<br>Number 13.<br>6:22<br>The only competition that matters in life is with yourself.<br>6:26<br>Yesterday’s you, last month’s you, last year’s you.<br>6:27<br>Focus<br>6:31<br>on outdoing your past self and you will flourish.<br>6:34<br>And if you are going to look at others,<br>6:36<br>look at them for inspiration, not comparison.<br>Not everyone will like you<br>6:40<br>Number 14.<br>6:41<br>Not everyone will like you.<br>6:43<br>And that’s okay When you put yourself out there, you will always have some people<br>6:48<br>that will hate<br>6:50<br>you whatever you do.<br>6:50<br>That’s okay. You’re not ice cream.<br>6:53<br>You can’t please everyone.<br>6:55<br>You can’t escape being judged.<br>6:57<br>So you might as well live a life true to yourself.<br>7:00<br>Not a life lived for others. Number 15.<br>Get clear on your priorities and productivity becomes easy<br>7:03<br>Get clear on your priorities and productivity becomes easy.<br>7:07<br>How will you know that today will have been a productive day?<br>7:11<br>Begin with the end in mind, work backwards and move forwards with purpose.<br>Be bold and take some risks<br>7:16<br>Number 16. Be bold and take some risks.<br>7:19<br>Not all risk takers will be winners, but all winners are risk takers.<br>7:24<br>If you want to enjoy a life the most can’t, you must do what most won’t.<br>7:29<br>So be bold and start stretching yourself out of your comfort zones.<br>7:33<br>Put that ask out there.<br>7:35<br>Start on the idea that you’ve been thinking about for so long.<br>7:39<br>Go to that event.<br>7:40<br>Say yes to that opportunity.<br>7:43<br>Do this every day and your life will flourish.<br>You get what you focus your energy on<br>7:46<br>Number 17.<br>7:47<br>You get what you focus your energy on.<br>7:49<br>Focus on things to complain about, and you will attract more things<br>7:53<br>into your life to complain about.<br>7:55<br>Focus on things to be grateful for and you will attract more things<br>7:59<br>into your life to be grateful for.<br>Be prepared for the best laid plans to not go the way you expect<br>8:00<br>Number 18 Be prepared for<br>8:03<br>the best laid plans to not go the way you expect.<br>8:07<br>I wanted to develop a successful career in finance after graduating from university<br>8:12<br>and then the financial crisis happened, which was actually a blessing in disguise.<br>8:16<br>Otherwise, I wouldn’t be sitting here right now talking to you.<br>8:19<br>And my friend opened a new restaurant four months before the COVID pandemic<br>8:23<br>Shut everything down.<br>8:24<br>Sometimes life doesn’t go according to plan,<br>8:28<br>and it ends up being the best thing that has ever happened to you.<br>8:32<br>The harsh reality is that when you commit to doing something with your life,<br>8:37<br>you will face inevitable setbacks and failures.<br>8:40<br>However how you respond to them will be the difference<br>8:43<br>between giving up too early and bouncing back stronger<br>8:47<br>from the wisdom that you have gained from that experience.<br>8:51<br>Which leads me nicely onto Number 19.<br>Don’t fear failure, fear regret<br>8:54<br>Don’t fear failure, fear regret.<br>8:57<br>More often than not,<br>8:58<br>success is born out of a series of setbacks, wrong turns and failures.<br>9:03<br>So when you avoid taking action because you are afraid of failure,<br>9:08<br>you actually hurt your chances for success.<br>9:10<br>There is a beautiful Japanese saying that goes: if you feel like<br>9:14<br>you are losing everything, remember this: trees lose their leaves every year.<br>9:21<br>Yet they still stand tall, waiting for better days to come.<br>The purpose of life is a life of purpose<br>9:25<br>Number 20.<br>9:26<br>The purpose of life is a life of purpose.<br>9:29<br>You were not born into this world to just pay bills, scroll aimlessly through<br>9:34<br>social media feeds, watch television, do things you hate, and then die.<br>9:39<br>You were born with unique gifts and talents, and it is life’s greatest<br>9:44<br>adventure to discover what these are and to share them with the world.<br>9:48<br>Don’t go through life accepting that five out of seven days<br>9:53<br>are going to be spent doing something that does not bring you joy or fulfillment.<br>9:57<br>Live each day with intention so that you own your days<br>10:01<br>rather than your days owning you Number 21.<br>Knowing yourself is the beginning of true wisdom<br>10:04<br>Knowing yourself is the beginning of true wisdom.<br>10:08<br>This is because you can’t have self-development without self-awareness.<br>10:13<br>For you can’t change what you are not aware of.<br>10:16<br>Number 22.<br>10:17<br>On the days where it feels like you will never make progress.<br>10:20<br>Just remember how far you have come.<br>Remember how far you have come<br>10:23<br>If you can’t be grateful for what you currently have,<br>10:27<br>you will never have enough.<br>10:28<br>Appreciate where you are in your journey,<br>10:31<br>even if it is not where you want to be.<br>10:34<br>For every season serves a purpose.<br>Stop filling your calendar with junk<br>10:36<br>Number 23.<br>10:38<br>Stop filling your calendar with junk.<br>10:40<br>If you want your life to change, you must make space for it to happen.<br>10:45<br>Nothing more can be added to a full calendar, a calendar<br>10:48<br>that can often be filled with things that you have said yes to,<br>10:52<br>just to please other people and activities that would take you away from<br>10:56<br>the very things that will help you make progress towards where you want to be.<br>Do the work<br>11:00<br>Number 24.<br>11:02<br>If you did the work that you are currently avoiding,<br>11:05<br>you would have the results that you want At a minimum,<br>11:08<br>you will always end up in a better place by doing the work than avoiding it.<br>11:12<br>Overthinking, on the other hand, is the death of all great ideas and<br>11:16<br>opportunities.<br>11:17<br>You don’t have to have it all figured out in order to move forward.<br>11:20<br>The clarity you seek will come from the action that you take,<br>11:25<br>and the next piece of advice will help with this.<br>Get important tasks done early in the day<br>11:27<br>Number 25<br>11:29<br>get important tasks done early in the day when your energy is at its highest.<br>11:33<br>Once these are done, whatever else happens later in the day,<br>11:37<br>you will have already had a productive day.<br>Have patience with the journey ahead<br>11:39<br>Number 26.<br>11:41<br>Have patience with the journey ahead To become a success story,<br>11:45<br>you must be willing to look stupid<br>11:47<br>and like a beginner for a long time before you start getting things right.<br>11:50<br>Too many people ignore their dreams because they dislike<br>11:54<br>the idea of being a beginner and learning slowly.<br>11:57<br>So don’t let impatience and the fear of embarrassment<br>12:02<br>become the biggest hurdle to your growth.<br>12:04<br>Sometimes it takes ten years to get that one year<br>12:08<br>that will completely change your life.<br>Act from your future, not your past<br>12:10<br>Number 27 Act from your future, not your past.<br>12:14<br>Let’s fast forward to a year from now and imagine that your life is the best<br>12:18<br>that it has ever been as a result of your own intentional choices.<br>12:23<br>What choices did you make today and in the coming weeks and months<br>12:27<br>that made this reality a possibility for you?<br>Level up your network<br>12:31<br>Number 28.<br>12:32<br>Level up your network.<br>12:34<br>The fastest way to make meaningful progress<br>12:37<br>in any area of your life is to design an environment around you<br>12:41<br>that makes it impossible not to succeed Your circle of friends<br>12:45<br>will also change as you grow.<br>12:47<br>And this is all part of the personal development journey.<br>12:50<br>It is why your new life will cost you your old one.<br>12:53<br>It is part of your evolution<br>12:55<br>and becoming as you move into the next phase of your growth.<br>12:59<br>Not everyone is focused on being better than who they were yesterday,<br>13:03<br>and that’s okay.<br>Commit to learning on a daily basis<br>13:04<br>Number 29.<br>13:06<br>Commit to learning on a daily basis.<br>13:08<br>There is this 100 hour rule which states<br>13:11<br>that if you spend 100 hours a year deepening your knowledge<br>13:15<br>in your chosen discipline (which is around 18 minutes a day),<br>13:19<br>you will be better than 95% of the world in that discipline.<br>13:24<br>So what will you spend your 18 minutes today learning about?<br>You are the architect of your destiny<br>13:28<br>Number 30.<br>13:29<br>You are the architect of your destiny.<br>13:32<br>You are both the sculpture and the sculptor<br>13:34<br>with your thoughts shaping your entire reality.<br>13:38<br>Your thoughts, therefore, can either be the gateway<br>13:41<br>to limitless achievement or a prison cell for your potential.<br>Make a difference, not just a living<br>13:45<br>Number 31.<br>13:47<br>Focus on making a difference, not just a living.<br>13:50<br>Your value is determined by<br>13:52<br>how much more you have given to the world than you have taken from it.<br>13:56<br>Add value to people’s each day,<br>13:58<br>however small, and watch your life transform.<br>Unknown paths often lead to the most rewarding journeys<br>14:01<br>Number 32.<br>14:02<br>Unknown paths often lead to the most rewarding journeys.<br>14:06<br>When you surrender to the unknown, you allow yourself to explore and experiment.<br>14:11<br>So be open to new experiences, constantly meet new people, try stuff<br>14:17<br>just because it is interesting and fun, and do a few things<br>14:21<br>that you will be excited to tell your kids about someday.<br>Spending money on things you don’t need to impress others is the fastest way to go broke<br>14:23<br>Number 33.<br>14:25<br>Spending money on things you don’t need or want<br>14:29<br>just to impress others is the fastest way to go broke.<br>14:32<br>Instead, learn how to invest and then put that money to work for you<br>14:37<br>so you can grow your financial wealth over time.<br>14:39<br>This way you are able to tap into the power of the compound effect.<br>14:44<br>The eighth wonder of this world.<br>14:46<br>Just look at Warren Buffett,<br>14:47<br>one of the most successful investors the world has seen.<br>14:51<br>99% of his current wealth was created after his 50th birthday.<br>Do stuff that makes you feel alive<br>14:56<br>Number 34.<br>14:57<br>Do stuff that makes you feel alive.<br>15:00<br>Focus your energy on things that make you come alive<br>15:04<br>and away from the things that make you miserable.<br>15:07<br>This is key to fulfilling your potential.<br>You will have good seasons and bad seasons<br>15:09<br>Number 35.<br>15:10<br>You will have good seasons and bad seasons.<br>15:13<br>You can’t control the weather, only be prepared for it.<br>15:16<br>And this leads me to Number 36.<br>Don’t tie your emotional wellbeing to an outcome that may or may not happen<br>15:19<br>Don’t tie your emotional well-being to something in the future<br>15:23<br>that may or may not happen.<br>15:24<br>Doing so will mean that you will end up living as if you are never going to die<br>15:29<br>and then die having never truly lived.<br>15:31<br>And your present will be full of anxiety, frustration and stress.<br>15:36<br>Inner peace comes from accepting what you can’t control<br>15:39<br>and focusing your energy instead on what you can.<br>Listen to your heart<br>15:42<br>Number 37. Listen to your heart.<br>15:45<br>There is a reason why the longest journey you will make<br>15:49<br>are the inches from your head to your heart.<br>15:51<br>Too often we ignore our intuition and innate wisdom<br>15:55<br>and place too much importance on the opinions of others,<br>15:58<br>many of whom have not succeeded in what you are trying to do with your life.<br>16:03<br>In fact… Number 38.<br>Don’t take advice from those who haven’t done what you are trying to do<br>16:05<br>Don’t take advice from those who haven’t done what you are trying to do.<br>16:10<br>Everyone has advice to share with you.<br>16:13<br>Just make sure you are taking it from someone who has been in the arena<br>16:17<br>and not sitting on the sidelines as a spectator.<br>Leadership begins with you<br>16:20<br>Number 39.<br>16:21<br>Leadership begins with you.<br>16:24<br>You cannot be an effective leader of others<br>16:27<br>if you are not powerfully leading yourself first.<br>16:30<br>Lead yourself by living with intention each day.<br>16:33<br>And very soon your life will transform in the most magical of ways.<br>16:38<br>And this begins with taking care of your physical and mental energy,<br>16:42<br>for you can’t give what you don’t have.<br>16:44<br>And finally, number 40, It is never too late to make a change.<br>It is never too late to make a change<br>16:49<br>At some point you have to be honest<br>16:52<br>about the gap between the life you want to live,<br>16:55<br>and the life that your daily habits are currently leading you towards.<br>16:59<br>If your habits are causing that gap to widen, then do something about it.<br>17:03<br>It is never too late to make changes in your life to close that gap<br>17:08<br>between where you are now and where you want to be.<br>17:11<br>I hope you found this video useful.<br>17:13<br>Choose a few to implement this week<br>17:16<br>and see how simple adjustments to the way you operate can create dramatic change.<br>17:21<br>And make sure to keep this in mind.<br>17:23<br>You will suck at most things in the beginning With commitment,<br>17:27<br>consistency, persistence and patience,<br>17:30<br>however, anything becomes possible.<br>17:33<br>if you enjoyed this video,<br>17:35<br>it would be amazing<br>17:36<br>if you could subscribe, leave a comment below and give it a like.<br>17:40<br>Thank you for watching this far and I will see you in the next video.</p>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英文</tag>
        <tag>演讲稿</tag>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础</title>
    <url>/2024/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本部分计算机网络笔记用于学习和应用。</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><table>
<thead>
<tr>
<th>特性</th>
<th>TCP (传输控制协议)</th>
<th>UDP (用户数据报协议)</th>
</tr>
</thead>
<tbody><tr>
<td>连接方式</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠性</td>
<td>提供可靠的数据传输，保证数据完整性</td>
<td>不保证数据的可靠性</td>
</tr>
<tr>
<td>流量控制</td>
<td>支持流量控制和拥塞控制</td>
<td>不支持流量控制</td>
</tr>
<tr>
<td>数据顺序</td>
<td>保证数据的顺序</td>
<td>不保证数据的顺序</td>
</tr>
<tr>
<td>速度</td>
<td>较慢，由于需要建立连接和确认</td>
<td>较快，没有建立连接的延迟</td>
</tr>
<tr>
<td>适用场景</td>
<td>适合需要可靠传输的应用，如网页、文件传输</td>
<td>适合实时应用，如视频会议、在线游戏</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>TCP数据包的结构</strong></p>
<ul>
<li><p><strong>头部</strong>：通常为20字节，包含以下字段：</p>
<ul>
<li><strong>源端口</strong>（16位）：发送端的端口号。</li>
<li><strong>目的端口</strong>（16位）：接收端的端口号。</li>
<li><strong>序列号</strong>（32位）：用于数据重组和控制。</li>
<li><strong>确认号</strong>（32位）：期望收到的下一个字节的序列号。</li>
<li><strong>数据偏移</strong>（4位）：头部长度。</li>
<li><strong>保留位</strong>（6位）：保留用于未来使用。</li>
<li><strong>控制位</strong>（6位）：包括URG、ACK、PSH、RST、SYN、FIN等，用于控制连接。</li>
<li><strong>窗口大小</strong>（16位）：流量控制中的窗口大小。</li>
<li><strong>校验和</strong>（16位）：用于检测传输中的错误。</li>
<li><strong>紧急指针</strong>（16位）：指示紧急数据的偏移量（如果URG标志设置）。</li>
<li><strong>选项</strong>：可选字段，长度可变。</li>
</ul>
<p>  <strong>数据部分</strong>：包含实际传输的数据。</p>
</li>
</ul>
</li>
<li><p><strong>UDP数据包结构</strong></p>
<ul>
<li><strong>头部</strong>: 固定为8字节，包含以下字段：<ul>
<li><strong>源端口</strong>（16位）：发送端的端口号。</li>
<li><strong>目的端口</strong>（16位）：接收端的端口号。</li>
<li><strong>长度</strong>（16位）：UDP头部和数据部分的总长度。</li>
<li><strong>校验和</strong>（16位）：用于检测传输中的错误。</li>
</ul>
</li>
<li><strong>数据部分</strong>：包含实际传输的数据。</li>
</ul>
</li>
</ul>
<h3 id="TCP的三次握手和四次挥手机制"><a href="#TCP的三次握手和四次挥手机制" class="headerlink" title="TCP的三次握手和四次挥手机制"></a>TCP的三次握手和四次挥手机制</h3><h4 id="一、TCP-三次握手（连接建立）"><a href="#一、TCP-三次握手（连接建立）" class="headerlink" title="一、TCP 三次握手（连接建立）"></a>一、TCP 三次握手（连接建立）</h4><p>三次握手的目的是为了保证客户端和服务器双方都确认对方收到了自己的请求，成功建立可靠的连接。过程如下：</p>
<ol>
<li><p>第一次握手</p>
<p> ：</p>
<ul>
<li>客户端向服务器发送一个 <strong>SYN</strong>（同步）报文，表示要建立连接。此时客户端进入 <strong>SYN_SENT</strong> 状态。</li>
</ul>
</li>
<li><p>第二次握手</p>
<p> ：</p>
<ul>
<li>服务器收到客户端的 SYN 报文后，确认收到，回复一个 <strong>SYN-ACK</strong> 报文，表示同意建立连接并确认 SYN。此时服务器进入 <strong>SYN_RCVD</strong> 状态。</li>
</ul>
</li>
<li><p>第三次握手</p>
<p> ：</p>
<ul>
<li>客户端收到服务器的 SYN-ACK 报文后，发送一个 <strong>ACK</strong>（确认）报文，确认服务器的响应。此时，客户端进入 <strong>ESTABLISHED</strong>（连接已建立）状态，服务器收到 ACK 后也进入 <strong>ESTABLISHED</strong> 状态。</li>
</ul>
</li>
</ol>
<p>这三次握手的主要目的是确认双方的发送、接收能力和初始化序列号的同步。</p>
<h4 id="二、TCP-四次挥手（连接关闭）"><a href="#二、TCP-四次挥手（连接关闭）" class="headerlink" title="二、TCP 四次挥手（连接关闭）"></a>二、TCP 四次挥手（连接关闭）</h4><p>四次挥手的目的是保证双方都确认连接已经正常关闭。其步骤如下：</p>
<ol>
<li><p>第一次挥手</p>
<p> ：</p>
<ul>
<li>当客户端想要关闭连接时，发送一个 <strong>FIN</strong>（结束）报文，表示不再发送数据。此时客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
</ul>
</li>
<li><p>第二次挥手</p>
<p> ：</p>
<ul>
<li>服务器收到 FIN 报文后，确认收到，回复一个 <strong>ACK</strong> 报文。此时服务器进入 <strong>CLOSE_WAIT</strong> 状态，客户端收到 ACK 后进入 <strong>FIN_WAIT_2</strong> 状态。</li>
</ul>
</li>
<li><p>第三次挥手</p>
<p> ：</p>
<ul>
<li>服务器在确认客户端不再发送数据后，也发送一个 <strong>FIN</strong> 报文，表示自己也不再发送数据。此时服务器进入 <strong>LAST_ACK</strong> 状态。</li>
</ul>
</li>
<li><p>第四次挥手</p>
<p> ：</p>
<ul>
<li>客户端收到服务器的 FIN 报文后，发送 <strong>ACK</strong> 报文确认。此时客户端进入 <strong>TIME_WAIT</strong> 状态，等待一段时间（通常为 2 倍的报文最大生存时间，即 2MSL）以确保服务器接收到了 ACK，之后客户端进入 <strong>CLOSED</strong> 状态，连接关闭。</li>
</ul>
</li>
</ol>
<p>服务器收到 ACK 后，也进入 <strong>CLOSED</strong> 状态，至此连接完全关闭。</p>
<h3 id="使用TCP-IP协议进行通信（基于python）"><a href="#使用TCP-IP协议进行通信（基于python）" class="headerlink" title="使用TCP&#x2F;IP协议进行通信（基于python）"></a>使用TCP&#x2F;IP协议进行通信（基于python）</h3><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TCP服务器的socket对象</span></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定IP地址和端口号</span></span><br><span class="line">server_socket.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">12345</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始监听</span></span><br><span class="line">server_socket.listen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TCP服务器启动，等待客户端连接...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待客户端连接</span></span><br><span class="line">client_socket, addr = server_socket.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;连接建立，客户端地址: <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收数据</span></span><br><span class="line">data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;收到的数据: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送响应</span></span><br><span class="line">client_socket.send(<span class="string">&quot;你好，客户端！&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">client_socket.close()</span><br><span class="line">server_socket.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="TCP客户端："><a href="#TCP客户端：" class="headerlink" title="TCP客户端："></a>TCP客户端：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TCP客户端的socket对象</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接服务器</span></span><br><span class="line">client_socket.connect((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">12345</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据</span></span><br><span class="line">client_socket.send(<span class="string">&quot;你好，服务器！&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收服务器的响应</span></span><br><span class="line">data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;从服务器收到的响应: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">client_socket.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="使用TCP-IP协议进行网络聊天（基于python）"><a href="#使用TCP-IP协议进行网络聊天（基于python）" class="headerlink" title="使用TCP&#x2F;IP协议进行网络聊天（基于python）"></a>使用TCP&#x2F;IP协议进行网络聊天（基于python）</h3><h4 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">clients = []</span><br><span class="line">usernames = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_client</span>(<span class="params">client_socket</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 接收客户端发送的数据</span></span><br><span class="line">            message = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> message:</span><br><span class="line">                broadcast(message, client_socket)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                remove_client(client_socket)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">broadcast</span>(<span class="params">message, client_socket</span>):</span><br><span class="line">    <span class="keyword">for</span> client <span class="keyword">in</span> clients:</span><br><span class="line">        <span class="keyword">if</span> client != client_socket:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                client.send(message)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                remove_client(client)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_client</span>(<span class="params">client_socket</span>):</span><br><span class="line">    index = clients.index(client_socket)</span><br><span class="line">    clients.remove(client_socket)</span><br><span class="line">    username = usernames[index]</span><br><span class="line">    usernames.remove(username)</span><br><span class="line">    broadcast(<span class="string">f&quot;<span class="subst">&#123;username&#125;</span> 退出了聊天！&quot;</span>.encode(), client_socket)  <span class="comment"># 传递 client_socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_server</span>():</span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_socket.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">12345</span>))</span><br><span class="line">    server_socket.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;聊天服务器启动，等待连接...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket, addr = server_socket.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;客户端 <span class="subst">&#123;addr&#125;</span> 连接。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 让客户端输入用户名</span></span><br><span class="line">        client_socket.send(<span class="string">&quot;请输入用户名：&quot;</span>.encode())</span><br><span class="line">        username = client_socket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">        usernames.append(username)</span><br><span class="line">        clients.append(client_socket)</span><br><span class="line">        broadcast(<span class="string">f&quot;<span class="subst">&#123;username&#125;</span> 加入了聊天！&quot;</span>.encode(), client_socket)  <span class="comment"># 传递 client_socket</span></span><br><span class="line"></span><br><span class="line">        thread = threading.Thread(target=handle_client, args=(client_socket,))</span><br><span class="line">        thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_server()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="TCP客户端：-1"><a href="#TCP客户端：-1" class="headerlink" title="TCP客户端："></a>TCP客户端：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receive_messages</span>(<span class="params">client_socket</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            message = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> message:</span><br><span class="line">                <span class="built_in">print</span>(message.decode())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;连接到服务器失败。&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_client</span>():</span><br><span class="line">    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client_socket.connect((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">12345</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入用户名</span></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    client_socket.send(username.encode())</span><br><span class="line"></span><br><span class="line">    thread = threading.Thread(target=receive_messages, args=(client_socket,))</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        message = <span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> message.lower() == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        client_socket.send(<span class="string">f&quot;<span class="subst">&#123;username&#125;</span>: <span class="subst">&#123;message&#125;</span>&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">    client_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_client()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>软硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>民谣吉他即兴笔记</title>
    <url>/2024/10/06/%E6%B0%91%E8%B0%A3%E5%90%89%E4%BB%96%E5%8D%B3%E5%85%B4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="节奏型武器库"><a href="#节奏型武器库" class="headerlink" title="节奏型武器库"></a>节奏型武器库</h1><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1852844021&bvid=BV1Mp421977n&cid=1496964053&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<p>【【吉他就该这么玩】节奏太单调？学会它你能弹所有流行歌！扫弦&amp;分解节奏型汇总 伴奏武器库】 <a href="https://www.bilibili.com/video/BV1Mp421977n/?share_source=copy_web&vd_source=7a16ec5db4e5a23503ea8070ff118363">https://www.bilibili.com/video/BV1Mp421977n/?share_source=copy_web&amp;vd_source=7a16ec5db4e5a23503ea8070ff118363</a></p>
<h2 id="分解和弦"><a href="#分解和弦" class="headerlink" title="分解和弦"></a>分解和弦</h2><p>使用的和弦</p>
<p><img src="/../images/guitar/1.png" alt="和弦"></p>
<ul>
<li>节奏型</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol>
<li><p><img src="/../images/guitar/2.png" alt="1"></p>
</li>
<li><p><img src="/../images/guitar/3.png" alt="2"></p>
</li>
<li><p><img src="/../images/guitar/4.png" alt="3"></p>
</li>
<li><p><img src="/../images/guitar/5.png" alt="4"></p>
</li>
<li><p><img src="/../images/guitar/6.png" alt="6"></p>
</li>
<li><p><img src="/../images/guitar/7.png" alt="6"></p>
</li>
<li><p><img src="/../images/guitar/8.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/9.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/10.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/11.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/11.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/12.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/13.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/14.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/15.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/16.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/17.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/18.png" alt="和弦"></p>
</li>
<li><p><img src="/../images/guitar/19.png" alt="和弦"></p>
</li>
</ol>
<h2 id="扫弦节奏型"><a href="#扫弦节奏型" class="headerlink" title="扫弦节奏型"></a>扫弦节奏型</h2><p><img src="/../images/guitar/20.png" alt="和弦"></p>
<ol>
<li><p><img src="/../images/guitar/21.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/22.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/23.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/24.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/25.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/26.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/27.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/28.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/29.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/30.png" alt="扫弦"></p>
</li>
<li><p><img src="/../images/guitar/31.png" alt="扫弦"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>生活</category>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>吉他</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE前端项目笔记</title>
    <url>/2024/09/26/VUE%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>项目地址：<a href="https://github.com/creativetimofficial/vue-black-dashboard">creativetimofficial&#x2F;vue-black-dashboard: Vue Black Dashboard (github.com)</a></p>
<p>登录注册界面比较容易写，接下来试试登录后的管理界面以及展示界面。即 <strong>DashBoard</strong></p>
<p>说是实战其实是消化理解一下大佬的项目。</p>
<p>看了一会才发现是纯前端，没有连接后端的代码。</p>
<h3 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h3><blockquote>
<p>i18n 是指在软件、应用程序或网站开发过程中，通过适当的设计和编程，使其能够方便地支持不同的语言、地区和文化规范，而无需对代码进行大量修改。i18n 是实现全球化（globalization，g11n）的重要组成部分。</p>
</blockquote>
<h1 id="使用项目接口为自己的项目服务"><a href="#使用项目接口为自己的项目服务" class="headerlink" title="使用项目接口为自己的项目服务"></a>使用项目接口为自己的项目服务</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DashboardPlugin</span> <span class="keyword">from</span> <span class="string">&#x27;@/plugins/blackDashboard&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">DashboardPlugin</span>);</span><br></pre></td></tr></table></figure>



<h1 id="AXIOS"><a href="#AXIOS" class="headerlink" title="AXIOS"></a>AXIOS</h1><p>基于 Promise 的 HTTP 客户端，可以用在浏览器和 Node.js 中。适合用于 Vue 项目中进行 API 请求。</p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网水控系统硬件部分</title>
    <url>/2024/10/11/%E7%89%A9%E8%81%94%E7%BD%91%E6%B0%B4%E6%8E%A7%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>硬件部分实现记录</p>
<h1 id="PCB-电路图"><a href="#PCB-电路图" class="headerlink" title="PCB&amp;电路图"></a>PCB&amp;电路图</h1><h2 id="esp32-wroom-32E"><a href="#esp32-wroom-32E" class="headerlink" title="esp32-wroom-32E"></a>esp32-wroom-32E</h2><h3 id="下载电路"><a href="#下载电路" class="headerlink" title="下载电路"></a>下载电路</h3><ul>
<li><p>串口烧录</p>
<ul>
<li>IO1（tx）&amp;IO3（rx）：与CH340C连接</li>
</ul>
</li>
<li><p>自动烧录</p>
<ul>
<li><p>烧录条件</p>
<p>  <img src="/../images/iotWaterPump/hardware/2.png"></p>
</li>
<li><p>原理图</p>
<p>  <img src="/../images/iotWaterPump/hardware/3.png"></p>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/iotWaterPump/hardware/4.png"></p>
<h2 id="CH340C"><a href="#CH340C" class="headerlink" title="CH340C"></a>CH340C</h2><ul>
<li><p>RXD &amp; TXD 串口输入输出</p>
</li>
<li><p>D+ &amp; D- USB  输入</p>
</li>
<li><p>VCC</p>
<blockquote>
<p>Positive power input terminal, requires an external </p>
<p>0.1uF power decoupling capacitor. </p>
<p>去耦电容（Decoupling Capacitor）是电子电路设计中常用的一种电容，主要用于稳定电源电压，减少电源噪声和干扰，确保电路的正常工作。</p>
</blockquote>
</li>
<li><p>V3 </p>
<blockquote>
<p>When the power supply voltage is 3.3V, connect </p>
<p>VCC to input the external power supply. When the </p>
<p>power supply voltage is 5V, connect an external </p>
<p>decoupling capacitor with a capacity of 0.1uF. </p>
</blockquote>
</li>
<li><p><strong>RTS# &amp; DTR#</strong></p>
<blockquote>
<p>进行esp32的自动下载电路</p>
</blockquote>
<ul>
<li><p>DTR#</p>
<blockquote>
<p>MODEM contact output signal, data terminal ready, </p>
<p>active low (high) </p>
</blockquote>
</li>
<li><p>RTS# </p>
<blockquote>
<p>MODEM contact output signal, request to send, </p>
<p>active low (high)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/iotWaterPump/hardware/1.png"></p>
<h2 id="继电器模块"><a href="#继电器模块" class="headerlink" title="继电器模块"></a>继电器模块</h2><p><img src="/../images/iotWaterPump/hardware/5.png"></p>
<h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p><img src="/../images/iotwaterpump/hardware/pcb.png"></p>
]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>esp8266</tag>
        <tag>esp32</tag>
        <tag>Iot</tag>
        <tag>物联网协议</tag>
      </tags>
  </entry>
  <entry>
    <title>基于python的聊天脚本</title>
    <url>/2024/10/13/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E8%81%8A%E5%A4%A9%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>用于学习tcp&#x2F;ip协议的脚本。</p>
<p>目标：实现不同网络主机之间的通信</p>
<ol>
<li>服务器一直运行，获取用户请求，转发客服消息。</li>
<li>类似mqtt协议分类为不同频道。</li>
<li>用户登录只需提供昵称。</li>
</ol>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
        <tag>计算机网络</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门基础知识</title>
    <url>/2024/10/31/Nginx%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>最近Nginx部署用的多点，学过的tomcat仅仅适合用于java项目。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>开源的高性能 HTTP 服务器和反向代理服务器</p>
<p>IMAP&#x2F;POP3 邮件代理服务器</p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>高并发处理能力</li>
<li>反向代理和负载均衡</li>
<li>动静分离</li>
<li>高效的静态文件服务</li>
<li>支持多种协议</li>
</ol>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理充当客户端和后端服务器之间的中间层。它的作用是接收客户端的请求，转发给后端服务器处理，然后将处理结果返回给客户端。使用反向代理的主要目的是提高系统性能、安全性和可扩展性。Nginx 和 Apache 等服务器软件通常被配置为反向代理。</p>
<h3 id="单个服务器使用反向代理"><a href="#单个服务器使用反向代理" class="headerlink" title="单个服务器使用反向代理"></a>单个服务器使用反向代理</h3><p>可以用于分发请求、缓存静态资源、隐藏后端服务等</p>
<p><strong>优势：</strong></p>
<p><strong>安全性</strong>：隐藏后端服务器的 IP，防止直接攻击。</p>
<p><strong>可扩展性</strong>：在需要扩展时，可以在同一 Nginx 配置下代理多个应用或服务。</p>
<p><strong>性能优化</strong>：通过缓存静态资源和 SSL 卸载，提升整体性能。</p>
<h3 id="多个服务器使用反向代理"><a href="#多个服务器使用反向代理" class="headerlink" title="多个服务器使用反向代理"></a>多个服务器使用反向代理</h3><p>后端服务器不需要直接连接互联网，只要它们和反向代理服务器（例如 Nginx）在同一个内网中。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>安全性</strong><ul>
<li>后端服务器的 IP 地址不会暴露在公网上，降低了受到外部攻击的风险。</li>
<li>可以通过 Nginx 过滤和控制访问，进一步增强安全性。</li>
</ul>
</li>
<li><strong>负载均衡和容错</strong><ul>
<li>Nginx 可以使用负载均衡策略在内网中将请求分发到多台服务器上，提高系统的整体并发能力。</li>
<li>通过健康检查，Nginx 可以检测后端服务器的状态，自动跳过故障服务器，提高系统容错能力。</li>
</ul>
</li>
<li><strong>简化配置</strong><ul>
<li>后端服务器只需与反向代理服务器（Nginx）进行通讯，而不需要考虑公网的 IP 和 DNS 配置，简化了网络配置。</li>
<li>通过内网 IP 直接访问，减少了外部因素的影响，通信效率更高。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式服务器基础知识</title>
    <url>/2024/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>最近常常看到分布式这个词，好记性不如烂键盘，简单记录记录，并没有深入研究。</p>
<h1 id="分布式服务器架构"><a href="#分布式服务器架构" class="headerlink" title="分布式服务器架构"></a>分布式服务器架构</h1><blockquote>
<p>分布式服务器架构是一种将服务和计算任务分散到多个服务器或节点上来处理的系统架构。</p>
</blockquote>
<h2 id="目的或者功能"><a href="#目的或者功能" class="headerlink" title="目的或者功能"></a>目的或者功能</h2><blockquote>
<ol>
<li>提高系统的性能、可用性和扩展性。</li>
<li>适合应对高并发访问和海量数据处理的需求。</li>
<li>分布式架构的核心理念是将负载分摊到多个服务器上，避免单点故障（SPOF），并根据需求动态扩展。</li>
</ol>
</blockquote>
<h1 id="分布式服务器架构的主要组成和常见设计模式"><a href="#分布式服务器架构的主要组成和常见设计模式" class="headerlink" title="分布式服务器架构的主要组成和常见设计模式"></a>分布式服务器架构的主要组成和常见设计模式</h1><h2 id="主要组成"><a href="#主要组成" class="headerlink" title="主要组成"></a>主要组成</h2><h3 id="1-负载均衡层"><a href="#1-负载均衡层" class="headerlink" title="1. 负载均衡层"></a>1. <strong>负载均衡层</strong></h3><ul>
<li><strong>功能</strong>：将用户请求分发到多个服务器节点，避免单个服务器过载。</li>
<li><strong>实现方式</strong>：常用的负载均衡工具有硬件负载均衡（如 F5）和软件负载均衡（如 Nginx、HAProxy）。</li>
<li><strong>常见策略</strong>：轮询、加权轮询、最小连接、IP 哈希等，选择最佳策略分发流量。</li>
</ul>
<h3 id="2-应用服务层"><a href="#2-应用服务层" class="headerlink" title="2. 应用服务层"></a>2. <strong>应用服务层</strong></h3><ul>
<li><p><strong>功能</strong>：部署核心应用逻辑，如 Web 应用、API 服务、后端管理系统等。</p>
</li>
<li><p>架构模式</p>
<p>  ：微服务架构和单体架构。</p>
<ul>
<li><strong>微服务架构</strong>：将应用拆分为多个独立服务，每个服务独立部署和管理，便于扩展和更新。</li>
<li><strong>单体架构</strong>：应用服务集中于一台服务器或一个容器内，适合小型系统。</li>
</ul>
</li>
<li><p><strong>技术栈</strong>：可以选择基于 Spring Boot、Flask、Django、Node.js 等的框架。</p>
</li>
</ul>
<h3 id="3-缓存层"><a href="#3-缓存层" class="headerlink" title="3. 缓存层"></a>3. <strong>缓存层</strong></h3><ul>
<li><strong>功能</strong>：减少数据库压力，加快响应速度，存储经常访问的数据。</li>
<li><strong>常用缓存技术</strong>：Redis、Memcached 等。</li>
<li><strong>缓存策略</strong>：设置缓存过期时间（TTL）、缓存更新策略（LRU、LFU）等来优化缓存使用。</li>
</ul>
<h3 id="4-数据库层"><a href="#4-数据库层" class="headerlink" title="4. 数据库层"></a>4. <strong>数据库层</strong></h3><ul>
<li><strong>功能</strong>：持久化存储系统的数据，支持查询和事务处理。</li>
<li><strong>数据库分布</strong>：分库分表、读写分离、主从同步。</li>
<li><strong>常见数据库</strong>：MySQL、PostgreSQL（关系型数据库），MongoDB、Cassandra（非关系型数据库）。</li>
<li><strong>数据同步</strong>：使用主从复制、分片（Sharding）等技术提高数据访问性能和可用性。</li>
</ul>
<h3 id="5-消息队列层"><a href="#5-消息队列层" class="headerlink" title="5. 消息队列层"></a>5. <strong>消息队列层</strong></h3><ul>
<li><strong>功能</strong>：在系统内部传递消息，解耦不同服务模块，适合高并发需求。</li>
<li><strong>常用消息队列</strong>：RabbitMQ、Kafka、ActiveMQ 等。</li>
<li><strong>应用场景</strong>：订单处理、消息通知、日志存储等高并发场景。</li>
</ul>
<h3 id="6-文件存储层"><a href="#6-文件存储层" class="headerlink" title="6. 文件存储层"></a>6. <strong>文件存储层</strong></h3><ul>
<li><strong>功能</strong>：存储文件、图片、视频等大数据文件。</li>
<li><strong>常用技术</strong>：分布式文件系统（如 HDFS）、对象存储（如 AWS S3、阿里云 OSS）。</li>
<li><strong>适用场景</strong>：大文件上传、图片存储、备份数据等。</li>
</ul>
<h3 id="7-监控和日志系统"><a href="#7-监控和日志系统" class="headerlink" title="7. 监控和日志系统"></a>7. <strong>监控和日志系统</strong></h3><ul>
<li><strong>功能</strong>：实时监控系统的状态、日志记录，便于发现故障和优化系统。</li>
<li><strong>常用工具</strong>：Prometheus、Grafana、ELK（Elasticsearch、Logstash、Kibana）等。</li>
<li><strong>功能</strong>：监控 CPU、内存、网络流量，分析错误日志等，确保系统稳定。</li>
</ul>
<h2 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h2><ol>
<li><strong>微服务架构</strong>：将单体应用拆分为多个独立的服务，每个服务独立开发和部署，易于扩展。</li>
<li><strong>服务网格</strong>：通常用于管理微服务间的通信，确保服务间通信的安全性、可靠性和可观测性。</li>
<li><strong>CQRS 和事件溯源</strong>：使用不同模型处理读写请求，并记录系统的每次状态变更以支持回溯。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="系统复杂性增加"><a href="#系统复杂性增加" class="headerlink" title="系统复杂性增加"></a>系统复杂性增加</h3><ul>
<li>分布式架构涉及多个模块和服务的协调工作，相比单体架构，系统设计和开发变得更复杂。</li>
<li>服务之间的通信、数据同步、容错等都需要精细的设计和测试，开发成本和时间显著增加。</li>
<li>开发人员需要掌握分布式系统的知识，如一致性算法、分布式锁等，增加了技术要求。</li>
</ul>
<h3 id="数据一致性难以保障"><a href="#数据一致性难以保障" class="headerlink" title="数据一致性难以保障"></a>数据一致性难以保障</h3><ul>
<li>在分布式系统中，数据可能分散在不同的节点上，维护一致性变得困难。</li>
<li>CAP 理论（Consistency, Availability, Partition tolerance）指出分布式系统无法同时满足一致性、可用性和分区容错性，这导致设计时需在一致性和可用性之间进行权衡。</li>
<li>常用的一致性方案，如最终一致性、强一致性等，都有各自的复杂性和延迟问题。</li>
</ul>
<h3 id="网络通信开销"><a href="#网络通信开销" class="headerlink" title="网络通信开销"></a>网络通信开销</h3><ul>
<li>分布式架构中，各个节点通过网络通信相互协作，网络延迟、带宽限制等因素会影响系统性能。</li>
<li>网络故障会导致部分节点不可用，甚至造成服务的暂时中断。</li>
<li>额外的通信开销还可能增加系统的成本，如需要负载均衡器、API 网关等组件来优化网络流量。</li>
</ul>
<h3 id="部署和运维成本高"><a href="#部署和运维成本高" class="headerlink" title="部署和运维成本高"></a>部署和运维成本高</h3><ul>
<li>分布式架构通常需要更多的硬件和软件资源，以及专业的运维团队来支持系统的运行。</li>
<li>部署需要对多个节点和服务进行管理，更新和回滚复杂，尤其是在微服务架构中。</li>
<li>持续集成、持续交付（CI&#x2F;CD）流程的复杂度增加，需要额外的工具和策略来确保部署的稳定性。</li>
</ul>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="分布式mqtt服务器"><a href="#分布式mqtt服务器" class="headerlink" title="分布式mqtt服务器"></a>分布式mqtt服务器</h2><p>分布式 MQTT 服务器架构设计是为了实现 MQTT 消息的高可用性、高扩展性和高并发处理。分布式 MQTT 服务器可以承载大量物联网设备的连接，同时能够保证消息的快速分发和数据的一致性。在设计和实现分布式 MQTT 服务器时，通常会使用负载均衡、集群、数据分片、消息持久化等技术。</p>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>Spring Cloud、Kubernetes、Docker、Istio。将应用拆分为多个独立的服务，每个服务独立开发、部署和扩展，适合大型企业系统的开发。分布式服务独立运作，降低单个服务出错影响，全栈服务自主扩展，可快速响应不同功能模块的需求。</p>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>Bitcoin、Ethereum、Hyperledger Fabric、Polkadot。构建去中心化系统，支持加密货币交易、智能合约、数据安全和隐私保护。采用分布式账本、共识算法、加密技术，数据公开透明且难以篡改，适用于去中心化应用（DApp）和数据溯源等。</p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>分布式服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32开发板绘制（首次使用嘉立创SMT）</title>
    <url>/2024/10/31/STM32%E5%BC%80%E5%8F%91%E6%9D%BF%E7%BB%98%E5%88%B6%EF%BC%88%E9%A6%96%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%98%89%E7%AB%8B%E5%88%9BSMT%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>硬件技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>嵌入式</tag>
        <tag>STM32</tag>
        <tag>PCB</tag>
        <tag>项目</tag>
        <tag>最小系统</tag>
        <tag>SMT</tag>
        <tag>嘉立创</tag>
      </tags>
  </entry>
</search>
